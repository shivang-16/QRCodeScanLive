"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/barcode-detector";
exports.ids = ["vendor-chunks/barcode-detector"];
exports.modules = {

/***/ "(ssr)/./node_modules/barcode-detector/dist/es/index.js":
/*!********************************************************!*\
  !*** ./node_modules/barcode-detector/dist/es/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BarcodeDetector: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__.BarcodeDetector),\n/* harmony export */   ZXING_CPP_COMMIT: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__.ZXING_CPP_COMMIT),\n/* harmony export */   ZXING_WASM_SHA256: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__.ZXING_WASM_SHA256),\n/* harmony export */   ZXING_WASM_VERSION: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__.ZXING_WASM_VERSION),\n/* harmony export */   prepareZXingModule: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__.prepareZXingModule),\n/* harmony export */   purgeZXingModule: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__.purgeZXingModule),\n/* harmony export */   setZXingModuleOverrides: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__.setZXingModuleOverrides)\n/* harmony export */ });\n/* harmony import */ var _polyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polyfill.js */ \"(ssr)/./node_modules/barcode-detector/dist/es/polyfill.js\");\n/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ponyfill.js */ \"(ssr)/./node_modules/barcode-detector/dist/es/ponyfill.js\");\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFyY29kZS1kZXRlY3Rvci9kaXN0L2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF1QjtBQUNvTDtBQVN6TSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvYmFyY29kZS1kZXRlY3Rvci9kaXN0L2VzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBcIi4vcG9seWZpbGwuanNcIjtcbmltcG9ydCB7IEJhcmNvZGVEZXRlY3RvciBhcyBNLCBaWElOR19DUFBfQ09NTUlUIGFzIFgsIFpYSU5HX1dBU01fU0hBMjU2IGFzIFosIFpYSU5HX1dBU01fVkVSU0lPTiBhcyBfLCBwcmVwYXJlWlhpbmdNb2R1bGUgYXMgZCwgcHVyZ2VaWGluZ01vZHVsZSBhcyBpLCBzZXRaWGluZ01vZHVsZU92ZXJyaWRlcyBhcyBwIH0gZnJvbSBcIi4vcG9ueWZpbGwuanNcIjtcbmV4cG9ydCB7XG4gIE0gYXMgQmFyY29kZURldGVjdG9yLFxuICBYIGFzIFpYSU5HX0NQUF9DT01NSVQsXG4gIFogYXMgWlhJTkdfV0FTTV9TSEEyNTYsXG4gIF8gYXMgWlhJTkdfV0FTTV9WRVJTSU9OLFxuICBkIGFzIHByZXBhcmVaWGluZ01vZHVsZSxcbiAgaSBhcyBwdXJnZVpYaW5nTW9kdWxlLFxuICBwIGFzIHNldFpYaW5nTW9kdWxlT3ZlcnJpZGVzXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/barcode-detector/dist/es/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/barcode-detector/dist/es/polyfill.js":
/*!***********************************************************!*\
  !*** ./node_modules/barcode-detector/dist/es/polyfill.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZXING_CPP_COMMIT: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.ZXING_CPP_COMMIT),\n/* harmony export */   ZXING_WASM_SHA256: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.ZXING_WASM_SHA256),\n/* harmony export */   ZXING_WASM_VERSION: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.ZXING_WASM_VERSION),\n/* harmony export */   prepareZXingModule: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.prepareZXingModule),\n/* harmony export */   purgeZXingModule: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.purgeZXingModule),\n/* harmony export */   setZXingModuleOverrides: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.setZXingModuleOverrides)\n/* harmony export */ });\n/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ponyfill.js */ \"(ssr)/./node_modules/barcode-detector/dist/es/ponyfill.js\");\n\n\nvar e;\n(e = globalThis.BarcodeDetector) != null || (globalThis.BarcodeDetector = _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.BarcodeDetector);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFyY29kZS1kZXRlY3Rvci9kaXN0L2VzL3BvbHlmaWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBcUQ7QUFDZ0k7QUFDckw7QUFDQSwwRUFBMEUseURBQUM7QUFRekUiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL2JhcmNvZGUtZGV0ZWN0b3IvZGlzdC9lcy9wb2x5ZmlsbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXJjb2RlRGV0ZWN0b3IgYXMgciB9IGZyb20gXCIuL3BvbnlmaWxsLmpzXCI7XG5pbXBvcnQgeyBaWElOR19DUFBfQ09NTUlUIGFzIGQsIFpYSU5HX1dBU01fU0hBMjU2IGFzIGksIFpYSU5HX1dBU01fVkVSU0lPTiBhcyBYLCBwcmVwYXJlWlhpbmdNb2R1bGUgYXMgWiwgcHVyZ2VaWGluZ01vZHVsZSBhcyBfLCBzZXRaWGluZ01vZHVsZU92ZXJyaWRlcyBhcyBnIH0gZnJvbSBcIi4vcG9ueWZpbGwuanNcIjtcbnZhciBlO1xuKGUgPSBnbG9iYWxUaGlzLkJhcmNvZGVEZXRlY3RvcikgIT0gbnVsbCB8fCAoZ2xvYmFsVGhpcy5CYXJjb2RlRGV0ZWN0b3IgPSByKTtcbmV4cG9ydCB7XG4gIGQgYXMgWlhJTkdfQ1BQX0NPTU1JVCxcbiAgaSBhcyBaWElOR19XQVNNX1NIQTI1NixcbiAgWCBhcyBaWElOR19XQVNNX1ZFUlNJT04sXG4gIFogYXMgcHJlcGFyZVpYaW5nTW9kdWxlLFxuICBfIGFzIHB1cmdlWlhpbmdNb2R1bGUsXG4gIGcgYXMgc2V0WlhpbmdNb2R1bGVPdmVycmlkZXNcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/barcode-detector/dist/es/polyfill.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/barcode-detector/dist/es/ponyfill.js":
/*!***********************************************************!*\
  !*** ./node_modules/barcode-detector/dist/es/ponyfill.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BarcodeDetector: () => (/* binding */ Eo),\n/* harmony export */   ZXING_CPP_COMMIT: () => (/* binding */ bo),\n/* harmony export */   ZXING_WASM_SHA256: () => (/* binding */ Po),\n/* harmony export */   ZXING_WASM_VERSION: () => (/* binding */ $o),\n/* harmony export */   prepareZXingModule: () => (/* binding */ Be),\n/* harmony export */   purgeZXingModule: () => (/* binding */ Co),\n/* harmony export */   setZXingModuleOverrides: () => (/* binding */ To)\n/* harmony export */ });\nvar Ae = (o) => {\n  throw TypeError(o);\n};\nvar Se = (o, f, c) => f.has(o) || Ae(\"Cannot \" + c);\nvar Ie = (o, f, c) => (Se(o, f, \"read from private field\"), c ? c.call(o) : f.get(o)), De = (o, f, c) => f.has(o) ? Ae(\"Cannot add the same private member more than once\") : f instanceof WeakSet ? f.add(o) : f.set(o, c), Me = (o, f, c, T) => (Se(o, f, \"write to private field\"), T ? T.call(o, c) : f.set(o, c), c);\nconst Dt = [\n  [\"Aztec\", \"M\"],\n  [\"Codabar\", \"L\"],\n  [\"Code39\", \"L\"],\n  [\"Code93\", \"L\"],\n  [\"Code128\", \"L\"],\n  [\"DataBar\", \"L\"],\n  [\"DataBarExpanded\", \"L\"],\n  [\"DataMatrix\", \"M\"],\n  [\"EAN-8\", \"L\"],\n  [\"EAN-13\", \"L\"],\n  [\"ITF\", \"L\"],\n  [\"MaxiCode\", \"M\"],\n  [\"PDF417\", \"M\"],\n  [\"QRCode\", \"M\"],\n  [\"UPC-A\", \"L\"],\n  [\"UPC-E\", \"L\"],\n  [\"MicroQRCode\", \"M\"],\n  [\"rMQRCode\", \"M\"],\n  [\"DXFilmEdge\", \"L\"],\n  [\"DataBarLimited\", \"L\"]\n], Mt = Dt.map(([o]) => o), La = Mt.filter(\n  (o, f) => Dt[f][1] === \"L\"\n), Ba = Mt.filter(\n  (o, f) => Dt[f][1] === \"M\"\n);\nfunction Yt(o) {\n  switch (o) {\n    case \"Linear-Codes\":\n      return La.reduce((f, c) => f | Yt(c), 0);\n    case \"Matrix-Codes\":\n      return Ba.reduce((f, c) => f | Yt(c), 0);\n    case \"Any\":\n      return (1 << Dt.length) - 1;\n    case \"None\":\n      return 0;\n    default:\n      return 1 << Mt.indexOf(o);\n  }\n}\nfunction Wa(o) {\n  if (o === 0)\n    return \"None\";\n  const f = 31 - Math.clz32(o);\n  return Mt[f];\n}\nfunction Ua(o) {\n  return o.reduce((f, c) => f | Yt(c), 0);\n}\nconst Va = [\n  \"LocalAverage\",\n  \"GlobalHistogram\",\n  \"FixedThreshold\",\n  \"BoolCast\"\n];\nfunction ka(o) {\n  return Va.indexOf(o);\n}\nconst Fe = [\n  \"Unknown\",\n  \"ASCII\",\n  \"ISO8859_1\",\n  \"ISO8859_2\",\n  \"ISO8859_3\",\n  \"ISO8859_4\",\n  \"ISO8859_5\",\n  \"ISO8859_6\",\n  \"ISO8859_7\",\n  \"ISO8859_8\",\n  \"ISO8859_9\",\n  \"ISO8859_10\",\n  \"ISO8859_11\",\n  \"ISO8859_13\",\n  \"ISO8859_14\",\n  \"ISO8859_15\",\n  \"ISO8859_16\",\n  \"Cp437\",\n  \"Cp1250\",\n  \"Cp1251\",\n  \"Cp1252\",\n  \"Cp1256\",\n  \"Shift_JIS\",\n  \"Big5\",\n  \"GB2312\",\n  \"GB18030\",\n  \"EUC_JP\",\n  \"EUC_KR\",\n  \"UTF16BE\",\n  /**\n   * UnicodeBig [[deprecated]]\n   */\n  \"UTF16BE\",\n  \"UTF8\",\n  \"UTF16LE\",\n  \"UTF32BE\",\n  \"UTF32LE\",\n  \"BINARY\"\n];\nfunction Ha(o) {\n  return o === \"UnicodeBig\" ? Fe.indexOf(\"UTF16BE\") : Fe.indexOf(o);\n}\nconst Na = [\n  \"Text\",\n  \"Binary\",\n  \"Mixed\",\n  \"GS1\",\n  \"ISO15434\",\n  \"UnknownECI\"\n];\nfunction za(o) {\n  return Na[o];\n}\nconst Ga = [\"Ignore\", \"Read\", \"Require\"];\nfunction Xa(o) {\n  return Ga.indexOf(o);\n}\nconst qa = [\"Plain\", \"ECI\", \"HRI\", \"Hex\", \"Escaped\"];\nfunction Ya(o) {\n  return qa.indexOf(o);\n}\nconst It = {\n  formats: [],\n  tryHarder: !0,\n  tryRotate: !0,\n  tryInvert: !0,\n  tryDownscale: !0,\n  tryDenoise: !1,\n  binarizer: \"LocalAverage\",\n  isPure: !1,\n  downscaleFactor: 3,\n  downscaleThreshold: 500,\n  minLineCount: 2,\n  maxNumberOfSymbols: 255,\n  tryCode39ExtendedMode: !0,\n  returnErrors: !1,\n  eanAddOnSymbol: \"Ignore\",\n  textMode: \"HRI\",\n  characterSet: \"Unknown\"\n};\nfunction je(o) {\n  return {\n    ...o,\n    formats: Ua(o.formats),\n    binarizer: ka(o.binarizer),\n    eanAddOnSymbol: Xa(o.eanAddOnSymbol),\n    textMode: Ya(o.textMode),\n    characterSet: Ha(o.characterSet)\n  };\n}\nfunction Za(o) {\n  return {\n    ...o,\n    format: Wa(o.format),\n    contentType: za(o.contentType),\n    eccLevel: o.ecLevel\n  };\n}\nconst $o = \"2.1.2\", bo = \"a1516b34167cff504bf3c83698ea841e13a8f7f1\", Qa = {\n  locateFile: (o, f) => {\n    const c = o.match(/_(.+?)\\.wasm$/);\n    return c ? `https://fastly.jsdelivr.net/npm/zxing-wasm@2.1.2/dist/${c[1]}/${o}` : f + o;\n  }\n}, St = /* @__PURE__ */ new WeakMap();\nfunction Ja(o, f) {\n  return Object.is(o, f) || Object.keys(o).length === Object.keys(f).length && Object.keys(o).every(\n    (c) => Object.prototype.hasOwnProperty.call(f, c) && o[c] === f[c]\n  );\n}\nfunction Le(o, {\n  overrides: f,\n  equalityFn: c = Ja,\n  fireImmediately: T = !1\n} = {}) {\n  var $;\n  const [x, D] = ($ = St.get(o)) != null ? $ : [Qa], R = f != null ? f : x;\n  let O;\n  if (T) {\n    if (D && (O = c(x, R)))\n      return D;\n    const M = o({\n      ...R\n    });\n    return St.set(o, [R, M]), M;\n  }\n  (O != null ? O : c(x, R)) || St.set(o, [R]);\n}\nfunction Ka(o) {\n  St.delete(o);\n}\nasync function to(o, f, c = It) {\n  const T = {\n    ...It,\n    ...c\n  }, $ = await Le(o, {\n    fireImmediately: !0\n  });\n  let x, D;\n  if (\"width\" in f && \"height\" in f && \"data\" in f) {\n    const {\n      data: O,\n      data: { byteLength: M },\n      width: F,\n      height: q\n    } = f;\n    D = $._malloc(M), $.HEAPU8.set(O, D), x = $.readBarcodesFromPixmap(\n      D,\n      F,\n      q,\n      je(T)\n    );\n  } else {\n    let O, M;\n    if (\"buffer\" in f)\n      [O, M] = [f.byteLength, f];\n    else if (\"byteLength\" in f)\n      [O, M] = [f.byteLength, new Uint8Array(f)];\n    else if (\"size\" in f)\n      [O, M] = [f.size, new Uint8Array(await f.arrayBuffer())];\n    else\n      throw new TypeError(\"Invalid input type\");\n    D = $._malloc(O), $.HEAPU8.set(M, D), x = $.readBarcodesFromImage(\n      D,\n      O,\n      je(T)\n    );\n  }\n  $._free(D);\n  const R = [];\n  for (let O = 0; O < x.size(); ++O)\n    R.push(\n      Za(x.get(O))\n    );\n  return R;\n}\n({\n  ...It,\n  formats: [...It.formats]\n});\nvar Qt = async function(o = {}) {\n  var f, c = o, T, $, x = new Promise((e, t) => {\n    T = e, $ = t;\n  }), D = typeof window == \"object\", R = typeof Bun < \"u\", O = typeof WorkerGlobalScope < \"u\";\n  typeof process == \"object\" && typeof process.versions == \"object\" && typeof process.versions.node == \"string\" && process.type != \"renderer\";\n  var M = \"./this.program\", F = \"\";\n  function q(e) {\n    return c.locateFile ? c.locateFile(e, F) : F + e;\n  }\n  var rt, Y;\n  (D || O || R) && (O ? F = self.location.href : typeof document < \"u\" && document.currentScript && (F = document.currentScript.src), F.startsWith(\"blob:\") ? F = \"\" : F = F.slice(0, F.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1), O && (Y = (e) => {\n    var t = new XMLHttpRequest();\n    return t.open(\"GET\", e, !1), t.responseType = \"arraybuffer\", t.send(null), new Uint8Array(t.response);\n  }), rt = async (e) => {\n    var t = await fetch(e, {\n      credentials: \"same-origin\"\n    });\n    if (t.ok)\n      return t.arrayBuffer();\n    throw new Error(t.status + \" : \" + t.url);\n  });\n  var st = console.log.bind(console), k = console.error.bind(console), Z, nt, Jt = !1, Q, B, ut, vt, at, P, Kt, te;\n  function ee() {\n    var e = nt.buffer;\n    Q = new Int8Array(e), ut = new Int16Array(e), c.HEAPU8 = B = new Uint8Array(e), vt = new Uint16Array(e), at = new Int32Array(e), P = new Uint32Array(e), Kt = new Float32Array(e), te = new Float64Array(e);\n  }\n  function qe() {\n    if (c.preRun)\n      for (typeof c.preRun == \"function\" && (c.preRun = [c.preRun]); c.preRun.length; )\n        sr(c.preRun.shift());\n    re(ae);\n  }\n  function Ye() {\n    E.ya();\n  }\n  function Ze() {\n    if (c.postRun)\n      for (typeof c.postRun == \"function\" && (c.postRun = [c.postRun]); c.postRun.length; )\n        ir(c.postRun.shift());\n    re(ne);\n  }\n  var J = 0, ct = null;\n  function Qe(e) {\n    var t;\n    J++, (t = c.monitorRunDependencies) === null || t === void 0 || t.call(c, J);\n  }\n  function Je(e) {\n    var t;\n    if (J--, (t = c.monitorRunDependencies) === null || t === void 0 || t.call(c, J), J == 0 && ct) {\n      var r = ct;\n      ct = null, r();\n    }\n  }\n  function Ft(e) {\n    var t;\n    (t = c.onAbort) === null || t === void 0 || t.call(c, e), e = \"Aborted(\" + e + \")\", k(e), Jt = !0, e += \". Build with -sASSERTIONS for more info.\";\n    var r = new WebAssembly.RuntimeError(e);\n    throw $(r), r;\n  }\n  var yt;\n  function Ke() {\n    return q(\"zxing_reader.wasm\");\n  }\n  function tr(e) {\n    if (e == yt && Z)\n      return new Uint8Array(Z);\n    if (Y)\n      return Y(e);\n    throw \"both async and sync fetching of the wasm failed\";\n  }\n  async function er(e) {\n    if (!Z)\n      try {\n        var t = await rt(e);\n        return new Uint8Array(t);\n      } catch {\n      }\n    return tr(e);\n  }\n  async function rr(e, t) {\n    try {\n      var r = await er(e), n = await WebAssembly.instantiate(r, t);\n      return n;\n    } catch (a) {\n      k(`failed to asynchronously prepare wasm: ${a}`), Ft(a);\n    }\n  }\n  async function nr(e, t, r) {\n    if (!e && typeof WebAssembly.instantiateStreaming == \"function\")\n      try {\n        var n = fetch(t, {\n          credentials: \"same-origin\"\n        }), a = await WebAssembly.instantiateStreaming(n, r);\n        return a;\n      } catch (i) {\n        k(`wasm streaming compile failed: ${i}`), k(\"falling back to ArrayBuffer instantiation\");\n      }\n    return rr(t, r);\n  }\n  function ar() {\n    return {\n      a: Hn\n    };\n  }\n  async function or() {\n    function e(i, u) {\n      return E = i.exports, nt = E.xa, ee(), pe = E.Ba, Je(), E;\n    }\n    Qe();\n    function t(i) {\n      return e(i.instance);\n    }\n    var r = ar();\n    if (c.instantiateWasm)\n      return new Promise((i, u) => {\n        c.instantiateWasm(r, (s, l) => {\n          i(e(s));\n        });\n      });\n    yt != null || (yt = Ke());\n    try {\n      var n = await nr(Z, yt, r), a = t(n);\n      return a;\n    } catch (i) {\n      return $(i), Promise.reject(i);\n    }\n  }\n  var re = (e) => {\n    for (; e.length > 0; )\n      e.shift()(c);\n  }, ne = [], ir = (e) => ne.push(e), ae = [], sr = (e) => ae.push(e), y = (e) => Xn(e), m = () => qn(), mt = [], gt = 0, ur = (e) => {\n    var t = new jt(e);\n    return t.get_caught() || (t.set_caught(!0), gt--), t.set_rethrown(!1), mt.push(t), Zn(e), zn(e);\n  }, H = 0, cr = () => {\n    v(0, 0);\n    var e = mt.pop();\n    Yn(e.excPtr), H = 0;\n  };\n  class jt {\n    constructor(t) {\n      this.excPtr = t, this.ptr = t - 24;\n    }\n    set_type(t) {\n      P[this.ptr + 4 >> 2] = t;\n    }\n    get_type() {\n      return P[this.ptr + 4 >> 2];\n    }\n    set_destructor(t) {\n      P[this.ptr + 8 >> 2] = t;\n    }\n    get_destructor() {\n      return P[this.ptr + 8 >> 2];\n    }\n    set_caught(t) {\n      t = t ? 1 : 0, Q[this.ptr + 12] = t;\n    }\n    get_caught() {\n      return Q[this.ptr + 12] != 0;\n    }\n    set_rethrown(t) {\n      t = t ? 1 : 0, Q[this.ptr + 13] = t;\n    }\n    get_rethrown() {\n      return Q[this.ptr + 13] != 0;\n    }\n    init(t, r) {\n      this.set_adjusted_ptr(0), this.set_type(t), this.set_destructor(r);\n    }\n    set_adjusted_ptr(t) {\n      P[this.ptr + 16 >> 2] = t;\n    }\n    get_adjusted_ptr() {\n      return P[this.ptr + 16 >> 2];\n    }\n  }\n  var wt = (e) => Gn(e), Rt = (e) => {\n    var t = H;\n    if (!t)\n      return wt(0), 0;\n    var r = new jt(t);\n    r.set_adjusted_ptr(t);\n    var n = r.get_type();\n    if (!n)\n      return wt(0), t;\n    for (var a of e) {\n      if (a === 0 || a === n)\n        break;\n      var i = r.ptr + 16;\n      if (Qn(a, n, i))\n        return wt(a), t;\n    }\n    return wt(n), t;\n  }, lr = () => Rt([]), fr = (e) => Rt([e]), dr = (e, t) => Rt([e, t]), hr = () => {\n    var e = mt.pop();\n    e || Ft(\"no exception to throw\");\n    var t = e.excPtr;\n    throw e.get_rethrown() || (mt.push(e), e.set_rethrown(!0), e.set_caught(!1), gt++), H = t, H;\n  }, pr = (e, t, r) => {\n    var n = new jt(e);\n    throw n.init(t, r), H = e, gt++, H;\n  }, vr = () => gt, yr = (e) => {\n    throw H || (H = e), H;\n  }, mr = () => Ft(\"\"), $t = {}, Lt = (e) => {\n    for (; e.length; ) {\n      var t = e.pop(), r = e.pop();\n      r(t);\n    }\n  };\n  function lt(e) {\n    return this.fromWireType(P[e >> 2]);\n  }\n  var ot = {}, K = {}, bt = {}, gr = c.InternalError = class extends Error {\n    constructor(e) {\n      super(e), this.name = \"InternalError\";\n    }\n  }, Ct = (e) => {\n    throw new gr(e);\n  }, tt = (e, t, r) => {\n    e.forEach((s) => bt[s] = t);\n    function n(s) {\n      var l = r(s);\n      l.length !== e.length && Ct(\"Mismatched type converter count\");\n      for (var d = 0; d < e.length; ++d)\n        V(e[d], l[d]);\n    }\n    var a = new Array(t.length), i = [], u = 0;\n    t.forEach((s, l) => {\n      K.hasOwnProperty(s) ? a[l] = K[s] : (i.push(s), ot.hasOwnProperty(s) || (ot[s] = []), ot[s].push(() => {\n        a[l] = K[s], ++u, u === i.length && n(a);\n      }));\n    }), i.length === 0 && n(a);\n  }, wr = (e) => {\n    var t = $t[e];\n    delete $t[e];\n    var r = t.rawConstructor, n = t.rawDestructor, a = t.fields, i = a.map((u) => u.getterReturnType).concat(a.map((u) => u.setterArgumentType));\n    tt([e], i, (u) => {\n      var s = {};\n      return a.forEach((l, d) => {\n        var h = l.fieldName, p = u[d], w = u[d].optional, b = l.getter, _ = l.getterContext, S = u[d + a.length], A = l.setter, I = l.setterContext;\n        s[h] = {\n          read: (X) => p.fromWireType(b(_, X)),\n          write: (X, L) => {\n            var W = [];\n            A(I, X, S.toWireType(W, L)), Lt(W);\n          },\n          optional: w\n        };\n      }), [{\n        name: t.name,\n        fromWireType: (l) => {\n          var d = {};\n          for (var h in s)\n            d[h] = s[h].read(l);\n          return n(l), d;\n        },\n        toWireType: (l, d) => {\n          for (var h in s)\n            if (!(h in d) && !s[h].optional)\n              throw new TypeError(`Missing field: \"${h}\"`);\n          var p = r();\n          for (h in s)\n            s[h].write(p, d[h]);\n          return l !== null && l.push(n, p), p;\n        },\n        argPackAdvance: N,\n        readValueFromPointer: lt,\n        destructorFunction: n\n      }];\n    });\n  }, $r = (e, t, r, n, a) => {\n  }, br = () => {\n    for (var e = new Array(256), t = 0; t < 256; ++t)\n      e[t] = String.fromCharCode(t);\n    oe = e;\n  }, oe, j = (e) => {\n    for (var t = \"\", r = e; B[r]; )\n      t += oe[B[r++]];\n    return t;\n  }, ft = c.BindingError = class extends Error {\n    constructor(e) {\n      super(e), this.name = \"BindingError\";\n    }\n  }, C = (e) => {\n    throw new ft(e);\n  };\n  function Cr(e, t) {\n    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var n = t.name;\n    if (e || C(`type \"${n}\" must have a positive integer typeid pointer`), K.hasOwnProperty(e)) {\n      if (r.ignoreDuplicateRegistrations)\n        return;\n      C(`Cannot register type '${n}' twice`);\n    }\n    if (K[e] = t, delete bt[e], ot.hasOwnProperty(e)) {\n      var a = ot[e];\n      delete ot[e], a.forEach((i) => i());\n    }\n  }\n  function V(e, t) {\n    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return Cr(e, t, r);\n  }\n  var N = 8, Tr = (e, t, r, n) => {\n    t = j(t), V(e, {\n      name: t,\n      fromWireType: function(a) {\n        return !!a;\n      },\n      toWireType: function(a, i) {\n        return i ? r : n;\n      },\n      argPackAdvance: N,\n      readValueFromPointer: function(a) {\n        return this.fromWireType(B[a]);\n      },\n      destructorFunction: null\n    });\n  }, Pr = (e) => ({\n    count: e.count,\n    deleteScheduled: e.deleteScheduled,\n    preservePointerOnDelete: e.preservePointerOnDelete,\n    ptr: e.ptr,\n    ptrType: e.ptrType,\n    smartPtr: e.smartPtr,\n    smartPtrType: e.smartPtrType\n  }), Bt = (e) => {\n    function t(r) {\n      return r.$$.ptrType.registeredClass.name;\n    }\n    C(t(e) + \" instance already deleted\");\n  }, Wt = !1, ie = (e) => {\n  }, Er = (e) => {\n    e.smartPtr ? e.smartPtrType.rawDestructor(e.smartPtr) : e.ptrType.registeredClass.rawDestructor(e.ptr);\n  }, se = (e) => {\n    e.count.value -= 1;\n    var t = e.count.value === 0;\n    t && Er(e);\n  }, dt = (e) => typeof FinalizationRegistry > \"u\" ? (dt = (t) => t, e) : (Wt = new FinalizationRegistry((t) => {\n    se(t.$$);\n  }), dt = (t) => {\n    var r = t.$$, n = !!r.smartPtr;\n    if (n) {\n      var a = {\n        $$: r\n      };\n      Wt.register(t, a, t);\n    }\n    return t;\n  }, ie = (t) => Wt.unregister(t), dt(e)), _r = () => {\n    let e = Tt.prototype;\n    Object.assign(e, {\n      isAliasOf(r) {\n        if (!(this instanceof Tt) || !(r instanceof Tt))\n          return !1;\n        var n = this.$$.ptrType.registeredClass, a = this.$$.ptr;\n        r.$$ = r.$$;\n        for (var i = r.$$.ptrType.registeredClass, u = r.$$.ptr; n.baseClass; )\n          a = n.upcast(a), n = n.baseClass;\n        for (; i.baseClass; )\n          u = i.upcast(u), i = i.baseClass;\n        return n === i && a === u;\n      },\n      clone() {\n        if (this.$$.ptr || Bt(this), this.$$.preservePointerOnDelete)\n          return this.$$.count.value += 1, this;\n        var r = dt(Object.create(Object.getPrototypeOf(this), {\n          $$: {\n            value: Pr(this.$$)\n          }\n        }));\n        return r.$$.count.value += 1, r.$$.deleteScheduled = !1, r;\n      },\n      delete() {\n        this.$$.ptr || Bt(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && C(\"Object already scheduled for deletion\"), ie(this), se(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0);\n      },\n      isDeleted() {\n        return !this.$$.ptr;\n      },\n      deleteLater() {\n        return this.$$.ptr || Bt(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && C(\"Object already scheduled for deletion\"), this.$$.deleteScheduled = !0, this;\n      }\n    });\n    const t = Symbol.dispose;\n    t && (e[t] = e.delete);\n  };\n  function Tt() {\n  }\n  var Ut = (e, t) => Object.defineProperty(t, \"name\", {\n    value: e\n  }), ue = {}, ce = (e, t, r) => {\n    if (e[t].overloadTable === void 0) {\n      var n = e[t];\n      e[t] = function() {\n        for (var a = arguments.length, i = new Array(a), u = 0; u < a; u++)\n          i[u] = arguments[u];\n        return e[t].overloadTable.hasOwnProperty(i.length) || C(`Function '${r}' called with an invalid number of arguments (${i.length}) - expects one of (${e[t].overloadTable})!`), e[t].overloadTable[i.length].apply(this, i);\n      }, e[t].overloadTable = [], e[t].overloadTable[n.argCount] = n;\n    }\n  }, le = (e, t, r) => {\n    c.hasOwnProperty(e) ? ((r === void 0 || c[e].overloadTable !== void 0 && c[e].overloadTable[r] !== void 0) && C(`Cannot register public name '${e}' twice`), ce(c, e, e), c[e].overloadTable.hasOwnProperty(r) && C(`Cannot register multiple overloads of a function with the same number of arguments (${r})!`), c[e].overloadTable[r] = t) : (c[e] = t, c[e].argCount = r);\n  }, Or = 48, xr = 57, Ar = (e) => {\n    e = e.replace(/[^a-zA-Z0-9_]/g, \"$\");\n    var t = e.charCodeAt(0);\n    return t >= Or && t <= xr ? `_${e}` : e;\n  };\n  function Sr(e, t, r, n, a, i, u, s) {\n    this.name = e, this.constructor = t, this.instancePrototype = r, this.rawDestructor = n, this.baseClass = a, this.getActualType = i, this.upcast = u, this.downcast = s, this.pureVirtualFunctions = [];\n  }\n  var Vt = (e, t, r) => {\n    for (; t !== r; )\n      t.upcast || C(`Expected null or instance of ${r.name}, got an instance of ${t.name}`), e = t.upcast(e), t = t.baseClass;\n    return e;\n  };\n  function Ir(e, t) {\n    if (t === null)\n      return this.isReference && C(`null is not a valid ${this.name}`), 0;\n    t.$$ || C(`Cannot pass \"${embindRepr(t)}\" as a ${this.name}`), t.$$.ptr || C(`Cannot pass deleted object as a pointer of type ${this.name}`);\n    var r = t.$$.ptrType.registeredClass, n = Vt(t.$$.ptr, r, this.registeredClass);\n    return n;\n  }\n  function Dr(e, t) {\n    var r;\n    if (t === null)\n      return this.isReference && C(`null is not a valid ${this.name}`), this.isSmartPointer ? (r = this.rawConstructor(), e !== null && e.push(this.rawDestructor, r), r) : 0;\n    (!t || !t.$$) && C(`Cannot pass \"${embindRepr(t)}\" as a ${this.name}`), t.$$.ptr || C(`Cannot pass deleted object as a pointer of type ${this.name}`), !this.isConst && t.$$.ptrType.isConst && C(`Cannot convert argument of type ${t.$$.smartPtrType ? t.$$.smartPtrType.name : t.$$.ptrType.name} to parameter type ${this.name}`);\n    var n = t.$$.ptrType.registeredClass;\n    if (r = Vt(t.$$.ptr, n, this.registeredClass), this.isSmartPointer)\n      switch (t.$$.smartPtr === void 0 && C(\"Passing raw pointer to smart pointer is illegal\"), this.sharingPolicy) {\n        case 0:\n          t.$$.smartPtrType === this ? r = t.$$.smartPtr : C(`Cannot convert argument of type ${t.$$.smartPtrType ? t.$$.smartPtrType.name : t.$$.ptrType.name} to parameter type ${this.name}`);\n          break;\n        case 1:\n          r = t.$$.smartPtr;\n          break;\n        case 2:\n          if (t.$$.smartPtrType === this)\n            r = t.$$.smartPtr;\n          else {\n            var a = t.clone();\n            r = this.rawShare(r, G.toHandle(() => a.delete())), e !== null && e.push(this.rawDestructor, r);\n          }\n          break;\n        default:\n          C(\"Unsupporting sharing policy\");\n      }\n    return r;\n  }\n  function Mr(e, t) {\n    if (t === null)\n      return this.isReference && C(`null is not a valid ${this.name}`), 0;\n    t.$$ || C(`Cannot pass \"${embindRepr(t)}\" as a ${this.name}`), t.$$.ptr || C(`Cannot pass deleted object as a pointer of type ${this.name}`), t.$$.ptrType.isConst && C(`Cannot convert argument of type ${t.$$.ptrType.name} to parameter type ${this.name}`);\n    var r = t.$$.ptrType.registeredClass, n = Vt(t.$$.ptr, r, this.registeredClass);\n    return n;\n  }\n  var fe = (e, t, r) => {\n    if (t === r)\n      return e;\n    if (r.baseClass === void 0)\n      return null;\n    var n = fe(e, t, r.baseClass);\n    return n === null ? null : r.downcast(n);\n  }, Fr = {}, jr = (e, t) => {\n    for (t === void 0 && C(\"ptr should not be undefined\"); e.baseClass; )\n      t = e.upcast(t), e = e.baseClass;\n    return t;\n  }, Rr = (e, t) => (t = jr(e, t), Fr[t]), Pt = (e, t) => {\n    (!t.ptrType || !t.ptr) && Ct(\"makeClassHandle requires ptr and ptrType\");\n    var r = !!t.smartPtrType, n = !!t.smartPtr;\n    return r !== n && Ct(\"Both smartPtrType and smartPtr must be specified\"), t.count = {\n      value: 1\n    }, dt(Object.create(e, {\n      $$: {\n        value: t,\n        writable: !0\n      }\n    }));\n  };\n  function Lr(e) {\n    var t = this.getPointee(e);\n    if (!t)\n      return this.destructor(e), null;\n    var r = Rr(this.registeredClass, t);\n    if (r !== void 0) {\n      if (r.$$.count.value === 0)\n        return r.$$.ptr = t, r.$$.smartPtr = e, r.clone();\n      var n = r.clone();\n      return this.destructor(e), n;\n    }\n    function a() {\n      return this.isSmartPointer ? Pt(this.registeredClass.instancePrototype, {\n        ptrType: this.pointeeType,\n        ptr: t,\n        smartPtrType: this,\n        smartPtr: e\n      }) : Pt(this.registeredClass.instancePrototype, {\n        ptrType: this,\n        ptr: e\n      });\n    }\n    var i = this.registeredClass.getActualType(t), u = ue[i];\n    if (!u)\n      return a.call(this);\n    var s;\n    this.isConst ? s = u.constPointerType : s = u.pointerType;\n    var l = fe(t, this.registeredClass, s.registeredClass);\n    return l === null ? a.call(this) : this.isSmartPointer ? Pt(s.registeredClass.instancePrototype, {\n      ptrType: s,\n      ptr: l,\n      smartPtrType: this,\n      smartPtr: e\n    }) : Pt(s.registeredClass.instancePrototype, {\n      ptrType: s,\n      ptr: l\n    });\n  }\n  var Br = () => {\n    Object.assign(Et.prototype, {\n      getPointee(e) {\n        return this.rawGetPointee && (e = this.rawGetPointee(e)), e;\n      },\n      destructor(e) {\n        var t;\n        (t = this.rawDestructor) === null || t === void 0 || t.call(this, e);\n      },\n      argPackAdvance: N,\n      readValueFromPointer: lt,\n      fromWireType: Lr\n    });\n  };\n  function Et(e, t, r, n, a, i, u, s, l, d, h) {\n    this.name = e, this.registeredClass = t, this.isReference = r, this.isConst = n, this.isSmartPointer = a, this.pointeeType = i, this.sharingPolicy = u, this.rawGetPointee = s, this.rawConstructor = l, this.rawShare = d, this.rawDestructor = h, !a && t.baseClass === void 0 ? n ? (this.toWireType = Ir, this.destructorFunction = null) : (this.toWireType = Mr, this.destructorFunction = null) : this.toWireType = Dr;\n  }\n  var de = (e, t, r) => {\n    c.hasOwnProperty(e) || Ct(\"Replacing nonexistent public symbol\"), c[e].overloadTable !== void 0 && r !== void 0 ? c[e].overloadTable[r] = t : (c[e] = t, c[e].argCount = r);\n  }, he = [], pe, g = (e) => {\n    var t = he[e];\n    return t || (he[e] = t = pe.get(e)), t;\n  }, Wr = function(e, t) {\n    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n    if (e.includes(\"j\"))\n      return dynCallLegacy(e, t, r);\n    var n = g(t), a = n(...r);\n    return a;\n  }, Ur = function(e, t) {\n    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n    return function() {\n      for (var n = arguments.length, a = new Array(n), i = 0; i < n; i++)\n        a[i] = arguments[i];\n      return Wr(e, t, a, r);\n    };\n  }, U = function(e, t) {\n    e = j(e);\n    function r() {\n      if (e.includes(\"j\"))\n        return Ur(e, t);\n      var a = g(t);\n      return a;\n    }\n    var n = r();\n    return typeof n != \"function\" && C(`unknown function pointer with signature ${e}: ${t}`), n;\n  };\n  class Vr extends Error {\n  }\n  var ve = (e) => {\n    var t = Nn(e), r = j(t);\n    return et(t), r;\n  }, _t = (e, t) => {\n    var r = [], n = {};\n    function a(i) {\n      if (!n[i] && !K[i]) {\n        if (bt[i]) {\n          bt[i].forEach(a);\n          return;\n        }\n        r.push(i), n[i] = !0;\n      }\n    }\n    throw t.forEach(a), new Vr(`${e}: ` + r.map(ve).join([\", \"]));\n  }, kr = (e, t, r, n, a, i, u, s, l, d, h, p, w) => {\n    h = j(h), i = U(a, i), s && (s = U(u, s)), d && (d = U(l, d)), w = U(p, w);\n    var b = Ar(h);\n    le(b, function() {\n      _t(`Cannot construct ${h} due to unbound types`, [n]);\n    }), tt([e, t, r], n ? [n] : [], (_) => {\n      _ = _[0];\n      var S, A;\n      n ? (S = _.registeredClass, A = S.instancePrototype) : A = Tt.prototype;\n      var I = Ut(h, function() {\n        if (Object.getPrototypeOf(this) !== X)\n          throw new ft(`Use 'new' to construct ${h}`);\n        if (L.constructor_body === void 0)\n          throw new ft(`${h} has no accessible constructor`);\n        for (var Oe = arguments.length, xt = new Array(Oe), At = 0; At < Oe; At++)\n          xt[At] = arguments[At];\n        var xe = L.constructor_body[xt.length];\n        if (xe === void 0)\n          throw new ft(`Tried to invoke ctor of ${h} with invalid number of parameters (${xt.length}) - expected (${Object.keys(L.constructor_body).toString()}) parameters instead!`);\n        return xe.apply(this, xt);\n      }), X = Object.create(A, {\n        constructor: {\n          value: I\n        }\n      });\n      I.prototype = X;\n      var L = new Sr(h, I, X, w, S, i, s, d);\n      if (L.baseClass) {\n        var W, Ot;\n        (Ot = (W = L.baseClass).__derivedClasses) !== null && Ot !== void 0 || (W.__derivedClasses = []), L.baseClass.__derivedClasses.push(L);\n      }\n      var Ra = new Et(h, L, !0, !1, !1), Ee = new Et(h + \"*\", L, !1, !1, !1), _e = new Et(h + \" const*\", L, !1, !0, !1);\n      return ue[e] = {\n        pointerType: Ee,\n        constPointerType: _e\n      }, de(b, I), [Ra, Ee, _e];\n    });\n  }, kt = (e, t) => {\n    for (var r = [], n = 0; n < e; n++)\n      r.push(P[t + n * 4 >> 2]);\n    return r;\n  };\n  function Hr(e) {\n    for (var t = 1; t < e.length; ++t)\n      if (e[t] !== null && e[t].destructorFunction === void 0)\n        return !0;\n    return !1;\n  }\n  function Ht(e, t, r, n, a, i) {\n    var u = t.length;\n    u < 2 && C(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n    var s = t[1] !== null && r !== null, l = Hr(t), d = t[0].name !== \"void\", h = u - 2, p = new Array(h), w = [], b = [], _ = function() {\n      b.length = 0;\n      var S;\n      w.length = s ? 2 : 1, w[0] = a, s && (S = t[1].toWireType(b, this), w[1] = S);\n      for (var A = 0; A < h; ++A)\n        p[A] = t[A + 2].toWireType(b, A < 0 || arguments.length <= A ? void 0 : arguments[A]), w.push(p[A]);\n      var I = n(...w);\n      function X(L) {\n        if (l)\n          Lt(b);\n        else\n          for (var W = s ? 1 : 2; W < t.length; W++) {\n            var Ot = W === 1 ? S : p[W - 2];\n            t[W].destructorFunction !== null && t[W].destructorFunction(Ot);\n          }\n        if (d)\n          return t[0].fromWireType(L);\n      }\n      return X(I);\n    };\n    return Ut(e, _);\n  }\n  var Nr = (e, t, r, n, a, i) => {\n    var u = kt(t, r);\n    a = U(n, a), tt([], [e], (s) => {\n      s = s[0];\n      var l = `constructor ${s.name}`;\n      if (s.registeredClass.constructor_body === void 0 && (s.registeredClass.constructor_body = []), s.registeredClass.constructor_body[t - 1] !== void 0)\n        throw new ft(`Cannot register multiple constructors with identical number of parameters (${t - 1}) for class '${s.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);\n      return s.registeredClass.constructor_body[t - 1] = () => {\n        _t(`Cannot construct ${s.name} due to unbound types`, u);\n      }, tt([], u, (d) => (d.splice(1, 0, null), s.registeredClass.constructor_body[t - 1] = Ht(l, d, null, a, i), [])), [];\n    });\n  }, ye = (e) => {\n    e = e.trim();\n    const t = e.indexOf(\"(\");\n    return t === -1 ? e : e.slice(0, t);\n  }, zr = (e, t, r, n, a, i, u, s, l, d) => {\n    var h = kt(r, n);\n    t = j(t), t = ye(t), i = U(a, i), tt([], [e], (p) => {\n      p = p[0];\n      var w = `${p.name}.${t}`;\n      t.startsWith(\"@@\") && (t = Symbol[t.substring(2)]), s && p.registeredClass.pureVirtualFunctions.push(t);\n      function b() {\n        _t(`Cannot call ${w} due to unbound types`, h);\n      }\n      var _ = p.registeredClass.instancePrototype, S = _[t];\n      return S === void 0 || S.overloadTable === void 0 && S.className !== p.name && S.argCount === r - 2 ? (b.argCount = r - 2, b.className = p.name, _[t] = b) : (ce(_, t, w), _[t].overloadTable[r - 2] = b), tt([], h, (A) => {\n        var I = Ht(w, A, p, i, u);\n        return _[t].overloadTable === void 0 ? (I.argCount = r - 2, _[t] = I) : _[t].overloadTable[r - 2] = I, [];\n      }), [];\n    });\n  }, Nt = [], z = [], zt = (e) => {\n    e > 9 && --z[e + 1] === 0 && (z[e] = void 0, Nt.push(e));\n  }, Gr = () => z.length / 2 - 5 - Nt.length, Xr = () => {\n    z.push(0, 1, void 0, 1, null, 1, !0, 1, !1, 1), c.count_emval_handles = Gr;\n  }, G = {\n    toValue: (e) => (e || C(`Cannot use deleted val. handle = ${e}`), z[e]),\n    toHandle: (e) => {\n      switch (e) {\n        case void 0:\n          return 2;\n        case null:\n          return 4;\n        case !0:\n          return 6;\n        case !1:\n          return 8;\n        default: {\n          const t = Nt.pop() || z.length;\n          return z[t] = e, z[t + 1] = 1, t;\n        }\n      }\n    }\n  }, me = {\n    name: \"emscripten::val\",\n    fromWireType: (e) => {\n      var t = G.toValue(e);\n      return zt(e), t;\n    },\n    toWireType: (e, t) => G.toHandle(t),\n    argPackAdvance: N,\n    readValueFromPointer: lt,\n    destructorFunction: null\n  }, qr = (e) => V(e, me), Yr = (e, t) => {\n    switch (t) {\n      case 4:\n        return function(r) {\n          return this.fromWireType(Kt[r >> 2]);\n        };\n      case 8:\n        return function(r) {\n          return this.fromWireType(te[r >> 3]);\n        };\n      default:\n        throw new TypeError(`invalid float width (${t}): ${e}`);\n    }\n  }, Zr = (e, t, r) => {\n    t = j(t), V(e, {\n      name: t,\n      fromWireType: (n) => n,\n      toWireType: (n, a) => a,\n      argPackAdvance: N,\n      readValueFromPointer: Yr(t, r),\n      destructorFunction: null\n    });\n  }, Qr = (e, t, r, n, a, i, u, s) => {\n    var l = kt(t, r);\n    e = j(e), e = ye(e), a = U(n, a), le(e, function() {\n      _t(`Cannot call ${e} due to unbound types`, l);\n    }, t - 1), tt([], l, (d) => {\n      var h = [d[0], null].concat(d.slice(1));\n      return de(e, Ht(e, h, null, a, i), t - 1), [];\n    });\n  }, Jr = (e, t, r) => {\n    switch (t) {\n      case 1:\n        return r ? (n) => Q[n] : (n) => B[n];\n      case 2:\n        return r ? (n) => ut[n >> 1] : (n) => vt[n >> 1];\n      case 4:\n        return r ? (n) => at[n >> 2] : (n) => P[n >> 2];\n      default:\n        throw new TypeError(`invalid integer width (${t}): ${e}`);\n    }\n  }, Kr = (e, t, r, n, a) => {\n    t = j(t);\n    var i = (h) => h;\n    if (n === 0) {\n      var u = 32 - 8 * r;\n      i = (h) => h << u >>> u;\n    }\n    var s = t.includes(\"unsigned\"), l = (h, p) => {\n    }, d;\n    s ? d = function(h, p) {\n      return l(p, this.name), p >>> 0;\n    } : d = function(h, p) {\n      return l(p, this.name), p;\n    }, V(e, {\n      name: t,\n      fromWireType: i,\n      toWireType: d,\n      argPackAdvance: N,\n      readValueFromPointer: Jr(t, r, n !== 0),\n      destructorFunction: null\n    });\n  }, tn = (e, t, r) => {\n    var n = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], a = n[t];\n    function i(u) {\n      var s = P[u >> 2], l = P[u + 4 >> 2];\n      return new a(Q.buffer, l, s);\n    }\n    r = j(r), V(e, {\n      name: r,\n      fromWireType: i,\n      argPackAdvance: N,\n      readValueFromPointer: i\n    }, {\n      ignoreDuplicateRegistrations: !0\n    });\n  }, en = Object.assign({\n    optional: !0\n  }, me), rn = (e, t) => {\n    V(e, en);\n  }, nn = (e, t, r, n) => {\n    if (!(n > 0)) return 0;\n    for (var a = r, i = r + n - 1, u = 0; u < e.length; ++u) {\n      var s = e.charCodeAt(u);\n      if (s >= 55296 && s <= 57343) {\n        var l = e.charCodeAt(++u);\n        s = 65536 + ((s & 1023) << 10) | l & 1023;\n      }\n      if (s <= 127) {\n        if (r >= i) break;\n        t[r++] = s;\n      } else if (s <= 2047) {\n        if (r + 1 >= i) break;\n        t[r++] = 192 | s >> 6, t[r++] = 128 | s & 63;\n      } else if (s <= 65535) {\n        if (r + 2 >= i) break;\n        t[r++] = 224 | s >> 12, t[r++] = 128 | s >> 6 & 63, t[r++] = 128 | s & 63;\n      } else {\n        if (r + 3 >= i) break;\n        t[r++] = 240 | s >> 18, t[r++] = 128 | s >> 12 & 63, t[r++] = 128 | s >> 6 & 63, t[r++] = 128 | s & 63;\n      }\n    }\n    return t[r] = 0, r - a;\n  }, it = (e, t, r) => nn(e, B, t, r), ge = (e) => {\n    for (var t = 0, r = 0; r < e.length; ++r) {\n      var n = e.charCodeAt(r);\n      n <= 127 ? t++ : n <= 2047 ? t += 2 : n >= 55296 && n <= 57343 ? (t += 4, ++r) : t += 3;\n    }\n    return t;\n  }, we = typeof TextDecoder < \"u\" ? new TextDecoder() : void 0, $e = function(e) {\n    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;\n    for (var n = t + r, a = t; e[a] && !(a >= n); ) ++a;\n    if (a - t > 16 && e.buffer && we)\n      return we.decode(e.subarray(t, a));\n    for (var i = \"\"; t < a; ) {\n      var u = e[t++];\n      if (!(u & 128)) {\n        i += String.fromCharCode(u);\n        continue;\n      }\n      var s = e[t++] & 63;\n      if ((u & 224) == 192) {\n        i += String.fromCharCode((u & 31) << 6 | s);\n        continue;\n      }\n      var l = e[t++] & 63;\n      if ((u & 240) == 224 ? u = (u & 15) << 12 | s << 6 | l : u = (u & 7) << 18 | s << 12 | l << 6 | e[t++] & 63, u < 65536)\n        i += String.fromCharCode(u);\n      else {\n        var d = u - 65536;\n        i += String.fromCharCode(55296 | d >> 10, 56320 | d & 1023);\n      }\n    }\n    return i;\n  }, an = (e, t) => e ? $e(B, e, t) : \"\", on = (e, t) => {\n    t = j(t), V(e, {\n      name: t,\n      fromWireType(r) {\n        for (var n = P[r >> 2], a = r + 4, i, s, u = a, s = 0; s <= n; ++s) {\n          var l = a + s;\n          if (s == n || B[l] == 0) {\n            var d = l - u, h = an(u, d);\n            i === void 0 ? i = h : (i += \"\\0\", i += h), u = l + 1;\n          }\n        }\n        return et(r), i;\n      },\n      toWireType(r, n) {\n        n instanceof ArrayBuffer && (n = new Uint8Array(n));\n        var a, i = typeof n == \"string\";\n        i || ArrayBuffer.isView(n) && n.BYTES_PER_ELEMENT == 1 || C(\"Cannot pass non-string to std::string\"), i ? a = ge(n) : a = n.length;\n        var u = Pe(4 + a + 1), s = u + 4;\n        return P[u >> 2] = a, i ? it(n, s, a + 1) : B.set(n, s), r !== null && r.push(et, u), u;\n      },\n      argPackAdvance: N,\n      readValueFromPointer: lt,\n      destructorFunction(r) {\n        et(r);\n      }\n    });\n  }, be = typeof TextDecoder < \"u\" ? new TextDecoder(\"utf-16le\") : void 0, sn = (e, t) => {\n    for (var r = e, n = r >> 1, a = n + t / 2; !(n >= a) && vt[n]; ) ++n;\n    if (r = n << 1, r - e > 32 && be) return be.decode(B.subarray(e, r));\n    for (var i = \"\", u = 0; !(u >= t / 2); ++u) {\n      var s = ut[e + u * 2 >> 1];\n      if (s == 0) break;\n      i += String.fromCharCode(s);\n    }\n    return i;\n  }, un = (e, t, r) => {\n    if (r != null || (r = 2147483647), r < 2) return 0;\n    r -= 2;\n    for (var n = t, a = r < e.length * 2 ? r / 2 : e.length, i = 0; i < a; ++i) {\n      var u = e.charCodeAt(i);\n      ut[t >> 1] = u, t += 2;\n    }\n    return ut[t >> 1] = 0, t - n;\n  }, cn = (e) => e.length * 2, ln = (e, t) => {\n    for (var r = 0, n = \"\"; !(r >= t / 4); ) {\n      var a = at[e + r * 4 >> 2];\n      if (a == 0) break;\n      if (++r, a >= 65536) {\n        var i = a - 65536;\n        n += String.fromCharCode(55296 | i >> 10, 56320 | i & 1023);\n      } else\n        n += String.fromCharCode(a);\n    }\n    return n;\n  }, fn = (e, t, r) => {\n    if (r != null || (r = 2147483647), r < 4) return 0;\n    for (var n = t, a = n + r - 4, i = 0; i < e.length; ++i) {\n      var u = e.charCodeAt(i);\n      if (u >= 55296 && u <= 57343) {\n        var s = e.charCodeAt(++i);\n        u = 65536 + ((u & 1023) << 10) | s & 1023;\n      }\n      if (at[t >> 2] = u, t += 4, t + 4 > a) break;\n    }\n    return at[t >> 2] = 0, t - n;\n  }, dn = (e) => {\n    for (var t = 0, r = 0; r < e.length; ++r) {\n      var n = e.charCodeAt(r);\n      n >= 55296 && n <= 57343 && ++r, t += 4;\n    }\n    return t;\n  }, hn = (e, t, r) => {\n    r = j(r);\n    var n, a, i, u;\n    t === 2 ? (n = sn, a = un, u = cn, i = (s) => vt[s >> 1]) : t === 4 && (n = ln, a = fn, u = dn, i = (s) => P[s >> 2]), V(e, {\n      name: r,\n      fromWireType: (s) => {\n        for (var l = P[s >> 2], d, h = s + 4, p = 0; p <= l; ++p) {\n          var w = s + 4 + p * t;\n          if (p == l || i(w) == 0) {\n            var b = w - h, _ = n(h, b);\n            d === void 0 ? d = _ : (d += \"\\0\", d += _), h = w + t;\n          }\n        }\n        return et(s), d;\n      },\n      toWireType: (s, l) => {\n        typeof l != \"string\" && C(`Cannot pass non-string to C++ string type ${r}`);\n        var d = u(l), h = Pe(4 + d + t);\n        return P[h >> 2] = d / t, a(l, h + 4, d + t), s !== null && s.push(et, h), h;\n      },\n      argPackAdvance: N,\n      readValueFromPointer: lt,\n      destructorFunction(s) {\n        et(s);\n      }\n    });\n  }, pn = (e, t, r, n, a, i) => {\n    $t[e] = {\n      name: j(t),\n      rawConstructor: U(r, n),\n      rawDestructor: U(a, i),\n      fields: []\n    };\n  }, vn = (e, t, r, n, a, i, u, s, l, d) => {\n    $t[e].fields.push({\n      fieldName: j(t),\n      getterReturnType: r,\n      getter: U(n, a),\n      getterContext: i,\n      setterArgumentType: u,\n      setter: U(s, l),\n      setterContext: d\n    });\n  }, yn = (e, t) => {\n    t = j(t), V(e, {\n      isVoid: !0,\n      name: t,\n      argPackAdvance: 0,\n      fromWireType: () => {\n      },\n      toWireType: (r, n) => {\n      }\n    });\n  }, Gt = [], mn = (e, t, r, n) => (e = Gt[e], t = G.toValue(t), e(null, t, r, n)), gn = {}, wn = (e) => {\n    var t = gn[e];\n    return t === void 0 ? j(e) : t;\n  }, Ce = () => {\n    if (typeof globalThis == \"object\")\n      return globalThis;\n    function e(t) {\n      t.$$$embind_global$$$ = t;\n      var r = typeof $$$embind_global$$$ == \"object\" && t.$$$embind_global$$$ == t;\n      return r || delete t.$$$embind_global$$$, r;\n    }\n    if (typeof $$$embind_global$$$ == \"object\" || (typeof global == \"object\" && e(global) ? $$$embind_global$$$ = global : typeof self == \"object\" && e(self) && ($$$embind_global$$$ = self), typeof $$$embind_global$$$ == \"object\"))\n      return $$$embind_global$$$;\n    throw Error(\"unable to get global object.\");\n  }, $n = (e) => e === 0 ? G.toHandle(Ce()) : (e = wn(e), G.toHandle(Ce()[e])), bn = (e) => {\n    var t = Gt.length;\n    return Gt.push(e), t;\n  }, Te = (e, t) => {\n    var r = K[e];\n    return r === void 0 && C(`${t} has unknown type ${ve(e)}`), r;\n  }, Cn = (e, t) => {\n    for (var r = new Array(e), n = 0; n < e; ++n)\n      r[n] = Te(P[t + n * 4 >> 2], `parameter ${n}`);\n    return r;\n  }, Tn = (e, t, r) => {\n    var n = [], a = e.toWireType(n, r);\n    return n.length && (P[t >> 2] = G.toHandle(n)), a;\n  }, Pn = Reflect.construct, En = (e, t, r) => {\n    var n = Cn(e, t), a = n.shift();\n    e--;\n    var i = new Array(e), u = (l, d, h, p) => {\n      for (var w = 0, b = 0; b < e; ++b)\n        i[b] = n[b].readValueFromPointer(p + w), w += n[b].argPackAdvance;\n      var _ = r === 1 ? Pn(d, i) : d.apply(l, i);\n      return Tn(a, h, _);\n    }, s = `methodCaller<(${n.map((l) => l.name).join(\", \")}) => ${a.name}>`;\n    return bn(Ut(s, u));\n  }, _n = (e) => {\n    e > 9 && (z[e + 1] += 1);\n  }, On = (e) => {\n    var t = G.toValue(e);\n    Lt(t), zt(e);\n  }, xn = (e, t) => {\n    e = Te(e, \"_emval_take_value\");\n    var r = e.readValueFromPointer(t);\n    return G.toHandle(r);\n  }, An = (e, t, r, n) => {\n    var a = (/* @__PURE__ */ new Date()).getFullYear(), i = new Date(a, 0, 1), u = new Date(a, 6, 1), s = i.getTimezoneOffset(), l = u.getTimezoneOffset(), d = Math.max(s, l);\n    P[e >> 2] = d * 60, at[t >> 2] = +(s != l);\n    var h = (b) => {\n      var _ = b >= 0 ? \"-\" : \"+\", S = Math.abs(b), A = String(Math.floor(S / 60)).padStart(2, \"0\"), I = String(S % 60).padStart(2, \"0\");\n      return `UTC${_}${A}${I}`;\n    }, p = h(s), w = h(l);\n    l < s ? (it(p, r, 17), it(w, n, 17)) : (it(p, n, 17), it(w, r, 17));\n  }, Sn = () => 2147483648, In = (e, t) => Math.ceil(e / t) * t, Dn = (e) => {\n    var t = nt.buffer, r = (e - t.byteLength + 65535) / 65536 | 0;\n    try {\n      return nt.grow(r), ee(), 1;\n    } catch {\n    }\n  }, Mn = (e) => {\n    var t = B.length;\n    e >>>= 0;\n    var r = Sn();\n    if (e > r)\n      return !1;\n    for (var n = 1; n <= 4; n *= 2) {\n      var a = t * (1 + 0.2 / n);\n      a = Math.min(a, e + 100663296);\n      var i = Math.min(r, In(Math.max(e, a), 65536)), u = Dn(i);\n      if (u)\n        return !0;\n    }\n    return !1;\n  }, Xt = {}, Fn = () => M || \"./this.program\", ht = () => {\n    if (!ht.strings) {\n      var e = (typeof navigator == \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\", t = {\n        USER: \"web_user\",\n        LOGNAME: \"web_user\",\n        PATH: \"/\",\n        PWD: \"/\",\n        HOME: \"/home/web_user\",\n        LANG: e,\n        _: Fn()\n      };\n      for (var r in Xt)\n        Xt[r] === void 0 ? delete t[r] : t[r] = Xt[r];\n      var n = [];\n      for (var r in t)\n        n.push(`${r}=${t[r]}`);\n      ht.strings = n;\n    }\n    return ht.strings;\n  }, jn = (e, t) => {\n    var r = 0, n = 0;\n    for (var a of ht()) {\n      var i = t + r;\n      P[e + n >> 2] = i, r += it(a, i, 1 / 0) + 1, n += 4;\n    }\n    return 0;\n  }, Rn = (e, t) => {\n    var r = ht();\n    P[e >> 2] = r.length;\n    var n = 0;\n    for (var a of r)\n      n += ge(a) + 1;\n    return P[t >> 2] = n, 0;\n  }, Ln = (e) => 52;\n  function Bn(e, t, r, n, a) {\n    return 70;\n  }\n  var Wn = [null, [], []], Un = (e, t) => {\n    var r = Wn[e];\n    t === 0 || t === 10 ? ((e === 1 ? st : k)($e(r)), r.length = 0) : r.push(t);\n  }, Vn = (e, t, r, n) => {\n    for (var a = 0, i = 0; i < r; i++) {\n      var u = P[t >> 2], s = P[t + 4 >> 2];\n      t += 8;\n      for (var l = 0; l < s; l++)\n        Un(e, B[u + l]);\n      a += s;\n    }\n    return P[n >> 2] = a, 0;\n  }, kn = (e) => e;\n  br(), _r(), Br(), Xr(), c.noExitRuntime && c.noExitRuntime, c.print && (st = c.print), c.printErr && (k = c.printErr), c.wasmBinary && (Z = c.wasmBinary), c.arguments && c.arguments, c.thisProgram && (M = c.thisProgram);\n  var Hn = {\n    s: ur,\n    w: cr,\n    a: lr,\n    j: fr,\n    m: dr,\n    N: hr,\n    p: pr,\n    da: vr,\n    d: yr,\n    _: mr,\n    sa: wr,\n    Z: $r,\n    na: Tr,\n    qa: kr,\n    pa: Nr,\n    F: zr,\n    la: qr,\n    R: Zr,\n    S: Qr,\n    y: Kr,\n    t: tn,\n    ra: rn,\n    ma: on,\n    O: hn,\n    K: pn,\n    ta: vn,\n    oa: yn,\n    V: mn,\n    ua: zt,\n    wa: $n,\n    $: En,\n    T: _n,\n    va: On,\n    ka: xn,\n    aa: An,\n    ea: Mn,\n    ba: jn,\n    ca: Rn,\n    fa: Ln,\n    X: Bn,\n    Q: Vn,\n    I: ba,\n    C: Ta,\n    U: oa,\n    P: Sa,\n    q: ma,\n    b: ea,\n    D: $a,\n    ia: Ea,\n    c: na,\n    ha: _a,\n    h: aa,\n    i: la,\n    r: da,\n    M: wa,\n    v: pa,\n    E: ya,\n    J: ga,\n    A: Pa,\n    H: Ia,\n    W: Fa,\n    k: sa,\n    f: ia,\n    e: ra,\n    g: ta,\n    L: Aa,\n    l: ca,\n    ja: Ca,\n    o: ha,\n    x: fa,\n    u: va,\n    ga: xa,\n    B: Oa,\n    n: ua,\n    G: Da,\n    Y: Ma,\n    z: kn\n  }, E = await or();\n  E.ya;\n  var Nn = E.za, et = c._free = E.Aa, Pe = c._malloc = E.Ca, zn = E.Da, v = E.Ea, Gn = E.Fa, Xn = E.Ga, qn = E.Ha, Yn = E.Ia, Zn = E.Ja, Qn = E.Ka;\n  c.dynCall_viijii = E.La;\n  var Jn = c.dynCall_vij = E.Ma;\n  c.dynCall_jiji = E.Na;\n  var Kn = c.dynCall_jiiii = E.Oa;\n  c.dynCall_iiiiij = E.Pa, c.dynCall_iiiiijj = E.Qa, c.dynCall_iiiiiijj = E.Ra;\n  function ta(e, t, r, n) {\n    var a = m();\n    try {\n      g(e)(t, r, n);\n    } catch (i) {\n      if (y(a), i !== i + 0) throw i;\n      v(1, 0);\n    }\n  }\n  function ea(e, t) {\n    var r = m();\n    try {\n      return g(e)(t);\n    } catch (n) {\n      if (y(r), n !== n + 0) throw n;\n      v(1, 0);\n    }\n  }\n  function ra(e, t, r) {\n    var n = m();\n    try {\n      g(e)(t, r);\n    } catch (a) {\n      if (y(n), a !== a + 0) throw a;\n      v(1, 0);\n    }\n  }\n  function na(e, t, r) {\n    var n = m();\n    try {\n      return g(e)(t, r);\n    } catch (a) {\n      if (y(n), a !== a + 0) throw a;\n      v(1, 0);\n    }\n  }\n  function aa(e, t, r, n) {\n    var a = m();\n    try {\n      return g(e)(t, r, n);\n    } catch (i) {\n      if (y(a), i !== i + 0) throw i;\n      v(1, 0);\n    }\n  }\n  function oa(e, t, r, n, a) {\n    var i = m();\n    try {\n      return g(e)(t, r, n, a);\n    } catch (u) {\n      if (y(i), u !== u + 0) throw u;\n      v(1, 0);\n    }\n  }\n  function ia(e, t) {\n    var r = m();\n    try {\n      g(e)(t);\n    } catch (n) {\n      if (y(r), n !== n + 0) throw n;\n      v(1, 0);\n    }\n  }\n  function sa(e) {\n    var t = m();\n    try {\n      g(e)();\n    } catch (r) {\n      if (y(t), r !== r + 0) throw r;\n      v(1, 0);\n    }\n  }\n  function ua(e, t, r, n, a, i, u, s, l, d, h) {\n    var p = m();\n    try {\n      g(e)(t, r, n, a, i, u, s, l, d, h);\n    } catch (w) {\n      if (y(p), w !== w + 0) throw w;\n      v(1, 0);\n    }\n  }\n  function ca(e, t, r, n, a) {\n    var i = m();\n    try {\n      g(e)(t, r, n, a);\n    } catch (u) {\n      if (y(i), u !== u + 0) throw u;\n      v(1, 0);\n    }\n  }\n  function la(e, t, r, n, a) {\n    var i = m();\n    try {\n      return g(e)(t, r, n, a);\n    } catch (u) {\n      if (y(i), u !== u + 0) throw u;\n      v(1, 0);\n    }\n  }\n  function fa(e, t, r, n, a, i, u) {\n    var s = m();\n    try {\n      g(e)(t, r, n, a, i, u);\n    } catch (l) {\n      if (y(s), l !== l + 0) throw l;\n      v(1, 0);\n    }\n  }\n  function da(e, t, r, n, a, i) {\n    var u = m();\n    try {\n      return g(e)(t, r, n, a, i);\n    } catch (s) {\n      if (y(u), s !== s + 0) throw s;\n      v(1, 0);\n    }\n  }\n  function ha(e, t, r, n, a, i) {\n    var u = m();\n    try {\n      g(e)(t, r, n, a, i);\n    } catch (s) {\n      if (y(u), s !== s + 0) throw s;\n      v(1, 0);\n    }\n  }\n  function pa(e, t, r, n, a, i, u) {\n    var s = m();\n    try {\n      return g(e)(t, r, n, a, i, u);\n    } catch (l) {\n      if (y(s), l !== l + 0) throw l;\n      v(1, 0);\n    }\n  }\n  function va(e, t, r, n, a, i, u, s) {\n    var l = m();\n    try {\n      g(e)(t, r, n, a, i, u, s);\n    } catch (d) {\n      if (y(l), d !== d + 0) throw d;\n      v(1, 0);\n    }\n  }\n  function ya(e, t, r, n, a, i, u, s) {\n    var l = m();\n    try {\n      return g(e)(t, r, n, a, i, u, s);\n    } catch (d) {\n      if (y(l), d !== d + 0) throw d;\n      v(1, 0);\n    }\n  }\n  function ma(e) {\n    var t = m();\n    try {\n      return g(e)();\n    } catch (r) {\n      if (y(t), r !== r + 0) throw r;\n      v(1, 0);\n    }\n  }\n  function ga(e, t, r, n, a, i, u, s, l) {\n    var d = m();\n    try {\n      return g(e)(t, r, n, a, i, u, s, l);\n    } catch (h) {\n      if (y(d), h !== h + 0) throw h;\n      v(1, 0);\n    }\n  }\n  function wa(e, t, r, n, a, i, u) {\n    var s = m();\n    try {\n      return g(e)(t, r, n, a, i, u);\n    } catch (l) {\n      if (y(s), l !== l + 0) throw l;\n      v(1, 0);\n    }\n  }\n  function $a(e, t, r, n) {\n    var a = m();\n    try {\n      return g(e)(t, r, n);\n    } catch (i) {\n      if (y(a), i !== i + 0) throw i;\n      v(1, 0);\n    }\n  }\n  function ba(e, t, r, n) {\n    var a = m();\n    try {\n      return g(e)(t, r, n);\n    } catch (i) {\n      if (y(a), i !== i + 0) throw i;\n      v(1, 0);\n    }\n  }\n  function Ca(e, t, r, n, a, i, u, s) {\n    var l = m();\n    try {\n      g(e)(t, r, n, a, i, u, s);\n    } catch (d) {\n      if (y(l), d !== d + 0) throw d;\n      v(1, 0);\n    }\n  }\n  function Ta(e, t, r, n, a, i) {\n    var u = m();\n    try {\n      return g(e)(t, r, n, a, i);\n    } catch (s) {\n      if (y(u), s !== s + 0) throw s;\n      v(1, 0);\n    }\n  }\n  function Pa(e, t, r, n, a, i, u, s, l, d) {\n    var h = m();\n    try {\n      return g(e)(t, r, n, a, i, u, s, l, d);\n    } catch (p) {\n      if (y(h), p !== p + 0) throw p;\n      v(1, 0);\n    }\n  }\n  function Ea(e, t, r) {\n    var n = m();\n    try {\n      return g(e)(t, r);\n    } catch (a) {\n      if (y(n), a !== a + 0) throw a;\n      v(1, 0);\n    }\n  }\n  function _a(e, t, r, n, a) {\n    var i = m();\n    try {\n      return g(e)(t, r, n, a);\n    } catch (u) {\n      if (y(i), u !== u + 0) throw u;\n      v(1, 0);\n    }\n  }\n  function Oa(e, t, r, n, a, i, u, s, l, d) {\n    var h = m();\n    try {\n      g(e)(t, r, n, a, i, u, s, l, d);\n    } catch (p) {\n      if (y(h), p !== p + 0) throw p;\n      v(1, 0);\n    }\n  }\n  function xa(e, t, r, n, a, i, u, s, l) {\n    var d = m();\n    try {\n      g(e)(t, r, n, a, i, u, s, l);\n    } catch (h) {\n      if (y(d), h !== h + 0) throw h;\n      v(1, 0);\n    }\n  }\n  function Aa(e, t, r, n, a, i, u) {\n    var s = m();\n    try {\n      g(e)(t, r, n, a, i, u);\n    } catch (l) {\n      if (y(s), l !== l + 0) throw l;\n      v(1, 0);\n    }\n  }\n  function Sa(e, t, r, n) {\n    var a = m();\n    try {\n      return g(e)(t, r, n);\n    } catch (i) {\n      if (y(a), i !== i + 0) throw i;\n      v(1, 0);\n    }\n  }\n  function Ia(e, t, r, n, a, i, u, s, l, d, h, p) {\n    var w = m();\n    try {\n      return g(e)(t, r, n, a, i, u, s, l, d, h, p);\n    } catch (b) {\n      if (y(w), b !== b + 0) throw b;\n      v(1, 0);\n    }\n  }\n  function Da(e, t, r, n, a, i, u, s, l, d, h, p, w, b, _, S) {\n    var A = m();\n    try {\n      g(e)(t, r, n, a, i, u, s, l, d, h, p, w, b, _, S);\n    } catch (I) {\n      if (y(A), I !== I + 0) throw I;\n      v(1, 0);\n    }\n  }\n  function Ma(e, t, r, n) {\n    var a = m();\n    try {\n      Jn(e, t, r, n);\n    } catch (i) {\n      if (y(a), i !== i + 0) throw i;\n      v(1, 0);\n    }\n  }\n  function Fa(e, t, r, n, a) {\n    var i = m();\n    try {\n      return Kn(e, t, r, n, a);\n    } catch (u) {\n      if (y(i), u !== u + 0) throw u;\n      v(1, 0);\n    }\n  }\n  function qt() {\n    if (J > 0) {\n      ct = qt;\n      return;\n    }\n    if (qe(), J > 0) {\n      ct = qt;\n      return;\n    }\n    function e() {\n      var t;\n      c.calledRun = !0, !Jt && (Ye(), T(c), (t = c.onRuntimeInitialized) === null || t === void 0 || t.call(c), Ze());\n    }\n    c.setStatus ? (c.setStatus(\"Running...\"), setTimeout(() => {\n      setTimeout(() => c.setStatus(\"\"), 1), e();\n    }, 1)) : e();\n  }\n  function ja() {\n    if (c.preInit)\n      for (typeof c.preInit == \"function\" && (c.preInit = [c.preInit]); c.preInit.length > 0; )\n        c.preInit.shift()();\n  }\n  return ja(), qt(), f = x, f;\n};\nfunction Be(o) {\n  return Le(Qt, o);\n}\nfunction Co() {\n  return Ka(Qt);\n}\nfunction To(o) {\n  Be({\n    overrides: o,\n    equalityFn: Object.is,\n    fireImmediately: !1\n  });\n}\nasync function eo(o, f) {\n  return to(Qt, o, f);\n}\nconst Po = \"3c07027dbfd6da47330ac18e74e6924019d9ac9a4c1e161b800666f9e3c925ca\", We = [\n  [\"aztec\", \"Aztec\"],\n  [\"code_128\", \"Code128\"],\n  [\"code_39\", \"Code39\"],\n  [\"code_93\", \"Code93\"],\n  [\"codabar\", \"Codabar\"],\n  [\"databar\", \"DataBar\"],\n  [\"databar_expanded\", \"DataBarExpanded\"],\n  [\"databar_limited\", \"DataBarLimited\"],\n  [\"data_matrix\", \"DataMatrix\"],\n  [\"dx_film_edge\", \"DXFilmEdge\"],\n  [\"ean_13\", \"EAN-13\"],\n  [\"ean_8\", \"EAN-8\"],\n  [\"itf\", \"ITF\"],\n  [\"maxi_code\", \"MaxiCode\"],\n  [\"micro_qr_code\", \"MicroQRCode\"],\n  [\"pdf417\", \"PDF417\"],\n  [\"qr_code\", \"QRCode\"],\n  [\"rm_qr_code\", \"rMQRCode\"],\n  [\"upc_a\", \"UPC-A\"],\n  [\"upc_e\", \"UPC-E\"],\n  [\"linear_codes\", \"Linear-Codes\"],\n  [\"matrix_codes\", \"Matrix-Codes\"],\n  [\"any\", \"Any\"]\n], ro = [...We, [\"unknown\"]].map((o) => o[0]), Zt = new Map(\n  We\n);\nfunction no(o) {\n  for (const [f, c] of Zt)\n    if (o === c)\n      return f;\n  return \"unknown\";\n}\nfunction ao(o) {\n  if (Ue(o))\n    return {\n      width: o.naturalWidth,\n      height: o.naturalHeight\n    };\n  if (Ve(o))\n    return {\n      width: o.width.baseVal.value,\n      height: o.height.baseVal.value\n    };\n  if (ke(o))\n    return {\n      width: o.videoWidth,\n      height: o.videoHeight\n    };\n  if (Ne(o))\n    return {\n      width: o.width,\n      height: o.height\n    };\n  if (Ge(o))\n    return {\n      width: o.displayWidth,\n      height: o.displayHeight\n    };\n  if (He(o))\n    return {\n      width: o.width,\n      height: o.height\n    };\n  if (ze(o))\n    return {\n      width: o.width,\n      height: o.height\n    };\n  throw new TypeError(\n    \"The provided value is not of type '(Blob or HTMLCanvasElement or HTMLImageElement or HTMLVideoElement or ImageBitmap or ImageData or OffscreenCanvas or SVGImageElement or VideoFrame)'.\"\n  );\n}\nfunction Ue(o) {\n  var f, c;\n  try {\n    return o instanceof ((c = (f = o == null ? void 0 : o.ownerDocument) == null ? void 0 : f.defaultView) == null ? void 0 : c.HTMLImageElement);\n  } catch {\n    return !1;\n  }\n}\nfunction Ve(o) {\n  var f, c;\n  try {\n    return o instanceof ((c = (f = o == null ? void 0 : o.ownerDocument) == null ? void 0 : f.defaultView) == null ? void 0 : c.SVGImageElement);\n  } catch {\n    return !1;\n  }\n}\nfunction ke(o) {\n  var f, c;\n  try {\n    return o instanceof ((c = (f = o == null ? void 0 : o.ownerDocument) == null ? void 0 : f.defaultView) == null ? void 0 : c.HTMLVideoElement);\n  } catch {\n    return !1;\n  }\n}\nfunction He(o) {\n  var f, c;\n  try {\n    return o instanceof ((c = (f = o == null ? void 0 : o.ownerDocument) == null ? void 0 : f.defaultView) == null ? void 0 : c.HTMLCanvasElement);\n  } catch {\n    return !1;\n  }\n}\nfunction Ne(o) {\n  try {\n    return o instanceof ImageBitmap || Object.prototype.toString.call(o) === \"[object ImageBitmap]\";\n  } catch {\n    return !1;\n  }\n}\nfunction ze(o) {\n  try {\n    return o instanceof OffscreenCanvas || Object.prototype.toString.call(o) === \"[object OffscreenCanvas]\";\n  } catch {\n    return !1;\n  }\n}\nfunction Ge(o) {\n  try {\n    return o instanceof VideoFrame || Object.prototype.toString.call(o) === \"[object VideoFrame]\";\n  } catch {\n    return !1;\n  }\n}\nfunction oo(o) {\n  try {\n    return o instanceof Blob || Object.prototype.toString.call(o) === \"[object Blob]\";\n  } catch {\n    return !1;\n  }\n}\nfunction io(o) {\n  try {\n    return o instanceof ImageData || Object.prototype.toString.call(o) === \"[object ImageData]\";\n  } catch {\n    return !1;\n  }\n}\nfunction so(o, f) {\n  try {\n    const c = new OffscreenCanvas(o, f);\n    if (c.getContext(\"2d\") instanceof OffscreenCanvasRenderingContext2D)\n      return c;\n    throw void 0;\n  } catch {\n    const c = document.createElement(\"canvas\");\n    return c.width = o, c.height = f, c;\n  }\n}\nasync function Xe(o) {\n  if (Ue(o) && !await fo(o))\n    throw new DOMException(\n      \"Failed to load or decode HTMLImageElement.\",\n      \"InvalidStateError\"\n    );\n  if (Ve(o) && !await ho(o))\n    throw new DOMException(\n      \"Failed to load or decode SVGImageElement.\",\n      \"InvalidStateError\"\n    );\n  if (Ge(o) && po(o))\n    throw new DOMException(\"VideoFrame is closed.\", \"InvalidStateError\");\n  if (ke(o) && (o.readyState === 0 || o.readyState === 1))\n    throw new DOMException(\"Invalid element or state.\", \"InvalidStateError\");\n  if (Ne(o) && yo(o))\n    throw new DOMException(\n      \"The image source is detached.\",\n      \"InvalidStateError\"\n    );\n  const { width: f, height: c } = ao(o);\n  if (f === 0 || c === 0)\n    return null;\n  const $ = so(f, c).getContext(\"2d\");\n  $.drawImage(o, 0, 0);\n  try {\n    return $.getImageData(0, 0, f, c);\n  } catch {\n    throw new DOMException(\"Source would taint origin.\", \"SecurityError\");\n  }\n}\nasync function uo(o) {\n  let f;\n  try {\n    f = await createImageBitmap(o);\n  } catch {\n    try {\n      if (globalThis.Image) {\n        f = new Image();\n        let $ = \"\";\n        try {\n          $ = URL.createObjectURL(o), f.src = $, await f.decode();\n        } finally {\n          URL.revokeObjectURL($);\n        }\n      } else\n        return o;\n    } catch {\n      throw new DOMException(\n        \"Failed to load or decode Blob.\",\n        \"InvalidStateError\"\n      );\n    }\n  }\n  return await Xe(f);\n}\nfunction co(o) {\n  const { width: f, height: c } = o;\n  if (f === 0 || c === 0)\n    return null;\n  const T = o.getContext(\"2d\");\n  try {\n    return T.getImageData(0, 0, f, c);\n  } catch {\n    throw new DOMException(\"Source would taint origin.\", \"SecurityError\");\n  }\n}\nasync function lo(o) {\n  if (oo(o))\n    return await uo(o);\n  if (io(o)) {\n    if (vo(o))\n      throw new DOMException(\n        \"The image data has been detached.\",\n        \"InvalidStateError\"\n      );\n    return o;\n  }\n  return He(o) || ze(o) ? co(o) : await Xe(o);\n}\nasync function fo(o) {\n  try {\n    return await o.decode(), !0;\n  } catch {\n    return !1;\n  }\n}\nasync function ho(o) {\n  var f;\n  try {\n    return await ((f = o.decode) == null ? void 0 : f.call(o)), !0;\n  } catch {\n    return !1;\n  }\n}\nfunction po(o) {\n  return o.format === null;\n}\nfunction vo(o) {\n  return o.data.buffer.byteLength === 0;\n}\nfunction yo(o) {\n  return o.width === 0 && o.height === 0;\n}\nfunction Re(o, f) {\n  return mo(o) ? new DOMException(`${f}: ${o.message}`, o.name) : go(o) ? new o.constructor(`${f}: ${o.message}`) : new Error(`${f}: ${o}`);\n}\nfunction mo(o) {\n  return o instanceof DOMException || Object.prototype.toString.call(o) === \"[object DOMException]\";\n}\nfunction go(o) {\n  return o instanceof Error || Object.prototype.toString.call(o) === \"[object Error]\";\n}\nvar pt;\nclass Eo {\n  constructor(f = {}) {\n    De(this, pt);\n    var c;\n    try {\n      const T = (c = f == null ? void 0 : f.formats) == null ? void 0 : c.filter(\n        ($) => $ !== \"unknown\"\n      );\n      if ((T == null ? void 0 : T.length) === 0)\n        throw new TypeError(\"Hint option provided, but is empty.\");\n      for (const $ of T != null ? T : [])\n        if (!Zt.has($))\n          throw new TypeError(\n            `Failed to read the 'formats' property from 'BarcodeDetectorOptions': The provided value '${$}' is not a valid enum value of type BarcodeFormat.`\n          );\n      Me(this, pt, T != null ? T : []), Be({ fireImmediately: !0 }).catch(() => {\n      });\n    } catch (T) {\n      throw Re(\n        T,\n        \"Failed to construct 'BarcodeDetector'\"\n      );\n    }\n  }\n  static async getSupportedFormats() {\n    return ro.filter((f) => f !== \"unknown\");\n  }\n  async detect(f) {\n    try {\n      const c = await lo(f);\n      if (c === null)\n        return [];\n      let T;\n      const $ = {\n        tryCode39ExtendedMode: !1,\n        textMode: \"Plain\",\n        formats: Ie(this, pt).map((x) => Zt.get(x))\n      };\n      try {\n        T = await eo(c, $);\n      } catch (x) {\n        throw console.error(x), new DOMException(\n          \"Barcode detection service unavailable.\",\n          \"NotSupportedError\"\n        );\n      }\n      return T.map((x) => {\n        const {\n          topLeft: { x: D, y: R },\n          topRight: { x: O, y: M },\n          bottomLeft: { x: F, y: q },\n          bottomRight: { x: rt, y: Y }\n        } = x.position, st = Math.min(D, O, F, rt), k = Math.min(R, M, q, Y), Z = Math.max(D, O, F, rt), nt = Math.max(R, M, q, Y);\n        return {\n          boundingBox: new DOMRectReadOnly(\n            st,\n            k,\n            Z - st,\n            nt - k\n          ),\n          rawValue: x.text,\n          format: no(x.format),\n          cornerPoints: [\n            {\n              x: D,\n              y: R\n            },\n            {\n              x: O,\n              y: M\n            },\n            {\n              x: rt,\n              y: Y\n            },\n            {\n              x: F,\n              y: q\n            }\n          ]\n        };\n      });\n    } catch (c) {\n      throw Re(\n        c,\n        \"Failed to execute 'detect' on 'BarcodeDetector'\"\n      );\n    }\n  }\n}\npt = new WeakMap();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFyY29kZS1kZXRlY3Rvci9kaXN0L2VzL3BvbnlmaWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsS0FBSyxHQUFHLEVBQUU7QUFDbEY7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxpQkFBaUI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxrQkFBa0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0RBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1IsNENBQTRDLEVBQUU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUcsNEJBQTRCO0FBQy9CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUSxTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxzQkFBc0I7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNCQUFzQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzQkFBc0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxFQUFFLElBQUksVUFBVSwwQ0FBMEMsRUFBRSxJQUFJLFVBQVUsa0JBQWtCLEVBQUUsSUFBSSxFQUFFO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLEVBQUU7QUFDMUc7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQyxzQkFBc0IsWUFBWTtBQUNsQyx3QkFBd0IsWUFBWTtBQUNwQyx5QkFBeUI7QUFDekIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0UiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL2JhcmNvZGUtZGV0ZWN0b3IvZGlzdC9lcy9wb255ZmlsbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQWUgPSAobykgPT4ge1xuICB0aHJvdyBUeXBlRXJyb3Iobyk7XG59O1xudmFyIFNlID0gKG8sIGYsIGMpID0+IGYuaGFzKG8pIHx8IEFlKFwiQ2Fubm90IFwiICsgYyk7XG52YXIgSWUgPSAobywgZiwgYykgPT4gKFNlKG8sIGYsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIiksIGMgPyBjLmNhbGwobykgOiBmLmdldChvKSksIERlID0gKG8sIGYsIGMpID0+IGYuaGFzKG8pID8gQWUoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpIDogZiBpbnN0YW5jZW9mIFdlYWtTZXQgPyBmLmFkZChvKSA6IGYuc2V0KG8sIGMpLCBNZSA9IChvLCBmLCBjLCBUKSA9PiAoU2UobywgZiwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpLCBUID8gVC5jYWxsKG8sIGMpIDogZi5zZXQobywgYyksIGMpO1xuY29uc3QgRHQgPSBbXG4gIFtcIkF6dGVjXCIsIFwiTVwiXSxcbiAgW1wiQ29kYWJhclwiLCBcIkxcIl0sXG4gIFtcIkNvZGUzOVwiLCBcIkxcIl0sXG4gIFtcIkNvZGU5M1wiLCBcIkxcIl0sXG4gIFtcIkNvZGUxMjhcIiwgXCJMXCJdLFxuICBbXCJEYXRhQmFyXCIsIFwiTFwiXSxcbiAgW1wiRGF0YUJhckV4cGFuZGVkXCIsIFwiTFwiXSxcbiAgW1wiRGF0YU1hdHJpeFwiLCBcIk1cIl0sXG4gIFtcIkVBTi04XCIsIFwiTFwiXSxcbiAgW1wiRUFOLTEzXCIsIFwiTFwiXSxcbiAgW1wiSVRGXCIsIFwiTFwiXSxcbiAgW1wiTWF4aUNvZGVcIiwgXCJNXCJdLFxuICBbXCJQREY0MTdcIiwgXCJNXCJdLFxuICBbXCJRUkNvZGVcIiwgXCJNXCJdLFxuICBbXCJVUEMtQVwiLCBcIkxcIl0sXG4gIFtcIlVQQy1FXCIsIFwiTFwiXSxcbiAgW1wiTWljcm9RUkNvZGVcIiwgXCJNXCJdLFxuICBbXCJyTVFSQ29kZVwiLCBcIk1cIl0sXG4gIFtcIkRYRmlsbUVkZ2VcIiwgXCJMXCJdLFxuICBbXCJEYXRhQmFyTGltaXRlZFwiLCBcIkxcIl1cbl0sIE10ID0gRHQubWFwKChbb10pID0+IG8pLCBMYSA9IE10LmZpbHRlcihcbiAgKG8sIGYpID0+IER0W2ZdWzFdID09PSBcIkxcIlxuKSwgQmEgPSBNdC5maWx0ZXIoXG4gIChvLCBmKSA9PiBEdFtmXVsxXSA9PT0gXCJNXCJcbik7XG5mdW5jdGlvbiBZdChvKSB7XG4gIHN3aXRjaCAobykge1xuICAgIGNhc2UgXCJMaW5lYXItQ29kZXNcIjpcbiAgICAgIHJldHVybiBMYS5yZWR1Y2UoKGYsIGMpID0+IGYgfCBZdChjKSwgMCk7XG4gICAgY2FzZSBcIk1hdHJpeC1Db2Rlc1wiOlxuICAgICAgcmV0dXJuIEJhLnJlZHVjZSgoZiwgYykgPT4gZiB8IFl0KGMpLCAwKTtcbiAgICBjYXNlIFwiQW55XCI6XG4gICAgICByZXR1cm4gKDEgPDwgRHQubGVuZ3RoKSAtIDE7XG4gICAgY2FzZSBcIk5vbmVcIjpcbiAgICAgIHJldHVybiAwO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gMSA8PCBNdC5pbmRleE9mKG8pO1xuICB9XG59XG5mdW5jdGlvbiBXYShvKSB7XG4gIGlmIChvID09PSAwKVxuICAgIHJldHVybiBcIk5vbmVcIjtcbiAgY29uc3QgZiA9IDMxIC0gTWF0aC5jbHozMihvKTtcbiAgcmV0dXJuIE10W2ZdO1xufVxuZnVuY3Rpb24gVWEobykge1xuICByZXR1cm4gby5yZWR1Y2UoKGYsIGMpID0+IGYgfCBZdChjKSwgMCk7XG59XG5jb25zdCBWYSA9IFtcbiAgXCJMb2NhbEF2ZXJhZ2VcIixcbiAgXCJHbG9iYWxIaXN0b2dyYW1cIixcbiAgXCJGaXhlZFRocmVzaG9sZFwiLFxuICBcIkJvb2xDYXN0XCJcbl07XG5mdW5jdGlvbiBrYShvKSB7XG4gIHJldHVybiBWYS5pbmRleE9mKG8pO1xufVxuY29uc3QgRmUgPSBbXG4gIFwiVW5rbm93blwiLFxuICBcIkFTQ0lJXCIsXG4gIFwiSVNPODg1OV8xXCIsXG4gIFwiSVNPODg1OV8yXCIsXG4gIFwiSVNPODg1OV8zXCIsXG4gIFwiSVNPODg1OV80XCIsXG4gIFwiSVNPODg1OV81XCIsXG4gIFwiSVNPODg1OV82XCIsXG4gIFwiSVNPODg1OV83XCIsXG4gIFwiSVNPODg1OV84XCIsXG4gIFwiSVNPODg1OV85XCIsXG4gIFwiSVNPODg1OV8xMFwiLFxuICBcIklTTzg4NTlfMTFcIixcbiAgXCJJU084ODU5XzEzXCIsXG4gIFwiSVNPODg1OV8xNFwiLFxuICBcIklTTzg4NTlfMTVcIixcbiAgXCJJU084ODU5XzE2XCIsXG4gIFwiQ3A0MzdcIixcbiAgXCJDcDEyNTBcIixcbiAgXCJDcDEyNTFcIixcbiAgXCJDcDEyNTJcIixcbiAgXCJDcDEyNTZcIixcbiAgXCJTaGlmdF9KSVNcIixcbiAgXCJCaWc1XCIsXG4gIFwiR0IyMzEyXCIsXG4gIFwiR0IxODAzMFwiLFxuICBcIkVVQ19KUFwiLFxuICBcIkVVQ19LUlwiLFxuICBcIlVURjE2QkVcIixcbiAgLyoqXG4gICAqIFVuaWNvZGVCaWcgW1tkZXByZWNhdGVkXV1cbiAgICovXG4gIFwiVVRGMTZCRVwiLFxuICBcIlVURjhcIixcbiAgXCJVVEYxNkxFXCIsXG4gIFwiVVRGMzJCRVwiLFxuICBcIlVURjMyTEVcIixcbiAgXCJCSU5BUllcIlxuXTtcbmZ1bmN0aW9uIEhhKG8pIHtcbiAgcmV0dXJuIG8gPT09IFwiVW5pY29kZUJpZ1wiID8gRmUuaW5kZXhPZihcIlVURjE2QkVcIikgOiBGZS5pbmRleE9mKG8pO1xufVxuY29uc3QgTmEgPSBbXG4gIFwiVGV4dFwiLFxuICBcIkJpbmFyeVwiLFxuICBcIk1peGVkXCIsXG4gIFwiR1MxXCIsXG4gIFwiSVNPMTU0MzRcIixcbiAgXCJVbmtub3duRUNJXCJcbl07XG5mdW5jdGlvbiB6YShvKSB7XG4gIHJldHVybiBOYVtvXTtcbn1cbmNvbnN0IEdhID0gW1wiSWdub3JlXCIsIFwiUmVhZFwiLCBcIlJlcXVpcmVcIl07XG5mdW5jdGlvbiBYYShvKSB7XG4gIHJldHVybiBHYS5pbmRleE9mKG8pO1xufVxuY29uc3QgcWEgPSBbXCJQbGFpblwiLCBcIkVDSVwiLCBcIkhSSVwiLCBcIkhleFwiLCBcIkVzY2FwZWRcIl07XG5mdW5jdGlvbiBZYShvKSB7XG4gIHJldHVybiBxYS5pbmRleE9mKG8pO1xufVxuY29uc3QgSXQgPSB7XG4gIGZvcm1hdHM6IFtdLFxuICB0cnlIYXJkZXI6ICEwLFxuICB0cnlSb3RhdGU6ICEwLFxuICB0cnlJbnZlcnQ6ICEwLFxuICB0cnlEb3duc2NhbGU6ICEwLFxuICB0cnlEZW5vaXNlOiAhMSxcbiAgYmluYXJpemVyOiBcIkxvY2FsQXZlcmFnZVwiLFxuICBpc1B1cmU6ICExLFxuICBkb3duc2NhbGVGYWN0b3I6IDMsXG4gIGRvd25zY2FsZVRocmVzaG9sZDogNTAwLFxuICBtaW5MaW5lQ291bnQ6IDIsXG4gIG1heE51bWJlck9mU3ltYm9sczogMjU1LFxuICB0cnlDb2RlMzlFeHRlbmRlZE1vZGU6ICEwLFxuICByZXR1cm5FcnJvcnM6ICExLFxuICBlYW5BZGRPblN5bWJvbDogXCJJZ25vcmVcIixcbiAgdGV4dE1vZGU6IFwiSFJJXCIsXG4gIGNoYXJhY3RlclNldDogXCJVbmtub3duXCJcbn07XG5mdW5jdGlvbiBqZShvKSB7XG4gIHJldHVybiB7XG4gICAgLi4ubyxcbiAgICBmb3JtYXRzOiBVYShvLmZvcm1hdHMpLFxuICAgIGJpbmFyaXplcjoga2Eoby5iaW5hcml6ZXIpLFxuICAgIGVhbkFkZE9uU3ltYm9sOiBYYShvLmVhbkFkZE9uU3ltYm9sKSxcbiAgICB0ZXh0TW9kZTogWWEoby50ZXh0TW9kZSksXG4gICAgY2hhcmFjdGVyU2V0OiBIYShvLmNoYXJhY3RlclNldClcbiAgfTtcbn1cbmZ1bmN0aW9uIFphKG8pIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5vLFxuICAgIGZvcm1hdDogV2Eoby5mb3JtYXQpLFxuICAgIGNvbnRlbnRUeXBlOiB6YShvLmNvbnRlbnRUeXBlKSxcbiAgICBlY2NMZXZlbDogby5lY0xldmVsXG4gIH07XG59XG5jb25zdCAkbyA9IFwiMi4xLjJcIiwgYm8gPSBcImExNTE2YjM0MTY3Y2ZmNTA0YmYzYzgzNjk4ZWE4NDFlMTNhOGY3ZjFcIiwgUWEgPSB7XG4gIGxvY2F0ZUZpbGU6IChvLCBmKSA9PiB7XG4gICAgY29uc3QgYyA9IG8ubWF0Y2goL18oLis/KVxcLndhc20kLyk7XG4gICAgcmV0dXJuIGMgPyBgaHR0cHM6Ly9mYXN0bHkuanNkZWxpdnIubmV0L25wbS96eGluZy13YXNtQDIuMS4yL2Rpc3QvJHtjWzFdfS8ke299YCA6IGYgKyBvO1xuICB9XG59LCBTdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gSmEobywgZikge1xuICByZXR1cm4gT2JqZWN0LmlzKG8sIGYpIHx8IE9iamVjdC5rZXlzKG8pLmxlbmd0aCA9PT0gT2JqZWN0LmtleXMoZikubGVuZ3RoICYmIE9iamVjdC5rZXlzKG8pLmV2ZXJ5KFxuICAgIChjKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZiwgYykgJiYgb1tjXSA9PT0gZltjXVxuICApO1xufVxuZnVuY3Rpb24gTGUobywge1xuICBvdmVycmlkZXM6IGYsXG4gIGVxdWFsaXR5Rm46IGMgPSBKYSxcbiAgZmlyZUltbWVkaWF0ZWx5OiBUID0gITFcbn0gPSB7fSkge1xuICB2YXIgJDtcbiAgY29uc3QgW3gsIERdID0gKCQgPSBTdC5nZXQobykpICE9IG51bGwgPyAkIDogW1FhXSwgUiA9IGYgIT0gbnVsbCA/IGYgOiB4O1xuICBsZXQgTztcbiAgaWYgKFQpIHtcbiAgICBpZiAoRCAmJiAoTyA9IGMoeCwgUikpKVxuICAgICAgcmV0dXJuIEQ7XG4gICAgY29uc3QgTSA9IG8oe1xuICAgICAgLi4uUlxuICAgIH0pO1xuICAgIHJldHVybiBTdC5zZXQobywgW1IsIE1dKSwgTTtcbiAgfVxuICAoTyAhPSBudWxsID8gTyA6IGMoeCwgUikpIHx8IFN0LnNldChvLCBbUl0pO1xufVxuZnVuY3Rpb24gS2Eobykge1xuICBTdC5kZWxldGUobyk7XG59XG5hc3luYyBmdW5jdGlvbiB0byhvLCBmLCBjID0gSXQpIHtcbiAgY29uc3QgVCA9IHtcbiAgICAuLi5JdCxcbiAgICAuLi5jXG4gIH0sICQgPSBhd2FpdCBMZShvLCB7XG4gICAgZmlyZUltbWVkaWF0ZWx5OiAhMFxuICB9KTtcbiAgbGV0IHgsIEQ7XG4gIGlmIChcIndpZHRoXCIgaW4gZiAmJiBcImhlaWdodFwiIGluIGYgJiYgXCJkYXRhXCIgaW4gZikge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IE8sXG4gICAgICBkYXRhOiB7IGJ5dGVMZW5ndGg6IE0gfSxcbiAgICAgIHdpZHRoOiBGLFxuICAgICAgaGVpZ2h0OiBxXG4gICAgfSA9IGY7XG4gICAgRCA9ICQuX21hbGxvYyhNKSwgJC5IRUFQVTguc2V0KE8sIEQpLCB4ID0gJC5yZWFkQmFyY29kZXNGcm9tUGl4bWFwKFxuICAgICAgRCxcbiAgICAgIEYsXG4gICAgICBxLFxuICAgICAgamUoVClcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGxldCBPLCBNO1xuICAgIGlmIChcImJ1ZmZlclwiIGluIGYpXG4gICAgICBbTywgTV0gPSBbZi5ieXRlTGVuZ3RoLCBmXTtcbiAgICBlbHNlIGlmIChcImJ5dGVMZW5ndGhcIiBpbiBmKVxuICAgICAgW08sIE1dID0gW2YuYnl0ZUxlbmd0aCwgbmV3IFVpbnQ4QXJyYXkoZildO1xuICAgIGVsc2UgaWYgKFwic2l6ZVwiIGluIGYpXG4gICAgICBbTywgTV0gPSBbZi5zaXplLCBuZXcgVWludDhBcnJheShhd2FpdCBmLmFycmF5QnVmZmVyKCkpXTtcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlXCIpO1xuICAgIEQgPSAkLl9tYWxsb2MoTyksICQuSEVBUFU4LnNldChNLCBEKSwgeCA9ICQucmVhZEJhcmNvZGVzRnJvbUltYWdlKFxuICAgICAgRCxcbiAgICAgIE8sXG4gICAgICBqZShUKVxuICAgICk7XG4gIH1cbiAgJC5fZnJlZShEKTtcbiAgY29uc3QgUiA9IFtdO1xuICBmb3IgKGxldCBPID0gMDsgTyA8IHguc2l6ZSgpOyArK08pXG4gICAgUi5wdXNoKFxuICAgICAgWmEoeC5nZXQoTykpXG4gICAgKTtcbiAgcmV0dXJuIFI7XG59XG4oe1xuICAuLi5JdCxcbiAgZm9ybWF0czogWy4uLkl0LmZvcm1hdHNdXG59KTtcbnZhciBRdCA9IGFzeW5jIGZ1bmN0aW9uKG8gPSB7fSkge1xuICB2YXIgZiwgYyA9IG8sIFQsICQsIHggPSBuZXcgUHJvbWlzZSgoZSwgdCkgPT4ge1xuICAgIFQgPSBlLCAkID0gdDtcbiAgfSksIEQgPSB0eXBlb2Ygd2luZG93ID09IFwib2JqZWN0XCIsIFIgPSB0eXBlb2YgQnVuIDwgXCJ1XCIsIE8gPSB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgPCBcInVcIjtcbiAgdHlwZW9mIHByb2Nlc3MgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgPT0gXCJzdHJpbmdcIiAmJiBwcm9jZXNzLnR5cGUgIT0gXCJyZW5kZXJlclwiO1xuICB2YXIgTSA9IFwiLi90aGlzLnByb2dyYW1cIiwgRiA9IFwiXCI7XG4gIGZ1bmN0aW9uIHEoZSkge1xuICAgIHJldHVybiBjLmxvY2F0ZUZpbGUgPyBjLmxvY2F0ZUZpbGUoZSwgRikgOiBGICsgZTtcbiAgfVxuICB2YXIgcnQsIFk7XG4gIChEIHx8IE8gfHwgUikgJiYgKE8gPyBGID0gc2VsZi5sb2NhdGlvbi5ocmVmIDogdHlwZW9mIGRvY3VtZW50IDwgXCJ1XCIgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCAmJiAoRiA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSwgRi5zdGFydHNXaXRoKFwiYmxvYjpcIikgPyBGID0gXCJcIiA6IEYgPSBGLnNsaWNlKDAsIEYucmVwbGFjZSgvWz8jXS4qLywgXCJcIikubGFzdEluZGV4T2YoXCIvXCIpICsgMSksIE8gJiYgKFkgPSAoZSkgPT4ge1xuICAgIHZhciB0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmV0dXJuIHQub3BlbihcIkdFVFwiLCBlLCAhMSksIHQucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiLCB0LnNlbmQobnVsbCksIG5ldyBVaW50OEFycmF5KHQucmVzcG9uc2UpO1xuICB9KSwgcnQgPSBhc3luYyAoZSkgPT4ge1xuICAgIHZhciB0ID0gYXdhaXQgZmV0Y2goZSwge1xuICAgICAgY3JlZGVudGlhbHM6IFwic2FtZS1vcmlnaW5cIlxuICAgIH0pO1xuICAgIGlmICh0Lm9rKVxuICAgICAgcmV0dXJuIHQuYXJyYXlCdWZmZXIoKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IodC5zdGF0dXMgKyBcIiA6IFwiICsgdC51cmwpO1xuICB9KTtcbiAgdmFyIHN0ID0gY29uc29sZS5sb2cuYmluZChjb25zb2xlKSwgayA9IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSwgWiwgbnQsIEp0ID0gITEsIFEsIEIsIHV0LCB2dCwgYXQsIFAsIEt0LCB0ZTtcbiAgZnVuY3Rpb24gZWUoKSB7XG4gICAgdmFyIGUgPSBudC5idWZmZXI7XG4gICAgUSA9IG5ldyBJbnQ4QXJyYXkoZSksIHV0ID0gbmV3IEludDE2QXJyYXkoZSksIGMuSEVBUFU4ID0gQiA9IG5ldyBVaW50OEFycmF5KGUpLCB2dCA9IG5ldyBVaW50MTZBcnJheShlKSwgYXQgPSBuZXcgSW50MzJBcnJheShlKSwgUCA9IG5ldyBVaW50MzJBcnJheShlKSwgS3QgPSBuZXcgRmxvYXQzMkFycmF5KGUpLCB0ZSA9IG5ldyBGbG9hdDY0QXJyYXkoZSk7XG4gIH1cbiAgZnVuY3Rpb24gcWUoKSB7XG4gICAgaWYgKGMucHJlUnVuKVxuICAgICAgZm9yICh0eXBlb2YgYy5wcmVSdW4gPT0gXCJmdW5jdGlvblwiICYmIChjLnByZVJ1biA9IFtjLnByZVJ1bl0pOyBjLnByZVJ1bi5sZW5ndGg7IClcbiAgICAgICAgc3IoYy5wcmVSdW4uc2hpZnQoKSk7XG4gICAgcmUoYWUpO1xuICB9XG4gIGZ1bmN0aW9uIFllKCkge1xuICAgIEUueWEoKTtcbiAgfVxuICBmdW5jdGlvbiBaZSgpIHtcbiAgICBpZiAoYy5wb3N0UnVuKVxuICAgICAgZm9yICh0eXBlb2YgYy5wb3N0UnVuID09IFwiZnVuY3Rpb25cIiAmJiAoYy5wb3N0UnVuID0gW2MucG9zdFJ1bl0pOyBjLnBvc3RSdW4ubGVuZ3RoOyApXG4gICAgICAgIGlyKGMucG9zdFJ1bi5zaGlmdCgpKTtcbiAgICByZShuZSk7XG4gIH1cbiAgdmFyIEogPSAwLCBjdCA9IG51bGw7XG4gIGZ1bmN0aW9uIFFlKGUpIHtcbiAgICB2YXIgdDtcbiAgICBKKyssICh0ID0gYy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKSA9PT0gbnVsbCB8fCB0ID09PSB2b2lkIDAgfHwgdC5jYWxsKGMsIEopO1xuICB9XG4gIGZ1bmN0aW9uIEplKGUpIHtcbiAgICB2YXIgdDtcbiAgICBpZiAoSi0tLCAodCA9IGMubW9uaXRvclJ1bkRlcGVuZGVuY2llcykgPT09IG51bGwgfHwgdCA9PT0gdm9pZCAwIHx8IHQuY2FsbChjLCBKKSwgSiA9PSAwICYmIGN0KSB7XG4gICAgICB2YXIgciA9IGN0O1xuICAgICAgY3QgPSBudWxsLCByKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIEZ0KGUpIHtcbiAgICB2YXIgdDtcbiAgICAodCA9IGMub25BYm9ydCkgPT09IG51bGwgfHwgdCA9PT0gdm9pZCAwIHx8IHQuY2FsbChjLCBlKSwgZSA9IFwiQWJvcnRlZChcIiArIGUgKyBcIilcIiwgayhlKSwgSnQgPSAhMCwgZSArPSBcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIjtcbiAgICB2YXIgciA9IG5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoZSk7XG4gICAgdGhyb3cgJChyKSwgcjtcbiAgfVxuICB2YXIgeXQ7XG4gIGZ1bmN0aW9uIEtlKCkge1xuICAgIHJldHVybiBxKFwienhpbmdfcmVhZGVyLndhc21cIik7XG4gIH1cbiAgZnVuY3Rpb24gdHIoZSkge1xuICAgIGlmIChlID09IHl0ICYmIFopXG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWik7XG4gICAgaWYgKFkpXG4gICAgICByZXR1cm4gWShlKTtcbiAgICB0aHJvdyBcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCI7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZXIoZSkge1xuICAgIGlmICghWilcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB0ID0gYXdhaXQgcnQoZSk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgIHJldHVybiB0cihlKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBycihlLCB0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciByID0gYXdhaXQgZXIoZSksIG4gPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShyLCB0KTtcbiAgICAgIHJldHVybiBuO1xuICAgIH0gY2F0Y2ggKGEpIHtcbiAgICAgIGsoYGZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206ICR7YX1gKSwgRnQoYSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG5yKGUsIHQsIHIpIHtcbiAgICBpZiAoIWUgJiYgdHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nID09IFwiZnVuY3Rpb25cIilcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuID0gZmV0Y2godCwge1xuICAgICAgICAgIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCJcbiAgICAgICAgfSksIGEgPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhuLCByKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGNhdGNoIChpKSB7XG4gICAgICAgIGsoYHdhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAke2l9YCksIGsoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKTtcbiAgICAgIH1cbiAgICByZXR1cm4gcnIodCwgcik7XG4gIH1cbiAgZnVuY3Rpb24gYXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGE6IEhuXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBvcigpIHtcbiAgICBmdW5jdGlvbiBlKGksIHUpIHtcbiAgICAgIHJldHVybiBFID0gaS5leHBvcnRzLCBudCA9IEUueGEsIGVlKCksIHBlID0gRS5CYSwgSmUoKSwgRTtcbiAgICB9XG4gICAgUWUoKTtcbiAgICBmdW5jdGlvbiB0KGkpIHtcbiAgICAgIHJldHVybiBlKGkuaW5zdGFuY2UpO1xuICAgIH1cbiAgICB2YXIgciA9IGFyKCk7XG4gICAgaWYgKGMuaW5zdGFudGlhdGVXYXNtKVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChpLCB1KSA9PiB7XG4gICAgICAgIGMuaW5zdGFudGlhdGVXYXNtKHIsIChzLCBsKSA9PiB7XG4gICAgICAgICAgaShlKHMpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB5dCAhPSBudWxsIHx8ICh5dCA9IEtlKCkpO1xuICAgIHRyeSB7XG4gICAgICB2YXIgbiA9IGF3YWl0IG5yKFosIHl0LCByKSwgYSA9IHQobik7XG4gICAgICByZXR1cm4gYTtcbiAgICB9IGNhdGNoIChpKSB7XG4gICAgICByZXR1cm4gJChpKSwgUHJvbWlzZS5yZWplY3QoaSk7XG4gICAgfVxuICB9XG4gIHZhciByZSA9IChlKSA9PiB7XG4gICAgZm9yICg7IGUubGVuZ3RoID4gMDsgKVxuICAgICAgZS5zaGlmdCgpKGMpO1xuICB9LCBuZSA9IFtdLCBpciA9IChlKSA9PiBuZS5wdXNoKGUpLCBhZSA9IFtdLCBzciA9IChlKSA9PiBhZS5wdXNoKGUpLCB5ID0gKGUpID0+IFhuKGUpLCBtID0gKCkgPT4gcW4oKSwgbXQgPSBbXSwgZ3QgPSAwLCB1ciA9IChlKSA9PiB7XG4gICAgdmFyIHQgPSBuZXcganQoZSk7XG4gICAgcmV0dXJuIHQuZ2V0X2NhdWdodCgpIHx8ICh0LnNldF9jYXVnaHQoITApLCBndC0tKSwgdC5zZXRfcmV0aHJvd24oITEpLCBtdC5wdXNoKHQpLCBabihlKSwgem4oZSk7XG4gIH0sIEggPSAwLCBjciA9ICgpID0+IHtcbiAgICB2KDAsIDApO1xuICAgIHZhciBlID0gbXQucG9wKCk7XG4gICAgWW4oZS5leGNQdHIpLCBIID0gMDtcbiAgfTtcbiAgY2xhc3MganQge1xuICAgIGNvbnN0cnVjdG9yKHQpIHtcbiAgICAgIHRoaXMuZXhjUHRyID0gdCwgdGhpcy5wdHIgPSB0IC0gMjQ7XG4gICAgfVxuICAgIHNldF90eXBlKHQpIHtcbiAgICAgIFBbdGhpcy5wdHIgKyA0ID4+IDJdID0gdDtcbiAgICB9XG4gICAgZ2V0X3R5cGUoKSB7XG4gICAgICByZXR1cm4gUFt0aGlzLnB0ciArIDQgPj4gMl07XG4gICAgfVxuICAgIHNldF9kZXN0cnVjdG9yKHQpIHtcbiAgICAgIFBbdGhpcy5wdHIgKyA4ID4+IDJdID0gdDtcbiAgICB9XG4gICAgZ2V0X2Rlc3RydWN0b3IoKSB7XG4gICAgICByZXR1cm4gUFt0aGlzLnB0ciArIDggPj4gMl07XG4gICAgfVxuICAgIHNldF9jYXVnaHQodCkge1xuICAgICAgdCA9IHQgPyAxIDogMCwgUVt0aGlzLnB0ciArIDEyXSA9IHQ7XG4gICAgfVxuICAgIGdldF9jYXVnaHQoKSB7XG4gICAgICByZXR1cm4gUVt0aGlzLnB0ciArIDEyXSAhPSAwO1xuICAgIH1cbiAgICBzZXRfcmV0aHJvd24odCkge1xuICAgICAgdCA9IHQgPyAxIDogMCwgUVt0aGlzLnB0ciArIDEzXSA9IHQ7XG4gICAgfVxuICAgIGdldF9yZXRocm93bigpIHtcbiAgICAgIHJldHVybiBRW3RoaXMucHRyICsgMTNdICE9IDA7XG4gICAgfVxuICAgIGluaXQodCwgcikge1xuICAgICAgdGhpcy5zZXRfYWRqdXN0ZWRfcHRyKDApLCB0aGlzLnNldF90eXBlKHQpLCB0aGlzLnNldF9kZXN0cnVjdG9yKHIpO1xuICAgIH1cbiAgICBzZXRfYWRqdXN0ZWRfcHRyKHQpIHtcbiAgICAgIFBbdGhpcy5wdHIgKyAxNiA+PiAyXSA9IHQ7XG4gICAgfVxuICAgIGdldF9hZGp1c3RlZF9wdHIoKSB7XG4gICAgICByZXR1cm4gUFt0aGlzLnB0ciArIDE2ID4+IDJdO1xuICAgIH1cbiAgfVxuICB2YXIgd3QgPSAoZSkgPT4gR24oZSksIFJ0ID0gKGUpID0+IHtcbiAgICB2YXIgdCA9IEg7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuIHd0KDApLCAwO1xuICAgIHZhciByID0gbmV3IGp0KHQpO1xuICAgIHIuc2V0X2FkanVzdGVkX3B0cih0KTtcbiAgICB2YXIgbiA9IHIuZ2V0X3R5cGUoKTtcbiAgICBpZiAoIW4pXG4gICAgICByZXR1cm4gd3QoMCksIHQ7XG4gICAgZm9yICh2YXIgYSBvZiBlKSB7XG4gICAgICBpZiAoYSA9PT0gMCB8fCBhID09PSBuKVxuICAgICAgICBicmVhaztcbiAgICAgIHZhciBpID0gci5wdHIgKyAxNjtcbiAgICAgIGlmIChRbihhLCBuLCBpKSlcbiAgICAgICAgcmV0dXJuIHd0KGEpLCB0O1xuICAgIH1cbiAgICByZXR1cm4gd3QobiksIHQ7XG4gIH0sIGxyID0gKCkgPT4gUnQoW10pLCBmciA9IChlKSA9PiBSdChbZV0pLCBkciA9IChlLCB0KSA9PiBSdChbZSwgdF0pLCBociA9ICgpID0+IHtcbiAgICB2YXIgZSA9IG10LnBvcCgpO1xuICAgIGUgfHwgRnQoXCJubyBleGNlcHRpb24gdG8gdGhyb3dcIik7XG4gICAgdmFyIHQgPSBlLmV4Y1B0cjtcbiAgICB0aHJvdyBlLmdldF9yZXRocm93bigpIHx8IChtdC5wdXNoKGUpLCBlLnNldF9yZXRocm93bighMCksIGUuc2V0X2NhdWdodCghMSksIGd0KyspLCBIID0gdCwgSDtcbiAgfSwgcHIgPSAoZSwgdCwgcikgPT4ge1xuICAgIHZhciBuID0gbmV3IGp0KGUpO1xuICAgIHRocm93IG4uaW5pdCh0LCByKSwgSCA9IGUsIGd0KyssIEg7XG4gIH0sIHZyID0gKCkgPT4gZ3QsIHlyID0gKGUpID0+IHtcbiAgICB0aHJvdyBIIHx8IChIID0gZSksIEg7XG4gIH0sIG1yID0gKCkgPT4gRnQoXCJcIiksICR0ID0ge30sIEx0ID0gKGUpID0+IHtcbiAgICBmb3IgKDsgZS5sZW5ndGg7ICkge1xuICAgICAgdmFyIHQgPSBlLnBvcCgpLCByID0gZS5wb3AoKTtcbiAgICAgIHIodCk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBsdChlKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKFBbZSA+PiAyXSk7XG4gIH1cbiAgdmFyIG90ID0ge30sIEsgPSB7fSwgYnQgPSB7fSwgZ3IgPSBjLkludGVybmFsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgICBzdXBlcihlKSwgdGhpcy5uYW1lID0gXCJJbnRlcm5hbEVycm9yXCI7XG4gICAgfVxuICB9LCBDdCA9IChlKSA9PiB7XG4gICAgdGhyb3cgbmV3IGdyKGUpO1xuICB9LCB0dCA9IChlLCB0LCByKSA9PiB7XG4gICAgZS5mb3JFYWNoKChzKSA9PiBidFtzXSA9IHQpO1xuICAgIGZ1bmN0aW9uIG4ocykge1xuICAgICAgdmFyIGwgPSByKHMpO1xuICAgICAgbC5sZW5ndGggIT09IGUubGVuZ3RoICYmIEN0KFwiTWlzbWF0Y2hlZCB0eXBlIGNvbnZlcnRlciBjb3VudFwiKTtcbiAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZS5sZW5ndGg7ICsrZClcbiAgICAgICAgVihlW2RdLCBsW2RdKTtcbiAgICB9XG4gICAgdmFyIGEgPSBuZXcgQXJyYXkodC5sZW5ndGgpLCBpID0gW10sIHUgPSAwO1xuICAgIHQuZm9yRWFjaCgocywgbCkgPT4ge1xuICAgICAgSy5oYXNPd25Qcm9wZXJ0eShzKSA/IGFbbF0gPSBLW3NdIDogKGkucHVzaChzKSwgb3QuaGFzT3duUHJvcGVydHkocykgfHwgKG90W3NdID0gW10pLCBvdFtzXS5wdXNoKCgpID0+IHtcbiAgICAgICAgYVtsXSA9IEtbc10sICsrdSwgdSA9PT0gaS5sZW5ndGggJiYgbihhKTtcbiAgICAgIH0pKTtcbiAgICB9KSwgaS5sZW5ndGggPT09IDAgJiYgbihhKTtcbiAgfSwgd3IgPSAoZSkgPT4ge1xuICAgIHZhciB0ID0gJHRbZV07XG4gICAgZGVsZXRlICR0W2VdO1xuICAgIHZhciByID0gdC5yYXdDb25zdHJ1Y3RvciwgbiA9IHQucmF3RGVzdHJ1Y3RvciwgYSA9IHQuZmllbGRzLCBpID0gYS5tYXAoKHUpID0+IHUuZ2V0dGVyUmV0dXJuVHlwZSkuY29uY2F0KGEubWFwKCh1KSA9PiB1LnNldHRlckFyZ3VtZW50VHlwZSkpO1xuICAgIHR0KFtlXSwgaSwgKHUpID0+IHtcbiAgICAgIHZhciBzID0ge307XG4gICAgICByZXR1cm4gYS5mb3JFYWNoKChsLCBkKSA9PiB7XG4gICAgICAgIHZhciBoID0gbC5maWVsZE5hbWUsIHAgPSB1W2RdLCB3ID0gdVtkXS5vcHRpb25hbCwgYiA9IGwuZ2V0dGVyLCBfID0gbC5nZXR0ZXJDb250ZXh0LCBTID0gdVtkICsgYS5sZW5ndGhdLCBBID0gbC5zZXR0ZXIsIEkgPSBsLnNldHRlckNvbnRleHQ7XG4gICAgICAgIHNbaF0gPSB7XG4gICAgICAgICAgcmVhZDogKFgpID0+IHAuZnJvbVdpcmVUeXBlKGIoXywgWCkpLFxuICAgICAgICAgIHdyaXRlOiAoWCwgTCkgPT4ge1xuICAgICAgICAgICAgdmFyIFcgPSBbXTtcbiAgICAgICAgICAgIEEoSSwgWCwgUy50b1dpcmVUeXBlKFcsIEwpKSwgTHQoVyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcHRpb25hbDogd1xuICAgICAgICB9O1xuICAgICAgfSksIFt7XG4gICAgICAgIG5hbWU6IHQubmFtZSxcbiAgICAgICAgZnJvbVdpcmVUeXBlOiAobCkgPT4ge1xuICAgICAgICAgIHZhciBkID0ge307XG4gICAgICAgICAgZm9yICh2YXIgaCBpbiBzKVxuICAgICAgICAgICAgZFtoXSA9IHNbaF0ucmVhZChsKTtcbiAgICAgICAgICByZXR1cm4gbihsKSwgZDtcbiAgICAgICAgfSxcbiAgICAgICAgdG9XaXJlVHlwZTogKGwsIGQpID0+IHtcbiAgICAgICAgICBmb3IgKHZhciBoIGluIHMpXG4gICAgICAgICAgICBpZiAoIShoIGluIGQpICYmICFzW2hdLm9wdGlvbmFsKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBNaXNzaW5nIGZpZWxkOiBcIiR7aH1cImApO1xuICAgICAgICAgIHZhciBwID0gcigpO1xuICAgICAgICAgIGZvciAoaCBpbiBzKVxuICAgICAgICAgICAgc1toXS53cml0ZShwLCBkW2hdKTtcbiAgICAgICAgICByZXR1cm4gbCAhPT0gbnVsbCAmJiBsLnB1c2gobiwgcCksIHA7XG4gICAgICAgIH0sXG4gICAgICAgIGFyZ1BhY2tBZHZhbmNlOiBOLFxuICAgICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogbHQsXG4gICAgICAgIGRlc3RydWN0b3JGdW5jdGlvbjogblxuICAgICAgfV07XG4gICAgfSk7XG4gIH0sICRyID0gKGUsIHQsIHIsIG4sIGEpID0+IHtcbiAgfSwgYnIgPSAoKSA9PiB7XG4gICAgZm9yICh2YXIgZSA9IG5ldyBBcnJheSgyNTYpLCB0ID0gMDsgdCA8IDI1NjsgKyt0KVxuICAgICAgZVt0XSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodCk7XG4gICAgb2UgPSBlO1xuICB9LCBvZSwgaiA9IChlKSA9PiB7XG4gICAgZm9yICh2YXIgdCA9IFwiXCIsIHIgPSBlOyBCW3JdOyApXG4gICAgICB0ICs9IG9lW0JbcisrXV07XG4gICAgcmV0dXJuIHQ7XG4gIH0sIGZ0ID0gYy5CaW5kaW5nRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgICBzdXBlcihlKSwgdGhpcy5uYW1lID0gXCJCaW5kaW5nRXJyb3JcIjtcbiAgICB9XG4gIH0sIEMgPSAoZSkgPT4ge1xuICAgIHRocm93IG5ldyBmdChlKTtcbiAgfTtcbiAgZnVuY3Rpb24gQ3IoZSwgdCkge1xuICAgIGxldCByID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgbiA9IHQubmFtZTtcbiAgICBpZiAoZSB8fCBDKGB0eXBlIFwiJHtufVwiIG11c3QgaGF2ZSBhIHBvc2l0aXZlIGludGVnZXIgdHlwZWlkIHBvaW50ZXJgKSwgSy5oYXNPd25Qcm9wZXJ0eShlKSkge1xuICAgICAgaWYgKHIuaWdub3JlRHVwbGljYXRlUmVnaXN0cmF0aW9ucylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgQyhgQ2Fubm90IHJlZ2lzdGVyIHR5cGUgJyR7bn0nIHR3aWNlYCk7XG4gICAgfVxuICAgIGlmIChLW2VdID0gdCwgZGVsZXRlIGJ0W2VdLCBvdC5oYXNPd25Qcm9wZXJ0eShlKSkge1xuICAgICAgdmFyIGEgPSBvdFtlXTtcbiAgICAgIGRlbGV0ZSBvdFtlXSwgYS5mb3JFYWNoKChpKSA9PiBpKCkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBWKGUsIHQpIHtcbiAgICBsZXQgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIENyKGUsIHQsIHIpO1xuICB9XG4gIHZhciBOID0gOCwgVHIgPSAoZSwgdCwgciwgbikgPT4ge1xuICAgIHQgPSBqKHQpLCBWKGUsIHtcbiAgICAgIG5hbWU6IHQsXG4gICAgICBmcm9tV2lyZVR5cGU6IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgcmV0dXJuICEhYTtcbiAgICAgIH0sXG4gICAgICB0b1dpcmVUeXBlOiBmdW5jdGlvbihhLCBpKSB7XG4gICAgICAgIHJldHVybiBpID8gciA6IG47XG4gICAgICB9LFxuICAgICAgYXJnUGFja0FkdmFuY2U6IE4sXG4gICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogZnVuY3Rpb24oYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoQlthXSk7XG4gICAgICB9LFxuICAgICAgZGVzdHJ1Y3RvckZ1bmN0aW9uOiBudWxsXG4gICAgfSk7XG4gIH0sIFByID0gKGUpID0+ICh7XG4gICAgY291bnQ6IGUuY291bnQsXG4gICAgZGVsZXRlU2NoZWR1bGVkOiBlLmRlbGV0ZVNjaGVkdWxlZCxcbiAgICBwcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZTogZS5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSxcbiAgICBwdHI6IGUucHRyLFxuICAgIHB0clR5cGU6IGUucHRyVHlwZSxcbiAgICBzbWFydFB0cjogZS5zbWFydFB0cixcbiAgICBzbWFydFB0clR5cGU6IGUuc21hcnRQdHJUeXBlXG4gIH0pLCBCdCA9IChlKSA9PiB7XG4gICAgZnVuY3Rpb24gdChyKSB7XG4gICAgICByZXR1cm4gci4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzcy5uYW1lO1xuICAgIH1cbiAgICBDKHQoZSkgKyBcIiBpbnN0YW5jZSBhbHJlYWR5IGRlbGV0ZWRcIik7XG4gIH0sIFd0ID0gITEsIGllID0gKGUpID0+IHtcbiAgfSwgRXIgPSAoZSkgPT4ge1xuICAgIGUuc21hcnRQdHIgPyBlLnNtYXJ0UHRyVHlwZS5yYXdEZXN0cnVjdG9yKGUuc21hcnRQdHIpIDogZS5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzcy5yYXdEZXN0cnVjdG9yKGUucHRyKTtcbiAgfSwgc2UgPSAoZSkgPT4ge1xuICAgIGUuY291bnQudmFsdWUgLT0gMTtcbiAgICB2YXIgdCA9IGUuY291bnQudmFsdWUgPT09IDA7XG4gICAgdCAmJiBFcihlKTtcbiAgfSwgZHQgPSAoZSkgPT4gdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID4gXCJ1XCIgPyAoZHQgPSAodCkgPT4gdCwgZSkgOiAoV3QgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKHQpID0+IHtcbiAgICBzZSh0LiQkKTtcbiAgfSksIGR0ID0gKHQpID0+IHtcbiAgICB2YXIgciA9IHQuJCQsIG4gPSAhIXIuc21hcnRQdHI7XG4gICAgaWYgKG4pIHtcbiAgICAgIHZhciBhID0ge1xuICAgICAgICAkJDogclxuICAgICAgfTtcbiAgICAgIFd0LnJlZ2lzdGVyKHQsIGEsIHQpO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfSwgaWUgPSAodCkgPT4gV3QudW5yZWdpc3Rlcih0KSwgZHQoZSkpLCBfciA9ICgpID0+IHtcbiAgICBsZXQgZSA9IFR0LnByb3RvdHlwZTtcbiAgICBPYmplY3QuYXNzaWduKGUsIHtcbiAgICAgIGlzQWxpYXNPZihyKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUdCkgfHwgIShyIGluc3RhbmNlb2YgVHQpKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgdmFyIG4gPSB0aGlzLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzLCBhID0gdGhpcy4kJC5wdHI7XG4gICAgICAgIHIuJCQgPSByLiQkO1xuICAgICAgICBmb3IgKHZhciBpID0gci4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzcywgdSA9IHIuJCQucHRyOyBuLmJhc2VDbGFzczsgKVxuICAgICAgICAgIGEgPSBuLnVwY2FzdChhKSwgbiA9IG4uYmFzZUNsYXNzO1xuICAgICAgICBmb3IgKDsgaS5iYXNlQ2xhc3M7IClcbiAgICAgICAgICB1ID0gaS51cGNhc3QodSksIGkgPSBpLmJhc2VDbGFzcztcbiAgICAgICAgcmV0dXJuIG4gPT09IGkgJiYgYSA9PT0gdTtcbiAgICAgIH0sXG4gICAgICBjbG9uZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuJCQucHRyIHx8IEJ0KHRoaXMpLCB0aGlzLiQkLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlKVxuICAgICAgICAgIHJldHVybiB0aGlzLiQkLmNvdW50LnZhbHVlICs9IDEsIHRoaXM7XG4gICAgICAgIHZhciByID0gZHQoT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHtcbiAgICAgICAgICAkJDoge1xuICAgICAgICAgICAgdmFsdWU6IFByKHRoaXMuJCQpXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiByLiQkLmNvdW50LnZhbHVlICs9IDEsIHIuJCQuZGVsZXRlU2NoZWR1bGVkID0gITEsIHI7XG4gICAgICB9LFxuICAgICAgZGVsZXRlKCkge1xuICAgICAgICB0aGlzLiQkLnB0ciB8fCBCdCh0aGlzKSwgdGhpcy4kJC5kZWxldGVTY2hlZHVsZWQgJiYgIXRoaXMuJCQucHJlc2VydmVQb2ludGVyT25EZWxldGUgJiYgQyhcIk9iamVjdCBhbHJlYWR5IHNjaGVkdWxlZCBmb3IgZGVsZXRpb25cIiksIGllKHRoaXMpLCBzZSh0aGlzLiQkKSwgdGhpcy4kJC5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSB8fCAodGhpcy4kJC5zbWFydFB0ciA9IHZvaWQgMCwgdGhpcy4kJC5wdHIgPSB2b2lkIDApO1xuICAgICAgfSxcbiAgICAgIGlzRGVsZXRlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLiQkLnB0cjtcbiAgICAgIH0sXG4gICAgICBkZWxldGVMYXRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJCQucHRyIHx8IEJ0KHRoaXMpLCB0aGlzLiQkLmRlbGV0ZVNjaGVkdWxlZCAmJiAhdGhpcy4kJC5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSAmJiBDKFwiT2JqZWN0IGFscmVhZHkgc2NoZWR1bGVkIGZvciBkZWxldGlvblwiKSwgdGhpcy4kJC5kZWxldGVTY2hlZHVsZWQgPSAhMCwgdGhpcztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCB0ID0gU3ltYm9sLmRpc3Bvc2U7XG4gICAgdCAmJiAoZVt0XSA9IGUuZGVsZXRlKTtcbiAgfTtcbiAgZnVuY3Rpb24gVHQoKSB7XG4gIH1cbiAgdmFyIFV0ID0gKGUsIHQpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIm5hbWVcIiwge1xuICAgIHZhbHVlOiBlXG4gIH0pLCB1ZSA9IHt9LCBjZSA9IChlLCB0LCByKSA9PiB7XG4gICAgaWYgKGVbdF0ub3ZlcmxvYWRUYWJsZSA9PT0gdm9pZCAwKSB7XG4gICAgICB2YXIgbiA9IGVbdF07XG4gICAgICBlW3RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHMubGVuZ3RoLCBpID0gbmV3IEFycmF5KGEpLCB1ID0gMDsgdSA8IGE7IHUrKylcbiAgICAgICAgICBpW3VdID0gYXJndW1lbnRzW3VdO1xuICAgICAgICByZXR1cm4gZVt0XS5vdmVybG9hZFRhYmxlLmhhc093blByb3BlcnR5KGkubGVuZ3RoKSB8fCBDKGBGdW5jdGlvbiAnJHtyfScgY2FsbGVkIHdpdGggYW4gaW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzICgke2kubGVuZ3RofSkgLSBleHBlY3RzIG9uZSBvZiAoJHtlW3RdLm92ZXJsb2FkVGFibGV9KSFgKSwgZVt0XS5vdmVybG9hZFRhYmxlW2kubGVuZ3RoXS5hcHBseSh0aGlzLCBpKTtcbiAgICAgIH0sIGVbdF0ub3ZlcmxvYWRUYWJsZSA9IFtdLCBlW3RdLm92ZXJsb2FkVGFibGVbbi5hcmdDb3VudF0gPSBuO1xuICAgIH1cbiAgfSwgbGUgPSAoZSwgdCwgcikgPT4ge1xuICAgIGMuaGFzT3duUHJvcGVydHkoZSkgPyAoKHIgPT09IHZvaWQgMCB8fCBjW2VdLm92ZXJsb2FkVGFibGUgIT09IHZvaWQgMCAmJiBjW2VdLm92ZXJsb2FkVGFibGVbcl0gIT09IHZvaWQgMCkgJiYgQyhgQ2Fubm90IHJlZ2lzdGVyIHB1YmxpYyBuYW1lICcke2V9JyB0d2ljZWApLCBjZShjLCBlLCBlKSwgY1tlXS5vdmVybG9hZFRhYmxlLmhhc093blByb3BlcnR5KHIpICYmIEMoYENhbm5vdCByZWdpc3RlciBtdWx0aXBsZSBvdmVybG9hZHMgb2YgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMgKCR7cn0pIWApLCBjW2VdLm92ZXJsb2FkVGFibGVbcl0gPSB0KSA6IChjW2VdID0gdCwgY1tlXS5hcmdDb3VudCA9IHIpO1xuICB9LCBPciA9IDQ4LCB4ciA9IDU3LCBBciA9IChlKSA9PiB7XG4gICAgZSA9IGUucmVwbGFjZSgvW15hLXpBLVowLTlfXS9nLCBcIiRcIik7XG4gICAgdmFyIHQgPSBlLmNoYXJDb2RlQXQoMCk7XG4gICAgcmV0dXJuIHQgPj0gT3IgJiYgdCA8PSB4ciA/IGBfJHtlfWAgOiBlO1xuICB9O1xuICBmdW5jdGlvbiBTcihlLCB0LCByLCBuLCBhLCBpLCB1LCBzKSB7XG4gICAgdGhpcy5uYW1lID0gZSwgdGhpcy5jb25zdHJ1Y3RvciA9IHQsIHRoaXMuaW5zdGFuY2VQcm90b3R5cGUgPSByLCB0aGlzLnJhd0Rlc3RydWN0b3IgPSBuLCB0aGlzLmJhc2VDbGFzcyA9IGEsIHRoaXMuZ2V0QWN0dWFsVHlwZSA9IGksIHRoaXMudXBjYXN0ID0gdSwgdGhpcy5kb3duY2FzdCA9IHMsIHRoaXMucHVyZVZpcnR1YWxGdW5jdGlvbnMgPSBbXTtcbiAgfVxuICB2YXIgVnQgPSAoZSwgdCwgcikgPT4ge1xuICAgIGZvciAoOyB0ICE9PSByOyApXG4gICAgICB0LnVwY2FzdCB8fCBDKGBFeHBlY3RlZCBudWxsIG9yIGluc3RhbmNlIG9mICR7ci5uYW1lfSwgZ290IGFuIGluc3RhbmNlIG9mICR7dC5uYW1lfWApLCBlID0gdC51cGNhc3QoZSksIHQgPSB0LmJhc2VDbGFzcztcbiAgICByZXR1cm4gZTtcbiAgfTtcbiAgZnVuY3Rpb24gSXIoZSwgdCkge1xuICAgIGlmICh0ID09PSBudWxsKVxuICAgICAgcmV0dXJuIHRoaXMuaXNSZWZlcmVuY2UgJiYgQyhgbnVsbCBpcyBub3QgYSB2YWxpZCAke3RoaXMubmFtZX1gKSwgMDtcbiAgICB0LiQkIHx8IEMoYENhbm5vdCBwYXNzIFwiJHtlbWJpbmRSZXByKHQpfVwiIGFzIGEgJHt0aGlzLm5hbWV9YCksIHQuJCQucHRyIHx8IEMoYENhbm5vdCBwYXNzIGRlbGV0ZWQgb2JqZWN0IGFzIGEgcG9pbnRlciBvZiB0eXBlICR7dGhpcy5uYW1lfWApO1xuICAgIHZhciByID0gdC4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzcywgbiA9IFZ0KHQuJCQucHRyLCByLCB0aGlzLnJlZ2lzdGVyZWRDbGFzcyk7XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgZnVuY3Rpb24gRHIoZSwgdCkge1xuICAgIHZhciByO1xuICAgIGlmICh0ID09PSBudWxsKVxuICAgICAgcmV0dXJuIHRoaXMuaXNSZWZlcmVuY2UgJiYgQyhgbnVsbCBpcyBub3QgYSB2YWxpZCAke3RoaXMubmFtZX1gKSwgdGhpcy5pc1NtYXJ0UG9pbnRlciA/IChyID0gdGhpcy5yYXdDb25zdHJ1Y3RvcigpLCBlICE9PSBudWxsICYmIGUucHVzaCh0aGlzLnJhd0Rlc3RydWN0b3IsIHIpLCByKSA6IDA7XG4gICAgKCF0IHx8ICF0LiQkKSAmJiBDKGBDYW5ub3QgcGFzcyBcIiR7ZW1iaW5kUmVwcih0KX1cIiBhcyBhICR7dGhpcy5uYW1lfWApLCB0LiQkLnB0ciB8fCBDKGBDYW5ub3QgcGFzcyBkZWxldGVkIG9iamVjdCBhcyBhIHBvaW50ZXIgb2YgdHlwZSAke3RoaXMubmFtZX1gKSwgIXRoaXMuaXNDb25zdCAmJiB0LiQkLnB0clR5cGUuaXNDb25zdCAmJiBDKGBDYW5ub3QgY29udmVydCBhcmd1bWVudCBvZiB0eXBlICR7dC4kJC5zbWFydFB0clR5cGUgPyB0LiQkLnNtYXJ0UHRyVHlwZS5uYW1lIDogdC4kJC5wdHJUeXBlLm5hbWV9IHRvIHBhcmFtZXRlciB0eXBlICR7dGhpcy5uYW1lfWApO1xuICAgIHZhciBuID0gdC4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzcztcbiAgICBpZiAociA9IFZ0KHQuJCQucHRyLCBuLCB0aGlzLnJlZ2lzdGVyZWRDbGFzcyksIHRoaXMuaXNTbWFydFBvaW50ZXIpXG4gICAgICBzd2l0Y2ggKHQuJCQuc21hcnRQdHIgPT09IHZvaWQgMCAmJiBDKFwiUGFzc2luZyByYXcgcG9pbnRlciB0byBzbWFydCBwb2ludGVyIGlzIGlsbGVnYWxcIiksIHRoaXMuc2hhcmluZ1BvbGljeSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgdC4kJC5zbWFydFB0clR5cGUgPT09IHRoaXMgPyByID0gdC4kJC5zbWFydFB0ciA6IEMoYENhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgJHt0LiQkLnNtYXJ0UHRyVHlwZSA/IHQuJCQuc21hcnRQdHJUeXBlLm5hbWUgOiB0LiQkLnB0clR5cGUubmFtZX0gdG8gcGFyYW1ldGVyIHR5cGUgJHt0aGlzLm5hbWV9YCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByID0gdC4kJC5zbWFydFB0cjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGlmICh0LiQkLnNtYXJ0UHRyVHlwZSA9PT0gdGhpcylcbiAgICAgICAgICAgIHIgPSB0LiQkLnNtYXJ0UHRyO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGEgPSB0LmNsb25lKCk7XG4gICAgICAgICAgICByID0gdGhpcy5yYXdTaGFyZShyLCBHLnRvSGFuZGxlKCgpID0+IGEuZGVsZXRlKCkpKSwgZSAhPT0gbnVsbCAmJiBlLnB1c2godGhpcy5yYXdEZXN0cnVjdG9yLCByKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgQyhcIlVuc3VwcG9ydGluZyBzaGFyaW5nIHBvbGljeVwiKTtcbiAgICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICBmdW5jdGlvbiBNcihlLCB0KSB7XG4gICAgaWYgKHQgPT09IG51bGwpXG4gICAgICByZXR1cm4gdGhpcy5pc1JlZmVyZW5jZSAmJiBDKGBudWxsIGlzIG5vdCBhIHZhbGlkICR7dGhpcy5uYW1lfWApLCAwO1xuICAgIHQuJCQgfHwgQyhgQ2Fubm90IHBhc3MgXCIke2VtYmluZFJlcHIodCl9XCIgYXMgYSAke3RoaXMubmFtZX1gKSwgdC4kJC5wdHIgfHwgQyhgQ2Fubm90IHBhc3MgZGVsZXRlZCBvYmplY3QgYXMgYSBwb2ludGVyIG9mIHR5cGUgJHt0aGlzLm5hbWV9YCksIHQuJCQucHRyVHlwZS5pc0NvbnN0ICYmIEMoYENhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgJHt0LiQkLnB0clR5cGUubmFtZX0gdG8gcGFyYW1ldGVyIHR5cGUgJHt0aGlzLm5hbWV9YCk7XG4gICAgdmFyIHIgPSB0LiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzLCBuID0gVnQodC4kJC5wdHIsIHIsIHRoaXMucmVnaXN0ZXJlZENsYXNzKTtcbiAgICByZXR1cm4gbjtcbiAgfVxuICB2YXIgZmUgPSAoZSwgdCwgcikgPT4ge1xuICAgIGlmICh0ID09PSByKVxuICAgICAgcmV0dXJuIGU7XG4gICAgaWYgKHIuYmFzZUNsYXNzID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB2YXIgbiA9IGZlKGUsIHQsIHIuYmFzZUNsYXNzKTtcbiAgICByZXR1cm4gbiA9PT0gbnVsbCA/IG51bGwgOiByLmRvd25jYXN0KG4pO1xuICB9LCBGciA9IHt9LCBqciA9IChlLCB0KSA9PiB7XG4gICAgZm9yICh0ID09PSB2b2lkIDAgJiYgQyhcInB0ciBzaG91bGQgbm90IGJlIHVuZGVmaW5lZFwiKTsgZS5iYXNlQ2xhc3M7IClcbiAgICAgIHQgPSBlLnVwY2FzdCh0KSwgZSA9IGUuYmFzZUNsYXNzO1xuICAgIHJldHVybiB0O1xuICB9LCBSciA9IChlLCB0KSA9PiAodCA9IGpyKGUsIHQpLCBGclt0XSksIFB0ID0gKGUsIHQpID0+IHtcbiAgICAoIXQucHRyVHlwZSB8fCAhdC5wdHIpICYmIEN0KFwibWFrZUNsYXNzSGFuZGxlIHJlcXVpcmVzIHB0ciBhbmQgcHRyVHlwZVwiKTtcbiAgICB2YXIgciA9ICEhdC5zbWFydFB0clR5cGUsIG4gPSAhIXQuc21hcnRQdHI7XG4gICAgcmV0dXJuIHIgIT09IG4gJiYgQ3QoXCJCb3RoIHNtYXJ0UHRyVHlwZSBhbmQgc21hcnRQdHIgbXVzdCBiZSBzcGVjaWZpZWRcIiksIHQuY291bnQgPSB7XG4gICAgICB2YWx1ZTogMVxuICAgIH0sIGR0KE9iamVjdC5jcmVhdGUoZSwge1xuICAgICAgJCQ6IHtcbiAgICAgICAgdmFsdWU6IHQsXG4gICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgfVxuICAgIH0pKTtcbiAgfTtcbiAgZnVuY3Rpb24gTHIoZSkge1xuICAgIHZhciB0ID0gdGhpcy5nZXRQb2ludGVlKGUpO1xuICAgIGlmICghdClcbiAgICAgIHJldHVybiB0aGlzLmRlc3RydWN0b3IoZSksIG51bGw7XG4gICAgdmFyIHIgPSBScih0aGlzLnJlZ2lzdGVyZWRDbGFzcywgdCk7XG4gICAgaWYgKHIgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHIuJCQuY291bnQudmFsdWUgPT09IDApXG4gICAgICAgIHJldHVybiByLiQkLnB0ciA9IHQsIHIuJCQuc21hcnRQdHIgPSBlLCByLmNsb25lKCk7XG4gICAgICB2YXIgbiA9IHIuY2xvbmUoKTtcbiAgICAgIHJldHVybiB0aGlzLmRlc3RydWN0b3IoZSksIG47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1NtYXJ0UG9pbnRlciA/IFB0KHRoaXMucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlLCB7XG4gICAgICAgIHB0clR5cGU6IHRoaXMucG9pbnRlZVR5cGUsXG4gICAgICAgIHB0cjogdCxcbiAgICAgICAgc21hcnRQdHJUeXBlOiB0aGlzLFxuICAgICAgICBzbWFydFB0cjogZVxuICAgICAgfSkgOiBQdCh0aGlzLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSwge1xuICAgICAgICBwdHJUeXBlOiB0aGlzLFxuICAgICAgICBwdHI6IGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMucmVnaXN0ZXJlZENsYXNzLmdldEFjdHVhbFR5cGUodCksIHUgPSB1ZVtpXTtcbiAgICBpZiAoIXUpXG4gICAgICByZXR1cm4gYS5jYWxsKHRoaXMpO1xuICAgIHZhciBzO1xuICAgIHRoaXMuaXNDb25zdCA/IHMgPSB1LmNvbnN0UG9pbnRlclR5cGUgOiBzID0gdS5wb2ludGVyVHlwZTtcbiAgICB2YXIgbCA9IGZlKHQsIHRoaXMucmVnaXN0ZXJlZENsYXNzLCBzLnJlZ2lzdGVyZWRDbGFzcyk7XG4gICAgcmV0dXJuIGwgPT09IG51bGwgPyBhLmNhbGwodGhpcykgOiB0aGlzLmlzU21hcnRQb2ludGVyID8gUHQocy5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGUsIHtcbiAgICAgIHB0clR5cGU6IHMsXG4gICAgICBwdHI6IGwsXG4gICAgICBzbWFydFB0clR5cGU6IHRoaXMsXG4gICAgICBzbWFydFB0cjogZVxuICAgIH0pIDogUHQocy5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGUsIHtcbiAgICAgIHB0clR5cGU6IHMsXG4gICAgICBwdHI6IGxcbiAgICB9KTtcbiAgfVxuICB2YXIgQnIgPSAoKSA9PiB7XG4gICAgT2JqZWN0LmFzc2lnbihFdC5wcm90b3R5cGUsIHtcbiAgICAgIGdldFBvaW50ZWUoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdHZXRQb2ludGVlICYmIChlID0gdGhpcy5yYXdHZXRQb2ludGVlKGUpKSwgZTtcbiAgICAgIH0sXG4gICAgICBkZXN0cnVjdG9yKGUpIHtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgICh0ID0gdGhpcy5yYXdEZXN0cnVjdG9yKSA9PT0gbnVsbCB8fCB0ID09PSB2b2lkIDAgfHwgdC5jYWxsKHRoaXMsIGUpO1xuICAgICAgfSxcbiAgICAgIGFyZ1BhY2tBZHZhbmNlOiBOLFxuICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IGx0LFxuICAgICAgZnJvbVdpcmVUeXBlOiBMclxuICAgIH0pO1xuICB9O1xuICBmdW5jdGlvbiBFdChlLCB0LCByLCBuLCBhLCBpLCB1LCBzLCBsLCBkLCBoKSB7XG4gICAgdGhpcy5uYW1lID0gZSwgdGhpcy5yZWdpc3RlcmVkQ2xhc3MgPSB0LCB0aGlzLmlzUmVmZXJlbmNlID0gciwgdGhpcy5pc0NvbnN0ID0gbiwgdGhpcy5pc1NtYXJ0UG9pbnRlciA9IGEsIHRoaXMucG9pbnRlZVR5cGUgPSBpLCB0aGlzLnNoYXJpbmdQb2xpY3kgPSB1LCB0aGlzLnJhd0dldFBvaW50ZWUgPSBzLCB0aGlzLnJhd0NvbnN0cnVjdG9yID0gbCwgdGhpcy5yYXdTaGFyZSA9IGQsIHRoaXMucmF3RGVzdHJ1Y3RvciA9IGgsICFhICYmIHQuYmFzZUNsYXNzID09PSB2b2lkIDAgPyBuID8gKHRoaXMudG9XaXJlVHlwZSA9IElyLCB0aGlzLmRlc3RydWN0b3JGdW5jdGlvbiA9IG51bGwpIDogKHRoaXMudG9XaXJlVHlwZSA9IE1yLCB0aGlzLmRlc3RydWN0b3JGdW5jdGlvbiA9IG51bGwpIDogdGhpcy50b1dpcmVUeXBlID0gRHI7XG4gIH1cbiAgdmFyIGRlID0gKGUsIHQsIHIpID0+IHtcbiAgICBjLmhhc093blByb3BlcnR5KGUpIHx8IEN0KFwiUmVwbGFjaW5nIG5vbmV4aXN0ZW50IHB1YmxpYyBzeW1ib2xcIiksIGNbZV0ub3ZlcmxvYWRUYWJsZSAhPT0gdm9pZCAwICYmIHIgIT09IHZvaWQgMCA/IGNbZV0ub3ZlcmxvYWRUYWJsZVtyXSA9IHQgOiAoY1tlXSA9IHQsIGNbZV0uYXJnQ291bnQgPSByKTtcbiAgfSwgaGUgPSBbXSwgcGUsIGcgPSAoZSkgPT4ge1xuICAgIHZhciB0ID0gaGVbZV07XG4gICAgcmV0dXJuIHQgfHwgKGhlW2VdID0gdCA9IHBlLmdldChlKSksIHQ7XG4gIH0sIFdyID0gZnVuY3Rpb24oZSwgdCkge1xuICAgIGxldCByID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiBbXTtcbiAgICBpZiAoZS5pbmNsdWRlcyhcImpcIikpXG4gICAgICByZXR1cm4gZHluQ2FsbExlZ2FjeShlLCB0LCByKTtcbiAgICB2YXIgbiA9IGcodCksIGEgPSBuKC4uLnIpO1xuICAgIHJldHVybiBhO1xuICB9LCBVciA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBsZXQgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogITE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGEgPSBuZXcgQXJyYXkobiksIGkgPSAwOyBpIDwgbjsgaSsrKVxuICAgICAgICBhW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgcmV0dXJuIFdyKGUsIHQsIGEsIHIpO1xuICAgIH07XG4gIH0sIFUgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgZSA9IGooZSk7XG4gICAgZnVuY3Rpb24gcigpIHtcbiAgICAgIGlmIChlLmluY2x1ZGVzKFwialwiKSlcbiAgICAgICAgcmV0dXJuIFVyKGUsIHQpO1xuICAgICAgdmFyIGEgPSBnKHQpO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIHZhciBuID0gcigpO1xuICAgIHJldHVybiB0eXBlb2YgbiAhPSBcImZ1bmN0aW9uXCIgJiYgQyhgdW5rbm93biBmdW5jdGlvbiBwb2ludGVyIHdpdGggc2lnbmF0dXJlICR7ZX06ICR7dH1gKSwgbjtcbiAgfTtcbiAgY2xhc3MgVnIgZXh0ZW5kcyBFcnJvciB7XG4gIH1cbiAgdmFyIHZlID0gKGUpID0+IHtcbiAgICB2YXIgdCA9IE5uKGUpLCByID0gaih0KTtcbiAgICByZXR1cm4gZXQodCksIHI7XG4gIH0sIF90ID0gKGUsIHQpID0+IHtcbiAgICB2YXIgciA9IFtdLCBuID0ge307XG4gICAgZnVuY3Rpb24gYShpKSB7XG4gICAgICBpZiAoIW5baV0gJiYgIUtbaV0pIHtcbiAgICAgICAgaWYgKGJ0W2ldKSB7XG4gICAgICAgICAgYnRbaV0uZm9yRWFjaChhKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgci5wdXNoKGkpLCBuW2ldID0gITA7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IHQuZm9yRWFjaChhKSwgbmV3IFZyKGAke2V9OiBgICsgci5tYXAodmUpLmpvaW4oW1wiLCBcIl0pKTtcbiAgfSwga3IgPSAoZSwgdCwgciwgbiwgYSwgaSwgdSwgcywgbCwgZCwgaCwgcCwgdykgPT4ge1xuICAgIGggPSBqKGgpLCBpID0gVShhLCBpKSwgcyAmJiAocyA9IFUodSwgcykpLCBkICYmIChkID0gVShsLCBkKSksIHcgPSBVKHAsIHcpO1xuICAgIHZhciBiID0gQXIoaCk7XG4gICAgbGUoYiwgZnVuY3Rpb24oKSB7XG4gICAgICBfdChgQ2Fubm90IGNvbnN0cnVjdCAke2h9IGR1ZSB0byB1bmJvdW5kIHR5cGVzYCwgW25dKTtcbiAgICB9KSwgdHQoW2UsIHQsIHJdLCBuID8gW25dIDogW10sIChfKSA9PiB7XG4gICAgICBfID0gX1swXTtcbiAgICAgIHZhciBTLCBBO1xuICAgICAgbiA/IChTID0gXy5yZWdpc3RlcmVkQ2xhc3MsIEEgPSBTLmluc3RhbmNlUHJvdG90eXBlKSA6IEEgPSBUdC5wcm90b3R5cGU7XG4gICAgICB2YXIgSSA9IFV0KGgsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpICE9PSBYKVxuICAgICAgICAgIHRocm93IG5ldyBmdChgVXNlICduZXcnIHRvIGNvbnN0cnVjdCAke2h9YCk7XG4gICAgICAgIGlmIChMLmNvbnN0cnVjdG9yX2JvZHkgPT09IHZvaWQgMClcbiAgICAgICAgICB0aHJvdyBuZXcgZnQoYCR7aH0gaGFzIG5vIGFjY2Vzc2libGUgY29uc3RydWN0b3JgKTtcbiAgICAgICAgZm9yICh2YXIgT2UgPSBhcmd1bWVudHMubGVuZ3RoLCB4dCA9IG5ldyBBcnJheShPZSksIEF0ID0gMDsgQXQgPCBPZTsgQXQrKylcbiAgICAgICAgICB4dFtBdF0gPSBhcmd1bWVudHNbQXRdO1xuICAgICAgICB2YXIgeGUgPSBMLmNvbnN0cnVjdG9yX2JvZHlbeHQubGVuZ3RoXTtcbiAgICAgICAgaWYgKHhlID09PSB2b2lkIDApXG4gICAgICAgICAgdGhyb3cgbmV3IGZ0KGBUcmllZCB0byBpbnZva2UgY3RvciBvZiAke2h9IHdpdGggaW52YWxpZCBudW1iZXIgb2YgcGFyYW1ldGVycyAoJHt4dC5sZW5ndGh9KSAtIGV4cGVjdGVkICgke09iamVjdC5rZXlzKEwuY29uc3RydWN0b3JfYm9keSkudG9TdHJpbmcoKX0pIHBhcmFtZXRlcnMgaW5zdGVhZCFgKTtcbiAgICAgICAgcmV0dXJuIHhlLmFwcGx5KHRoaXMsIHh0KTtcbiAgICAgIH0pLCBYID0gT2JqZWN0LmNyZWF0ZShBLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IElcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBJLnByb3RvdHlwZSA9IFg7XG4gICAgICB2YXIgTCA9IG5ldyBTcihoLCBJLCBYLCB3LCBTLCBpLCBzLCBkKTtcbiAgICAgIGlmIChMLmJhc2VDbGFzcykge1xuICAgICAgICB2YXIgVywgT3Q7XG4gICAgICAgIChPdCA9IChXID0gTC5iYXNlQ2xhc3MpLl9fZGVyaXZlZENsYXNzZXMpICE9PSBudWxsICYmIE90ICE9PSB2b2lkIDAgfHwgKFcuX19kZXJpdmVkQ2xhc3NlcyA9IFtdKSwgTC5iYXNlQ2xhc3MuX19kZXJpdmVkQ2xhc3Nlcy5wdXNoKEwpO1xuICAgICAgfVxuICAgICAgdmFyIFJhID0gbmV3IEV0KGgsIEwsICEwLCAhMSwgITEpLCBFZSA9IG5ldyBFdChoICsgXCIqXCIsIEwsICExLCAhMSwgITEpLCBfZSA9IG5ldyBFdChoICsgXCIgY29uc3QqXCIsIEwsICExLCAhMCwgITEpO1xuICAgICAgcmV0dXJuIHVlW2VdID0ge1xuICAgICAgICBwb2ludGVyVHlwZTogRWUsXG4gICAgICAgIGNvbnN0UG9pbnRlclR5cGU6IF9lXG4gICAgICB9LCBkZShiLCBJKSwgW1JhLCBFZSwgX2VdO1xuICAgIH0pO1xuICB9LCBrdCA9IChlLCB0KSA9PiB7XG4gICAgZm9yICh2YXIgciA9IFtdLCBuID0gMDsgbiA8IGU7IG4rKylcbiAgICAgIHIucHVzaChQW3QgKyBuICogNCA+PiAyXSk7XG4gICAgcmV0dXJuIHI7XG4gIH07XG4gIGZ1bmN0aW9uIEhyKGUpIHtcbiAgICBmb3IgKHZhciB0ID0gMTsgdCA8IGUubGVuZ3RoOyArK3QpXG4gICAgICBpZiAoZVt0XSAhPT0gbnVsbCAmJiBlW3RdLmRlc3RydWN0b3JGdW5jdGlvbiA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGZ1bmN0aW9uIEh0KGUsIHQsIHIsIG4sIGEsIGkpIHtcbiAgICB2YXIgdSA9IHQubGVuZ3RoO1xuICAgIHUgPCAyICYmIEMoXCJhcmdUeXBlcyBhcnJheSBzaXplIG1pc21hdGNoISBNdXN0IGF0IGxlYXN0IGdldCByZXR1cm4gdmFsdWUgYW5kICd0aGlzJyB0eXBlcyFcIik7XG4gICAgdmFyIHMgPSB0WzFdICE9PSBudWxsICYmIHIgIT09IG51bGwsIGwgPSBIcih0KSwgZCA9IHRbMF0ubmFtZSAhPT0gXCJ2b2lkXCIsIGggPSB1IC0gMiwgcCA9IG5ldyBBcnJheShoKSwgdyA9IFtdLCBiID0gW10sIF8gPSBmdW5jdGlvbigpIHtcbiAgICAgIGIubGVuZ3RoID0gMDtcbiAgICAgIHZhciBTO1xuICAgICAgdy5sZW5ndGggPSBzID8gMiA6IDEsIHdbMF0gPSBhLCBzICYmIChTID0gdFsxXS50b1dpcmVUeXBlKGIsIHRoaXMpLCB3WzFdID0gUyk7XG4gICAgICBmb3IgKHZhciBBID0gMDsgQSA8IGg7ICsrQSlcbiAgICAgICAgcFtBXSA9IHRbQSArIDJdLnRvV2lyZVR5cGUoYiwgQSA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBBID8gdm9pZCAwIDogYXJndW1lbnRzW0FdKSwgdy5wdXNoKHBbQV0pO1xuICAgICAgdmFyIEkgPSBuKC4uLncpO1xuICAgICAgZnVuY3Rpb24gWChMKSB7XG4gICAgICAgIGlmIChsKVxuICAgICAgICAgIEx0KGIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yICh2YXIgVyA9IHMgPyAxIDogMjsgVyA8IHQubGVuZ3RoOyBXKyspIHtcbiAgICAgICAgICAgIHZhciBPdCA9IFcgPT09IDEgPyBTIDogcFtXIC0gMl07XG4gICAgICAgICAgICB0W1ddLmRlc3RydWN0b3JGdW5jdGlvbiAhPT0gbnVsbCAmJiB0W1ddLmRlc3RydWN0b3JGdW5jdGlvbihPdCk7XG4gICAgICAgICAgfVxuICAgICAgICBpZiAoZClcbiAgICAgICAgICByZXR1cm4gdFswXS5mcm9tV2lyZVR5cGUoTCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gWChJKTtcbiAgICB9O1xuICAgIHJldHVybiBVdChlLCBfKTtcbiAgfVxuICB2YXIgTnIgPSAoZSwgdCwgciwgbiwgYSwgaSkgPT4ge1xuICAgIHZhciB1ID0ga3QodCwgcik7XG4gICAgYSA9IFUobiwgYSksIHR0KFtdLCBbZV0sIChzKSA9PiB7XG4gICAgICBzID0gc1swXTtcbiAgICAgIHZhciBsID0gYGNvbnN0cnVjdG9yICR7cy5uYW1lfWA7XG4gICAgICBpZiAocy5yZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3JfYm9keSA9PT0gdm9pZCAwICYmIChzLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5ID0gW10pLCBzLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5W3QgLSAxXSAhPT0gdm9pZCAwKVxuICAgICAgICB0aHJvdyBuZXcgZnQoYENhbm5vdCByZWdpc3RlciBtdWx0aXBsZSBjb25zdHJ1Y3RvcnMgd2l0aCBpZGVudGljYWwgbnVtYmVyIG9mIHBhcmFtZXRlcnMgKCR7dCAtIDF9KSBmb3IgY2xhc3MgJyR7cy5uYW1lfSchIE92ZXJsb2FkIHJlc29sdXRpb24gaXMgY3VycmVudGx5IG9ubHkgcGVyZm9ybWVkIHVzaW5nIHRoZSBwYXJhbWV0ZXIgY291bnQsIG5vdCBhY3R1YWwgdHlwZSBpbmZvIWApO1xuICAgICAgcmV0dXJuIHMucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHlbdCAtIDFdID0gKCkgPT4ge1xuICAgICAgICBfdChgQ2Fubm90IGNvbnN0cnVjdCAke3MubmFtZX0gZHVlIHRvIHVuYm91bmQgdHlwZXNgLCB1KTtcbiAgICAgIH0sIHR0KFtdLCB1LCAoZCkgPT4gKGQuc3BsaWNlKDEsIDAsIG51bGwpLCBzLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5W3QgLSAxXSA9IEh0KGwsIGQsIG51bGwsIGEsIGkpLCBbXSkpLCBbXTtcbiAgICB9KTtcbiAgfSwgeWUgPSAoZSkgPT4ge1xuICAgIGUgPSBlLnRyaW0oKTtcbiAgICBjb25zdCB0ID0gZS5pbmRleE9mKFwiKFwiKTtcbiAgICByZXR1cm4gdCA9PT0gLTEgPyBlIDogZS5zbGljZSgwLCB0KTtcbiAgfSwgenIgPSAoZSwgdCwgciwgbiwgYSwgaSwgdSwgcywgbCwgZCkgPT4ge1xuICAgIHZhciBoID0ga3Qociwgbik7XG4gICAgdCA9IGoodCksIHQgPSB5ZSh0KSwgaSA9IFUoYSwgaSksIHR0KFtdLCBbZV0sIChwKSA9PiB7XG4gICAgICBwID0gcFswXTtcbiAgICAgIHZhciB3ID0gYCR7cC5uYW1lfS4ke3R9YDtcbiAgICAgIHQuc3RhcnRzV2l0aChcIkBAXCIpICYmICh0ID0gU3ltYm9sW3Quc3Vic3RyaW5nKDIpXSksIHMgJiYgcC5yZWdpc3RlcmVkQ2xhc3MucHVyZVZpcnR1YWxGdW5jdGlvbnMucHVzaCh0KTtcbiAgICAgIGZ1bmN0aW9uIGIoKSB7XG4gICAgICAgIF90KGBDYW5ub3QgY2FsbCAke3d9IGR1ZSB0byB1bmJvdW5kIHR5cGVzYCwgaCk7XG4gICAgICB9XG4gICAgICB2YXIgXyA9IHAucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlLCBTID0gX1t0XTtcbiAgICAgIHJldHVybiBTID09PSB2b2lkIDAgfHwgUy5vdmVybG9hZFRhYmxlID09PSB2b2lkIDAgJiYgUy5jbGFzc05hbWUgIT09IHAubmFtZSAmJiBTLmFyZ0NvdW50ID09PSByIC0gMiA/IChiLmFyZ0NvdW50ID0gciAtIDIsIGIuY2xhc3NOYW1lID0gcC5uYW1lLCBfW3RdID0gYikgOiAoY2UoXywgdCwgdyksIF9bdF0ub3ZlcmxvYWRUYWJsZVtyIC0gMl0gPSBiKSwgdHQoW10sIGgsIChBKSA9PiB7XG4gICAgICAgIHZhciBJID0gSHQodywgQSwgcCwgaSwgdSk7XG4gICAgICAgIHJldHVybiBfW3RdLm92ZXJsb2FkVGFibGUgPT09IHZvaWQgMCA/IChJLmFyZ0NvdW50ID0gciAtIDIsIF9bdF0gPSBJKSA6IF9bdF0ub3ZlcmxvYWRUYWJsZVtyIC0gMl0gPSBJLCBbXTtcbiAgICAgIH0pLCBbXTtcbiAgICB9KTtcbiAgfSwgTnQgPSBbXSwgeiA9IFtdLCB6dCA9IChlKSA9PiB7XG4gICAgZSA+IDkgJiYgLS16W2UgKyAxXSA9PT0gMCAmJiAoeltlXSA9IHZvaWQgMCwgTnQucHVzaChlKSk7XG4gIH0sIEdyID0gKCkgPT4gei5sZW5ndGggLyAyIC0gNSAtIE50Lmxlbmd0aCwgWHIgPSAoKSA9PiB7XG4gICAgei5wdXNoKDAsIDEsIHZvaWQgMCwgMSwgbnVsbCwgMSwgITAsIDEsICExLCAxKSwgYy5jb3VudF9lbXZhbF9oYW5kbGVzID0gR3I7XG4gIH0sIEcgPSB7XG4gICAgdG9WYWx1ZTogKGUpID0+IChlIHx8IEMoYENhbm5vdCB1c2UgZGVsZXRlZCB2YWwuIGhhbmRsZSA9ICR7ZX1gKSwgeltlXSksXG4gICAgdG9IYW5kbGU6IChlKSA9PiB7XG4gICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgY2FzZSB2b2lkIDA6XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgY2FzZSAhMDpcbiAgICAgICAgICByZXR1cm4gNjtcbiAgICAgICAgY2FzZSAhMTpcbiAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IHQgPSBOdC5wb3AoKSB8fCB6Lmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gelt0XSA9IGUsIHpbdCArIDFdID0gMSwgdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgbWUgPSB7XG4gICAgbmFtZTogXCJlbXNjcmlwdGVuOjp2YWxcIixcbiAgICBmcm9tV2lyZVR5cGU6IChlKSA9PiB7XG4gICAgICB2YXIgdCA9IEcudG9WYWx1ZShlKTtcbiAgICAgIHJldHVybiB6dChlKSwgdDtcbiAgICB9LFxuICAgIHRvV2lyZVR5cGU6IChlLCB0KSA9PiBHLnRvSGFuZGxlKHQpLFxuICAgIGFyZ1BhY2tBZHZhbmNlOiBOLFxuICAgIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiBsdCxcbiAgICBkZXN0cnVjdG9yRnVuY3Rpb246IG51bGxcbiAgfSwgcXIgPSAoZSkgPT4gVihlLCBtZSksIFlyID0gKGUsIHQpID0+IHtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoS3RbciA+PiAyXSk7XG4gICAgICAgIH07XG4gICAgICBjYXNlIDg6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKHRlW3IgPj4gM10pO1xuICAgICAgICB9O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBmbG9hdCB3aWR0aCAoJHt0fSk6ICR7ZX1gKTtcbiAgICB9XG4gIH0sIFpyID0gKGUsIHQsIHIpID0+IHtcbiAgICB0ID0gaih0KSwgVihlLCB7XG4gICAgICBuYW1lOiB0LFxuICAgICAgZnJvbVdpcmVUeXBlOiAobikgPT4gbixcbiAgICAgIHRvV2lyZVR5cGU6IChuLCBhKSA9PiBhLFxuICAgICAgYXJnUGFja0FkdmFuY2U6IE4sXG4gICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogWXIodCwgciksXG4gICAgICBkZXN0cnVjdG9yRnVuY3Rpb246IG51bGxcbiAgICB9KTtcbiAgfSwgUXIgPSAoZSwgdCwgciwgbiwgYSwgaSwgdSwgcykgPT4ge1xuICAgIHZhciBsID0ga3QodCwgcik7XG4gICAgZSA9IGooZSksIGUgPSB5ZShlKSwgYSA9IFUobiwgYSksIGxlKGUsIGZ1bmN0aW9uKCkge1xuICAgICAgX3QoYENhbm5vdCBjYWxsICR7ZX0gZHVlIHRvIHVuYm91bmQgdHlwZXNgLCBsKTtcbiAgICB9LCB0IC0gMSksIHR0KFtdLCBsLCAoZCkgPT4ge1xuICAgICAgdmFyIGggPSBbZFswXSwgbnVsbF0uY29uY2F0KGQuc2xpY2UoMSkpO1xuICAgICAgcmV0dXJuIGRlKGUsIEh0KGUsIGgsIG51bGwsIGEsIGkpLCB0IC0gMSksIFtdO1xuICAgIH0pO1xuICB9LCBKciA9IChlLCB0LCByKSA9PiB7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiByID8gKG4pID0+IFFbbl0gOiAobikgPT4gQltuXTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIHIgPyAobikgPT4gdXRbbiA+PiAxXSA6IChuKSA9PiB2dFtuID4+IDFdO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gciA/IChuKSA9PiBhdFtuID4+IDJdIDogKG4pID0+IFBbbiA+PiAyXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgaW50ZWdlciB3aWR0aCAoJHt0fSk6ICR7ZX1gKTtcbiAgICB9XG4gIH0sIEtyID0gKGUsIHQsIHIsIG4sIGEpID0+IHtcbiAgICB0ID0gaih0KTtcbiAgICB2YXIgaSA9IChoKSA9PiBoO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICB2YXIgdSA9IDMyIC0gOCAqIHI7XG4gICAgICBpID0gKGgpID0+IGggPDwgdSA+Pj4gdTtcbiAgICB9XG4gICAgdmFyIHMgPSB0LmluY2x1ZGVzKFwidW5zaWduZWRcIiksIGwgPSAoaCwgcCkgPT4ge1xuICAgIH0sIGQ7XG4gICAgcyA/IGQgPSBmdW5jdGlvbihoLCBwKSB7XG4gICAgICByZXR1cm4gbChwLCB0aGlzLm5hbWUpLCBwID4+PiAwO1xuICAgIH0gOiBkID0gZnVuY3Rpb24oaCwgcCkge1xuICAgICAgcmV0dXJuIGwocCwgdGhpcy5uYW1lKSwgcDtcbiAgICB9LCBWKGUsIHtcbiAgICAgIG5hbWU6IHQsXG4gICAgICBmcm9tV2lyZVR5cGU6IGksXG4gICAgICB0b1dpcmVUeXBlOiBkLFxuICAgICAgYXJnUGFja0FkdmFuY2U6IE4sXG4gICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogSnIodCwgciwgbiAhPT0gMCksXG4gICAgICBkZXN0cnVjdG9yRnVuY3Rpb246IG51bGxcbiAgICB9KTtcbiAgfSwgdG4gPSAoZSwgdCwgcikgPT4ge1xuICAgIHZhciBuID0gW0ludDhBcnJheSwgVWludDhBcnJheSwgSW50MTZBcnJheSwgVWludDE2QXJyYXksIEludDMyQXJyYXksIFVpbnQzMkFycmF5LCBGbG9hdDMyQXJyYXksIEZsb2F0NjRBcnJheV0sIGEgPSBuW3RdO1xuICAgIGZ1bmN0aW9uIGkodSkge1xuICAgICAgdmFyIHMgPSBQW3UgPj4gMl0sIGwgPSBQW3UgKyA0ID4+IDJdO1xuICAgICAgcmV0dXJuIG5ldyBhKFEuYnVmZmVyLCBsLCBzKTtcbiAgICB9XG4gICAgciA9IGoociksIFYoZSwge1xuICAgICAgbmFtZTogcixcbiAgICAgIGZyb21XaXJlVHlwZTogaSxcbiAgICAgIGFyZ1BhY2tBZHZhbmNlOiBOLFxuICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IGlcbiAgICB9LCB7XG4gICAgICBpZ25vcmVEdXBsaWNhdGVSZWdpc3RyYXRpb25zOiAhMFxuICAgIH0pO1xuICB9LCBlbiA9IE9iamVjdC5hc3NpZ24oe1xuICAgIG9wdGlvbmFsOiAhMFxuICB9LCBtZSksIHJuID0gKGUsIHQpID0+IHtcbiAgICBWKGUsIGVuKTtcbiAgfSwgbm4gPSAoZSwgdCwgciwgbikgPT4ge1xuICAgIGlmICghKG4gPiAwKSkgcmV0dXJuIDA7XG4gICAgZm9yICh2YXIgYSA9IHIsIGkgPSByICsgbiAtIDEsIHUgPSAwOyB1IDwgZS5sZW5ndGg7ICsrdSkge1xuICAgICAgdmFyIHMgPSBlLmNoYXJDb2RlQXQodSk7XG4gICAgICBpZiAocyA+PSA1NTI5NiAmJiBzIDw9IDU3MzQzKSB7XG4gICAgICAgIHZhciBsID0gZS5jaGFyQ29kZUF0KCsrdSk7XG4gICAgICAgIHMgPSA2NTUzNiArICgocyAmIDEwMjMpIDw8IDEwKSB8IGwgJiAxMDIzO1xuICAgICAgfVxuICAgICAgaWYgKHMgPD0gMTI3KSB7XG4gICAgICAgIGlmIChyID49IGkpIGJyZWFrO1xuICAgICAgICB0W3IrK10gPSBzO1xuICAgICAgfSBlbHNlIGlmIChzIDw9IDIwNDcpIHtcbiAgICAgICAgaWYgKHIgKyAxID49IGkpIGJyZWFrO1xuICAgICAgICB0W3IrK10gPSAxOTIgfCBzID4+IDYsIHRbcisrXSA9IDEyOCB8IHMgJiA2MztcbiAgICAgIH0gZWxzZSBpZiAocyA8PSA2NTUzNSkge1xuICAgICAgICBpZiAociArIDIgPj0gaSkgYnJlYWs7XG4gICAgICAgIHRbcisrXSA9IDIyNCB8IHMgPj4gMTIsIHRbcisrXSA9IDEyOCB8IHMgPj4gNiAmIDYzLCB0W3IrK10gPSAxMjggfCBzICYgNjM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAociArIDMgPj0gaSkgYnJlYWs7XG4gICAgICAgIHRbcisrXSA9IDI0MCB8IHMgPj4gMTgsIHRbcisrXSA9IDEyOCB8IHMgPj4gMTIgJiA2MywgdFtyKytdID0gMTI4IHwgcyA+PiA2ICYgNjMsIHRbcisrXSA9IDEyOCB8IHMgJiA2MztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRbcl0gPSAwLCByIC0gYTtcbiAgfSwgaXQgPSAoZSwgdCwgcikgPT4gbm4oZSwgQiwgdCwgciksIGdlID0gKGUpID0+IHtcbiAgICBmb3IgKHZhciB0ID0gMCwgciA9IDA7IHIgPCBlLmxlbmd0aDsgKytyKSB7XG4gICAgICB2YXIgbiA9IGUuY2hhckNvZGVBdChyKTtcbiAgICAgIG4gPD0gMTI3ID8gdCsrIDogbiA8PSAyMDQ3ID8gdCArPSAyIDogbiA+PSA1NTI5NiAmJiBuIDw9IDU3MzQzID8gKHQgKz0gNCwgKytyKSA6IHQgKz0gMztcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH0sIHdlID0gdHlwZW9mIFRleHREZWNvZGVyIDwgXCJ1XCIgPyBuZXcgVGV4dERlY29kZXIoKSA6IHZvaWQgMCwgJGUgPSBmdW5jdGlvbihlKSB7XG4gICAgbGV0IHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IDAsIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IE5hTjtcbiAgICBmb3IgKHZhciBuID0gdCArIHIsIGEgPSB0OyBlW2FdICYmICEoYSA+PSBuKTsgKSArK2E7XG4gICAgaWYgKGEgLSB0ID4gMTYgJiYgZS5idWZmZXIgJiYgd2UpXG4gICAgICByZXR1cm4gd2UuZGVjb2RlKGUuc3ViYXJyYXkodCwgYSkpO1xuICAgIGZvciAodmFyIGkgPSBcIlwiOyB0IDwgYTsgKSB7XG4gICAgICB2YXIgdSA9IGVbdCsrXTtcbiAgICAgIGlmICghKHUgJiAxMjgpKSB7XG4gICAgICAgIGkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgcyA9IGVbdCsrXSAmIDYzO1xuICAgICAgaWYgKCh1ICYgMjI0KSA9PSAxOTIpIHtcbiAgICAgICAgaSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCh1ICYgMzEpIDw8IDYgfCBzKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgbCA9IGVbdCsrXSAmIDYzO1xuICAgICAgaWYgKCh1ICYgMjQwKSA9PSAyMjQgPyB1ID0gKHUgJiAxNSkgPDwgMTIgfCBzIDw8IDYgfCBsIDogdSA9ICh1ICYgNykgPDwgMTggfCBzIDw8IDEyIHwgbCA8PCA2IHwgZVt0KytdICYgNjMsIHUgPCA2NTUzNilcbiAgICAgICAgaSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHUpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBkID0gdSAtIDY1NTM2O1xuICAgICAgICBpICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYgfCBkID4+IDEwLCA1NjMyMCB8IGQgJiAxMDIzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH0sIGFuID0gKGUsIHQpID0+IGUgPyAkZShCLCBlLCB0KSA6IFwiXCIsIG9uID0gKGUsIHQpID0+IHtcbiAgICB0ID0gaih0KSwgVihlLCB7XG4gICAgICBuYW1lOiB0LFxuICAgICAgZnJvbVdpcmVUeXBlKHIpIHtcbiAgICAgICAgZm9yICh2YXIgbiA9IFBbciA+PiAyXSwgYSA9IHIgKyA0LCBpLCBzLCB1ID0gYSwgcyA9IDA7IHMgPD0gbjsgKytzKSB7XG4gICAgICAgICAgdmFyIGwgPSBhICsgcztcbiAgICAgICAgICBpZiAocyA9PSBuIHx8IEJbbF0gPT0gMCkge1xuICAgICAgICAgICAgdmFyIGQgPSBsIC0gdSwgaCA9IGFuKHUsIGQpO1xuICAgICAgICAgICAgaSA9PT0gdm9pZCAwID8gaSA9IGggOiAoaSArPSBcIlxcMFwiLCBpICs9IGgpLCB1ID0gbCArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldChyKSwgaTtcbiAgICAgIH0sXG4gICAgICB0b1dpcmVUeXBlKHIsIG4pIHtcbiAgICAgICAgbiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyICYmIChuID0gbmV3IFVpbnQ4QXJyYXkobikpO1xuICAgICAgICB2YXIgYSwgaSA9IHR5cGVvZiBuID09IFwic3RyaW5nXCI7XG4gICAgICAgIGkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KG4pICYmIG4uQllURVNfUEVSX0VMRU1FTlQgPT0gMSB8fCBDKFwiQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBzdGQ6OnN0cmluZ1wiKSwgaSA/IGEgPSBnZShuKSA6IGEgPSBuLmxlbmd0aDtcbiAgICAgICAgdmFyIHUgPSBQZSg0ICsgYSArIDEpLCBzID0gdSArIDQ7XG4gICAgICAgIHJldHVybiBQW3UgPj4gMl0gPSBhLCBpID8gaXQobiwgcywgYSArIDEpIDogQi5zZXQobiwgcyksIHIgIT09IG51bGwgJiYgci5wdXNoKGV0LCB1KSwgdTtcbiAgICAgIH0sXG4gICAgICBhcmdQYWNrQWR2YW5jZTogTixcbiAgICAgIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiBsdCxcbiAgICAgIGRlc3RydWN0b3JGdW5jdGlvbihyKSB7XG4gICAgICAgIGV0KHIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBiZSA9IHR5cGVvZiBUZXh0RGVjb2RlciA8IFwidVwiID8gbmV3IFRleHREZWNvZGVyKFwidXRmLTE2bGVcIikgOiB2b2lkIDAsIHNuID0gKGUsIHQpID0+IHtcbiAgICBmb3IgKHZhciByID0gZSwgbiA9IHIgPj4gMSwgYSA9IG4gKyB0IC8gMjsgIShuID49IGEpICYmIHZ0W25dOyApICsrbjtcbiAgICBpZiAociA9IG4gPDwgMSwgciAtIGUgPiAzMiAmJiBiZSkgcmV0dXJuIGJlLmRlY29kZShCLnN1YmFycmF5KGUsIHIpKTtcbiAgICBmb3IgKHZhciBpID0gXCJcIiwgdSA9IDA7ICEodSA+PSB0IC8gMik7ICsrdSkge1xuICAgICAgdmFyIHMgPSB1dFtlICsgdSAqIDIgPj4gMV07XG4gICAgICBpZiAocyA9PSAwKSBicmVhaztcbiAgICAgIGkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShzKTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH0sIHVuID0gKGUsIHQsIHIpID0+IHtcbiAgICBpZiAociAhPSBudWxsIHx8IChyID0gMjE0NzQ4MzY0NyksIHIgPCAyKSByZXR1cm4gMDtcbiAgICByIC09IDI7XG4gICAgZm9yICh2YXIgbiA9IHQsIGEgPSByIDwgZS5sZW5ndGggKiAyID8gciAvIDIgOiBlLmxlbmd0aCwgaSA9IDA7IGkgPCBhOyArK2kpIHtcbiAgICAgIHZhciB1ID0gZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgdXRbdCA+PiAxXSA9IHUsIHQgKz0gMjtcbiAgICB9XG4gICAgcmV0dXJuIHV0W3QgPj4gMV0gPSAwLCB0IC0gbjtcbiAgfSwgY24gPSAoZSkgPT4gZS5sZW5ndGggKiAyLCBsbiA9IChlLCB0KSA9PiB7XG4gICAgZm9yICh2YXIgciA9IDAsIG4gPSBcIlwiOyAhKHIgPj0gdCAvIDQpOyApIHtcbiAgICAgIHZhciBhID0gYXRbZSArIHIgKiA0ID4+IDJdO1xuICAgICAgaWYgKGEgPT0gMCkgYnJlYWs7XG4gICAgICBpZiAoKytyLCBhID49IDY1NTM2KSB7XG4gICAgICAgIHZhciBpID0gYSAtIDY1NTM2O1xuICAgICAgICBuICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYgfCBpID4+IDEwLCA1NjMyMCB8IGkgJiAxMDIzKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBuICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9LCBmbiA9IChlLCB0LCByKSA9PiB7XG4gICAgaWYgKHIgIT0gbnVsbCB8fCAociA9IDIxNDc0ODM2NDcpLCByIDwgNCkgcmV0dXJuIDA7XG4gICAgZm9yICh2YXIgbiA9IHQsIGEgPSBuICsgciAtIDQsIGkgPSAwOyBpIDwgZS5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHUgPSBlLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAodSA+PSA1NTI5NiAmJiB1IDw9IDU3MzQzKSB7XG4gICAgICAgIHZhciBzID0gZS5jaGFyQ29kZUF0KCsraSk7XG4gICAgICAgIHUgPSA2NTUzNiArICgodSAmIDEwMjMpIDw8IDEwKSB8IHMgJiAxMDIzO1xuICAgICAgfVxuICAgICAgaWYgKGF0W3QgPj4gMl0gPSB1LCB0ICs9IDQsIHQgKyA0ID4gYSkgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBhdFt0ID4+IDJdID0gMCwgdCAtIG47XG4gIH0sIGRuID0gKGUpID0+IHtcbiAgICBmb3IgKHZhciB0ID0gMCwgciA9IDA7IHIgPCBlLmxlbmd0aDsgKytyKSB7XG4gICAgICB2YXIgbiA9IGUuY2hhckNvZGVBdChyKTtcbiAgICAgIG4gPj0gNTUyOTYgJiYgbiA8PSA1NzM0MyAmJiArK3IsIHQgKz0gNDtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH0sIGhuID0gKGUsIHQsIHIpID0+IHtcbiAgICByID0gaihyKTtcbiAgICB2YXIgbiwgYSwgaSwgdTtcbiAgICB0ID09PSAyID8gKG4gPSBzbiwgYSA9IHVuLCB1ID0gY24sIGkgPSAocykgPT4gdnRbcyA+PiAxXSkgOiB0ID09PSA0ICYmIChuID0gbG4sIGEgPSBmbiwgdSA9IGRuLCBpID0gKHMpID0+IFBbcyA+PiAyXSksIFYoZSwge1xuICAgICAgbmFtZTogcixcbiAgICAgIGZyb21XaXJlVHlwZTogKHMpID0+IHtcbiAgICAgICAgZm9yICh2YXIgbCA9IFBbcyA+PiAyXSwgZCwgaCA9IHMgKyA0LCBwID0gMDsgcCA8PSBsOyArK3ApIHtcbiAgICAgICAgICB2YXIgdyA9IHMgKyA0ICsgcCAqIHQ7XG4gICAgICAgICAgaWYgKHAgPT0gbCB8fCBpKHcpID09IDApIHtcbiAgICAgICAgICAgIHZhciBiID0gdyAtIGgsIF8gPSBuKGgsIGIpO1xuICAgICAgICAgICAgZCA9PT0gdm9pZCAwID8gZCA9IF8gOiAoZCArPSBcIlxcMFwiLCBkICs9IF8pLCBoID0gdyArIHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldChzKSwgZDtcbiAgICAgIH0sXG4gICAgICB0b1dpcmVUeXBlOiAocywgbCkgPT4ge1xuICAgICAgICB0eXBlb2YgbCAhPSBcInN0cmluZ1wiICYmIEMoYENhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gQysrIHN0cmluZyB0eXBlICR7cn1gKTtcbiAgICAgICAgdmFyIGQgPSB1KGwpLCBoID0gUGUoNCArIGQgKyB0KTtcbiAgICAgICAgcmV0dXJuIFBbaCA+PiAyXSA9IGQgLyB0LCBhKGwsIGggKyA0LCBkICsgdCksIHMgIT09IG51bGwgJiYgcy5wdXNoKGV0LCBoKSwgaDtcbiAgICAgIH0sXG4gICAgICBhcmdQYWNrQWR2YW5jZTogTixcbiAgICAgIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiBsdCxcbiAgICAgIGRlc3RydWN0b3JGdW5jdGlvbihzKSB7XG4gICAgICAgIGV0KHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBwbiA9IChlLCB0LCByLCBuLCBhLCBpKSA9PiB7XG4gICAgJHRbZV0gPSB7XG4gICAgICBuYW1lOiBqKHQpLFxuICAgICAgcmF3Q29uc3RydWN0b3I6IFUociwgbiksXG4gICAgICByYXdEZXN0cnVjdG9yOiBVKGEsIGkpLFxuICAgICAgZmllbGRzOiBbXVxuICAgIH07XG4gIH0sIHZuID0gKGUsIHQsIHIsIG4sIGEsIGksIHUsIHMsIGwsIGQpID0+IHtcbiAgICAkdFtlXS5maWVsZHMucHVzaCh7XG4gICAgICBmaWVsZE5hbWU6IGoodCksXG4gICAgICBnZXR0ZXJSZXR1cm5UeXBlOiByLFxuICAgICAgZ2V0dGVyOiBVKG4sIGEpLFxuICAgICAgZ2V0dGVyQ29udGV4dDogaSxcbiAgICAgIHNldHRlckFyZ3VtZW50VHlwZTogdSxcbiAgICAgIHNldHRlcjogVShzLCBsKSxcbiAgICAgIHNldHRlckNvbnRleHQ6IGRcbiAgICB9KTtcbiAgfSwgeW4gPSAoZSwgdCkgPT4ge1xuICAgIHQgPSBqKHQpLCBWKGUsIHtcbiAgICAgIGlzVm9pZDogITAsXG4gICAgICBuYW1lOiB0LFxuICAgICAgYXJnUGFja0FkdmFuY2U6IDAsXG4gICAgICBmcm9tV2lyZVR5cGU6ICgpID0+IHtcbiAgICAgIH0sXG4gICAgICB0b1dpcmVUeXBlOiAociwgbikgPT4ge1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBHdCA9IFtdLCBtbiA9IChlLCB0LCByLCBuKSA9PiAoZSA9IEd0W2VdLCB0ID0gRy50b1ZhbHVlKHQpLCBlKG51bGwsIHQsIHIsIG4pKSwgZ24gPSB7fSwgd24gPSAoZSkgPT4ge1xuICAgIHZhciB0ID0gZ25bZV07XG4gICAgcmV0dXJuIHQgPT09IHZvaWQgMCA/IGooZSkgOiB0O1xuICB9LCBDZSA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICAgIGZ1bmN0aW9uIGUodCkge1xuICAgICAgdC4kJCRlbWJpbmRfZ2xvYmFsJCQkID0gdDtcbiAgICAgIHZhciByID0gdHlwZW9mICQkJGVtYmluZF9nbG9iYWwkJCQgPT0gXCJvYmplY3RcIiAmJiB0LiQkJGVtYmluZF9nbG9iYWwkJCQgPT0gdDtcbiAgICAgIHJldHVybiByIHx8IGRlbGV0ZSB0LiQkJGVtYmluZF9nbG9iYWwkJCQsIHI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgJCQkZW1iaW5kX2dsb2JhbCQkJCA9PSBcIm9iamVjdFwiIHx8ICh0eXBlb2YgZ2xvYmFsID09IFwib2JqZWN0XCIgJiYgZShnbG9iYWwpID8gJCQkZW1iaW5kX2dsb2JhbCQkJCA9IGdsb2JhbCA6IHR5cGVvZiBzZWxmID09IFwib2JqZWN0XCIgJiYgZShzZWxmKSAmJiAoJCQkZW1iaW5kX2dsb2JhbCQkJCA9IHNlbGYpLCB0eXBlb2YgJCQkZW1iaW5kX2dsb2JhbCQkJCA9PSBcIm9iamVjdFwiKSlcbiAgICAgIHJldHVybiAkJCRlbWJpbmRfZ2xvYmFsJCQkO1xuICAgIHRocm93IEVycm9yKFwidW5hYmxlIHRvIGdldCBnbG9iYWwgb2JqZWN0LlwiKTtcbiAgfSwgJG4gPSAoZSkgPT4gZSA9PT0gMCA/IEcudG9IYW5kbGUoQ2UoKSkgOiAoZSA9IHduKGUpLCBHLnRvSGFuZGxlKENlKClbZV0pKSwgYm4gPSAoZSkgPT4ge1xuICAgIHZhciB0ID0gR3QubGVuZ3RoO1xuICAgIHJldHVybiBHdC5wdXNoKGUpLCB0O1xuICB9LCBUZSA9IChlLCB0KSA9PiB7XG4gICAgdmFyIHIgPSBLW2VdO1xuICAgIHJldHVybiByID09PSB2b2lkIDAgJiYgQyhgJHt0fSBoYXMgdW5rbm93biB0eXBlICR7dmUoZSl9YCksIHI7XG4gIH0sIENuID0gKGUsIHQpID0+IHtcbiAgICBmb3IgKHZhciByID0gbmV3IEFycmF5KGUpLCBuID0gMDsgbiA8IGU7ICsrbilcbiAgICAgIHJbbl0gPSBUZShQW3QgKyBuICogNCA+PiAyXSwgYHBhcmFtZXRlciAke259YCk7XG4gICAgcmV0dXJuIHI7XG4gIH0sIFRuID0gKGUsIHQsIHIpID0+IHtcbiAgICB2YXIgbiA9IFtdLCBhID0gZS50b1dpcmVUeXBlKG4sIHIpO1xuICAgIHJldHVybiBuLmxlbmd0aCAmJiAoUFt0ID4+IDJdID0gRy50b0hhbmRsZShuKSksIGE7XG4gIH0sIFBuID0gUmVmbGVjdC5jb25zdHJ1Y3QsIEVuID0gKGUsIHQsIHIpID0+IHtcbiAgICB2YXIgbiA9IENuKGUsIHQpLCBhID0gbi5zaGlmdCgpO1xuICAgIGUtLTtcbiAgICB2YXIgaSA9IG5ldyBBcnJheShlKSwgdSA9IChsLCBkLCBoLCBwKSA9PiB7XG4gICAgICBmb3IgKHZhciB3ID0gMCwgYiA9IDA7IGIgPCBlOyArK2IpXG4gICAgICAgIGlbYl0gPSBuW2JdLnJlYWRWYWx1ZUZyb21Qb2ludGVyKHAgKyB3KSwgdyArPSBuW2JdLmFyZ1BhY2tBZHZhbmNlO1xuICAgICAgdmFyIF8gPSByID09PSAxID8gUG4oZCwgaSkgOiBkLmFwcGx5KGwsIGkpO1xuICAgICAgcmV0dXJuIFRuKGEsIGgsIF8pO1xuICAgIH0sIHMgPSBgbWV0aG9kQ2FsbGVyPCgke24ubWFwKChsKSA9PiBsLm5hbWUpLmpvaW4oXCIsIFwiKX0pID0+ICR7YS5uYW1lfT5gO1xuICAgIHJldHVybiBibihVdChzLCB1KSk7XG4gIH0sIF9uID0gKGUpID0+IHtcbiAgICBlID4gOSAmJiAoeltlICsgMV0gKz0gMSk7XG4gIH0sIE9uID0gKGUpID0+IHtcbiAgICB2YXIgdCA9IEcudG9WYWx1ZShlKTtcbiAgICBMdCh0KSwgenQoZSk7XG4gIH0sIHhuID0gKGUsIHQpID0+IHtcbiAgICBlID0gVGUoZSwgXCJfZW12YWxfdGFrZV92YWx1ZVwiKTtcbiAgICB2YXIgciA9IGUucmVhZFZhbHVlRnJvbVBvaW50ZXIodCk7XG4gICAgcmV0dXJuIEcudG9IYW5kbGUocik7XG4gIH0sIEFuID0gKGUsIHQsIHIsIG4pID0+IHtcbiAgICB2YXIgYSA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0RnVsbFllYXIoKSwgaSA9IG5ldyBEYXRlKGEsIDAsIDEpLCB1ID0gbmV3IERhdGUoYSwgNiwgMSksIHMgPSBpLmdldFRpbWV6b25lT2Zmc2V0KCksIGwgPSB1LmdldFRpbWV6b25lT2Zmc2V0KCksIGQgPSBNYXRoLm1heChzLCBsKTtcbiAgICBQW2UgPj4gMl0gPSBkICogNjAsIGF0W3QgPj4gMl0gPSArKHMgIT0gbCk7XG4gICAgdmFyIGggPSAoYikgPT4ge1xuICAgICAgdmFyIF8gPSBiID49IDAgPyBcIi1cIiA6IFwiK1wiLCBTID0gTWF0aC5hYnMoYiksIEEgPSBTdHJpbmcoTWF0aC5mbG9vcihTIC8gNjApKS5wYWRTdGFydCgyLCBcIjBcIiksIEkgPSBTdHJpbmcoUyAlIDYwKS5wYWRTdGFydCgyLCBcIjBcIik7XG4gICAgICByZXR1cm4gYFVUQyR7X30ke0F9JHtJfWA7XG4gICAgfSwgcCA9IGgocyksIHcgPSBoKGwpO1xuICAgIGwgPCBzID8gKGl0KHAsIHIsIDE3KSwgaXQodywgbiwgMTcpKSA6IChpdChwLCBuLCAxNyksIGl0KHcsIHIsIDE3KSk7XG4gIH0sIFNuID0gKCkgPT4gMjE0NzQ4MzY0OCwgSW4gPSAoZSwgdCkgPT4gTWF0aC5jZWlsKGUgLyB0KSAqIHQsIERuID0gKGUpID0+IHtcbiAgICB2YXIgdCA9IG50LmJ1ZmZlciwgciA9IChlIC0gdC5ieXRlTGVuZ3RoICsgNjU1MzUpIC8gNjU1MzYgfCAwO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbnQuZ3JvdyhyKSwgZWUoKSwgMTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH0sIE1uID0gKGUpID0+IHtcbiAgICB2YXIgdCA9IEIubGVuZ3RoO1xuICAgIGUgPj4+PSAwO1xuICAgIHZhciByID0gU24oKTtcbiAgICBpZiAoZSA+IHIpXG4gICAgICByZXR1cm4gITE7XG4gICAgZm9yICh2YXIgbiA9IDE7IG4gPD0gNDsgbiAqPSAyKSB7XG4gICAgICB2YXIgYSA9IHQgKiAoMSArIDAuMiAvIG4pO1xuICAgICAgYSA9IE1hdGgubWluKGEsIGUgKyAxMDA2NjMyOTYpO1xuICAgICAgdmFyIGkgPSBNYXRoLm1pbihyLCBJbihNYXRoLm1heChlLCBhKSwgNjU1MzYpKSwgdSA9IERuKGkpO1xuICAgICAgaWYgKHUpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9LCBYdCA9IHt9LCBGbiA9ICgpID0+IE0gfHwgXCIuL3RoaXMucHJvZ3JhbVwiLCBodCA9ICgpID0+IHtcbiAgICBpZiAoIWh0LnN0cmluZ3MpIHtcbiAgICAgIHZhciBlID0gKHR5cGVvZiBuYXZpZ2F0b3IgPT0gXCJvYmplY3RcIiAmJiBuYXZpZ2F0b3IubGFuZ3VhZ2VzICYmIG5hdmlnYXRvci5sYW5ndWFnZXNbMF0gfHwgXCJDXCIpLnJlcGxhY2UoXCItXCIsIFwiX1wiKSArIFwiLlVURi04XCIsIHQgPSB7XG4gICAgICAgIFVTRVI6IFwid2ViX3VzZXJcIixcbiAgICAgICAgTE9HTkFNRTogXCJ3ZWJfdXNlclwiLFxuICAgICAgICBQQVRIOiBcIi9cIixcbiAgICAgICAgUFdEOiBcIi9cIixcbiAgICAgICAgSE9NRTogXCIvaG9tZS93ZWJfdXNlclwiLFxuICAgICAgICBMQU5HOiBlLFxuICAgICAgICBfOiBGbigpXG4gICAgICB9O1xuICAgICAgZm9yICh2YXIgciBpbiBYdClcbiAgICAgICAgWHRbcl0gPT09IHZvaWQgMCA/IGRlbGV0ZSB0W3JdIDogdFtyXSA9IFh0W3JdO1xuICAgICAgdmFyIG4gPSBbXTtcbiAgICAgIGZvciAodmFyIHIgaW4gdClcbiAgICAgICAgbi5wdXNoKGAke3J9PSR7dFtyXX1gKTtcbiAgICAgIGh0LnN0cmluZ3MgPSBuO1xuICAgIH1cbiAgICByZXR1cm4gaHQuc3RyaW5ncztcbiAgfSwgam4gPSAoZSwgdCkgPT4ge1xuICAgIHZhciByID0gMCwgbiA9IDA7XG4gICAgZm9yICh2YXIgYSBvZiBodCgpKSB7XG4gICAgICB2YXIgaSA9IHQgKyByO1xuICAgICAgUFtlICsgbiA+PiAyXSA9IGksIHIgKz0gaXQoYSwgaSwgMSAvIDApICsgMSwgbiArPSA0O1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSwgUm4gPSAoZSwgdCkgPT4ge1xuICAgIHZhciByID0gaHQoKTtcbiAgICBQW2UgPj4gMl0gPSByLmxlbmd0aDtcbiAgICB2YXIgbiA9IDA7XG4gICAgZm9yICh2YXIgYSBvZiByKVxuICAgICAgbiArPSBnZShhKSArIDE7XG4gICAgcmV0dXJuIFBbdCA+PiAyXSA9IG4sIDA7XG4gIH0sIExuID0gKGUpID0+IDUyO1xuICBmdW5jdGlvbiBCbihlLCB0LCByLCBuLCBhKSB7XG4gICAgcmV0dXJuIDcwO1xuICB9XG4gIHZhciBXbiA9IFtudWxsLCBbXSwgW11dLCBVbiA9IChlLCB0KSA9PiB7XG4gICAgdmFyIHIgPSBXbltlXTtcbiAgICB0ID09PSAwIHx8IHQgPT09IDEwID8gKChlID09PSAxID8gc3QgOiBrKSgkZShyKSksIHIubGVuZ3RoID0gMCkgOiByLnB1c2godCk7XG4gIH0sIFZuID0gKGUsIHQsIHIsIG4pID0+IHtcbiAgICBmb3IgKHZhciBhID0gMCwgaSA9IDA7IGkgPCByOyBpKyspIHtcbiAgICAgIHZhciB1ID0gUFt0ID4+IDJdLCBzID0gUFt0ICsgNCA+PiAyXTtcbiAgICAgIHQgKz0gODtcbiAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgczsgbCsrKVxuICAgICAgICBVbihlLCBCW3UgKyBsXSk7XG4gICAgICBhICs9IHM7XG4gICAgfVxuICAgIHJldHVybiBQW24gPj4gMl0gPSBhLCAwO1xuICB9LCBrbiA9IChlKSA9PiBlO1xuICBicigpLCBfcigpLCBCcigpLCBYcigpLCBjLm5vRXhpdFJ1bnRpbWUgJiYgYy5ub0V4aXRSdW50aW1lLCBjLnByaW50ICYmIChzdCA9IGMucHJpbnQpLCBjLnByaW50RXJyICYmIChrID0gYy5wcmludEVyciksIGMud2FzbUJpbmFyeSAmJiAoWiA9IGMud2FzbUJpbmFyeSksIGMuYXJndW1lbnRzICYmIGMuYXJndW1lbnRzLCBjLnRoaXNQcm9ncmFtICYmIChNID0gYy50aGlzUHJvZ3JhbSk7XG4gIHZhciBIbiA9IHtcbiAgICBzOiB1cixcbiAgICB3OiBjcixcbiAgICBhOiBscixcbiAgICBqOiBmcixcbiAgICBtOiBkcixcbiAgICBOOiBocixcbiAgICBwOiBwcixcbiAgICBkYTogdnIsXG4gICAgZDogeXIsXG4gICAgXzogbXIsXG4gICAgc2E6IHdyLFxuICAgIFo6ICRyLFxuICAgIG5hOiBUcixcbiAgICBxYToga3IsXG4gICAgcGE6IE5yLFxuICAgIEY6IHpyLFxuICAgIGxhOiBxcixcbiAgICBSOiBacixcbiAgICBTOiBRcixcbiAgICB5OiBLcixcbiAgICB0OiB0bixcbiAgICByYTogcm4sXG4gICAgbWE6IG9uLFxuICAgIE86IGhuLFxuICAgIEs6IHBuLFxuICAgIHRhOiB2bixcbiAgICBvYTogeW4sXG4gICAgVjogbW4sXG4gICAgdWE6IHp0LFxuICAgIHdhOiAkbixcbiAgICAkOiBFbixcbiAgICBUOiBfbixcbiAgICB2YTogT24sXG4gICAga2E6IHhuLFxuICAgIGFhOiBBbixcbiAgICBlYTogTW4sXG4gICAgYmE6IGpuLFxuICAgIGNhOiBSbixcbiAgICBmYTogTG4sXG4gICAgWDogQm4sXG4gICAgUTogVm4sXG4gICAgSTogYmEsXG4gICAgQzogVGEsXG4gICAgVTogb2EsXG4gICAgUDogU2EsXG4gICAgcTogbWEsXG4gICAgYjogZWEsXG4gICAgRDogJGEsXG4gICAgaWE6IEVhLFxuICAgIGM6IG5hLFxuICAgIGhhOiBfYSxcbiAgICBoOiBhYSxcbiAgICBpOiBsYSxcbiAgICByOiBkYSxcbiAgICBNOiB3YSxcbiAgICB2OiBwYSxcbiAgICBFOiB5YSxcbiAgICBKOiBnYSxcbiAgICBBOiBQYSxcbiAgICBIOiBJYSxcbiAgICBXOiBGYSxcbiAgICBrOiBzYSxcbiAgICBmOiBpYSxcbiAgICBlOiByYSxcbiAgICBnOiB0YSxcbiAgICBMOiBBYSxcbiAgICBsOiBjYSxcbiAgICBqYTogQ2EsXG4gICAgbzogaGEsXG4gICAgeDogZmEsXG4gICAgdTogdmEsXG4gICAgZ2E6IHhhLFxuICAgIEI6IE9hLFxuICAgIG46IHVhLFxuICAgIEc6IERhLFxuICAgIFk6IE1hLFxuICAgIHo6IGtuXG4gIH0sIEUgPSBhd2FpdCBvcigpO1xuICBFLnlhO1xuICB2YXIgTm4gPSBFLnphLCBldCA9IGMuX2ZyZWUgPSBFLkFhLCBQZSA9IGMuX21hbGxvYyA9IEUuQ2EsIHpuID0gRS5EYSwgdiA9IEUuRWEsIEduID0gRS5GYSwgWG4gPSBFLkdhLCBxbiA9IEUuSGEsIFluID0gRS5JYSwgWm4gPSBFLkphLCBRbiA9IEUuS2E7XG4gIGMuZHluQ2FsbF92aWlqaWkgPSBFLkxhO1xuICB2YXIgSm4gPSBjLmR5bkNhbGxfdmlqID0gRS5NYTtcbiAgYy5keW5DYWxsX2ppamkgPSBFLk5hO1xuICB2YXIgS24gPSBjLmR5bkNhbGxfamlpaWkgPSBFLk9hO1xuICBjLmR5bkNhbGxfaWlpaWlqID0gRS5QYSwgYy5keW5DYWxsX2lpaWlpamogPSBFLlFhLCBjLmR5bkNhbGxfaWlpaWlpamogPSBFLlJhO1xuICBmdW5jdGlvbiB0YShlLCB0LCByLCBuKSB7XG4gICAgdmFyIGEgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIGcoZSkodCwgciwgbik7XG4gICAgfSBjYXRjaCAoaSkge1xuICAgICAgaWYgKHkoYSksIGkgIT09IGkgKyAwKSB0aHJvdyBpO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZWEoZSwgdCkge1xuICAgIHZhciByID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZyhlKSh0KTtcbiAgICB9IGNhdGNoIChuKSB7XG4gICAgICBpZiAoeShyKSwgbiAhPT0gbiArIDApIHRocm93IG47XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByYShlLCB0LCByKSB7XG4gICAgdmFyIG4gPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIGcoZSkodCwgcik7XG4gICAgfSBjYXRjaCAoYSkge1xuICAgICAgaWYgKHkobiksIGEgIT09IGEgKyAwKSB0aHJvdyBhO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbmEoZSwgdCwgcikge1xuICAgIHZhciBuID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZyhlKSh0LCByKTtcbiAgICB9IGNhdGNoIChhKSB7XG4gICAgICBpZiAoeShuKSwgYSAhPT0gYSArIDApIHRocm93IGE7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhYShlLCB0LCByLCBuKSB7XG4gICAgdmFyIGEgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnKGUpKHQsIHIsIG4pO1xuICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgIGlmICh5KGEpLCBpICE9PSBpICsgMCkgdGhyb3cgaTtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9hKGUsIHQsIHIsIG4sIGEpIHtcbiAgICB2YXIgaSA9IG0oKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGcoZSkodCwgciwgbiwgYSk7XG4gICAgfSBjYXRjaCAodSkge1xuICAgICAgaWYgKHkoaSksIHUgIT09IHUgKyAwKSB0aHJvdyB1O1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaWEoZSwgdCkge1xuICAgIHZhciByID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICBnKGUpKHQpO1xuICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgIGlmICh5KHIpLCBuICE9PSBuICsgMCkgdGhyb3cgbjtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNhKGUpIHtcbiAgICB2YXIgdCA9IG0oKTtcbiAgICB0cnkge1xuICAgICAgZyhlKSgpO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIGlmICh5KHQpLCByICE9PSByICsgMCkgdGhyb3cgcjtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVhKGUsIHQsIHIsIG4sIGEsIGksIHUsIHMsIGwsIGQsIGgpIHtcbiAgICB2YXIgcCA9IG0oKTtcbiAgICB0cnkge1xuICAgICAgZyhlKSh0LCByLCBuLCBhLCBpLCB1LCBzLCBsLCBkLCBoKTtcbiAgICB9IGNhdGNoICh3KSB7XG4gICAgICBpZiAoeShwKSwgdyAhPT0gdyArIDApIHRocm93IHc7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjYShlLCB0LCByLCBuLCBhKSB7XG4gICAgdmFyIGkgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIGcoZSkodCwgciwgbiwgYSk7XG4gICAgfSBjYXRjaCAodSkge1xuICAgICAgaWYgKHkoaSksIHUgIT09IHUgKyAwKSB0aHJvdyB1O1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbGEoZSwgdCwgciwgbiwgYSkge1xuICAgIHZhciBpID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZyhlKSh0LCByLCBuLCBhKTtcbiAgICB9IGNhdGNoICh1KSB7XG4gICAgICBpZiAoeShpKSwgdSAhPT0gdSArIDApIHRocm93IHU7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBmYShlLCB0LCByLCBuLCBhLCBpLCB1KSB7XG4gICAgdmFyIHMgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIGcoZSkodCwgciwgbiwgYSwgaSwgdSk7XG4gICAgfSBjYXRjaCAobCkge1xuICAgICAgaWYgKHkocyksIGwgIT09IGwgKyAwKSB0aHJvdyBsO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGEoZSwgdCwgciwgbiwgYSwgaSkge1xuICAgIHZhciB1ID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZyhlKSh0LCByLCBuLCBhLCBpKTtcbiAgICB9IGNhdGNoIChzKSB7XG4gICAgICBpZiAoeSh1KSwgcyAhPT0gcyArIDApIHRocm93IHM7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoYShlLCB0LCByLCBuLCBhLCBpKSB7XG4gICAgdmFyIHUgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIGcoZSkodCwgciwgbiwgYSwgaSk7XG4gICAgfSBjYXRjaCAocykge1xuICAgICAgaWYgKHkodSksIHMgIT09IHMgKyAwKSB0aHJvdyBzO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcGEoZSwgdCwgciwgbiwgYSwgaSwgdSkge1xuICAgIHZhciBzID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZyhlKSh0LCByLCBuLCBhLCBpLCB1KTtcbiAgICB9IGNhdGNoIChsKSB7XG4gICAgICBpZiAoeShzKSwgbCAhPT0gbCArIDApIHRocm93IGw7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB2YShlLCB0LCByLCBuLCBhLCBpLCB1LCBzKSB7XG4gICAgdmFyIGwgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIGcoZSkodCwgciwgbiwgYSwgaSwgdSwgcyk7XG4gICAgfSBjYXRjaCAoZCkge1xuICAgICAgaWYgKHkobCksIGQgIT09IGQgKyAwKSB0aHJvdyBkO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24geWEoZSwgdCwgciwgbiwgYSwgaSwgdSwgcykge1xuICAgIHZhciBsID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZyhlKSh0LCByLCBuLCBhLCBpLCB1LCBzKTtcbiAgICB9IGNhdGNoIChkKSB7XG4gICAgICBpZiAoeShsKSwgZCAhPT0gZCArIDApIHRocm93IGQ7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtYShlKSB7XG4gICAgdmFyIHQgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnKGUpKCk7XG4gICAgfSBjYXRjaCAocikge1xuICAgICAgaWYgKHkodCksIHIgIT09IHIgKyAwKSB0aHJvdyByO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2EoZSwgdCwgciwgbiwgYSwgaSwgdSwgcywgbCkge1xuICAgIHZhciBkID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZyhlKSh0LCByLCBuLCBhLCBpLCB1LCBzLCBsKTtcbiAgICB9IGNhdGNoIChoKSB7XG4gICAgICBpZiAoeShkKSwgaCAhPT0gaCArIDApIHRocm93IGg7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB3YShlLCB0LCByLCBuLCBhLCBpLCB1KSB7XG4gICAgdmFyIHMgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnKGUpKHQsIHIsIG4sIGEsIGksIHUpO1xuICAgIH0gY2F0Y2ggKGwpIHtcbiAgICAgIGlmICh5KHMpLCBsICE9PSBsICsgMCkgdGhyb3cgbDtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uICRhKGUsIHQsIHIsIG4pIHtcbiAgICB2YXIgYSA9IG0oKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGcoZSkodCwgciwgbik7XG4gICAgfSBjYXRjaCAoaSkge1xuICAgICAgaWYgKHkoYSksIGkgIT09IGkgKyAwKSB0aHJvdyBpO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYmEoZSwgdCwgciwgbikge1xuICAgIHZhciBhID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZyhlKSh0LCByLCBuKTtcbiAgICB9IGNhdGNoIChpKSB7XG4gICAgICBpZiAoeShhKSwgaSAhPT0gaSArIDApIHRocm93IGk7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBDYShlLCB0LCByLCBuLCBhLCBpLCB1LCBzKSB7XG4gICAgdmFyIGwgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIGcoZSkodCwgciwgbiwgYSwgaSwgdSwgcyk7XG4gICAgfSBjYXRjaCAoZCkge1xuICAgICAgaWYgKHkobCksIGQgIT09IGQgKyAwKSB0aHJvdyBkO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gVGEoZSwgdCwgciwgbiwgYSwgaSkge1xuICAgIHZhciB1ID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZyhlKSh0LCByLCBuLCBhLCBpKTtcbiAgICB9IGNhdGNoIChzKSB7XG4gICAgICBpZiAoeSh1KSwgcyAhPT0gcyArIDApIHRocm93IHM7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBQYShlLCB0LCByLCBuLCBhLCBpLCB1LCBzLCBsLCBkKSB7XG4gICAgdmFyIGggPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnKGUpKHQsIHIsIG4sIGEsIGksIHUsIHMsIGwsIGQpO1xuICAgIH0gY2F0Y2ggKHApIHtcbiAgICAgIGlmICh5KGgpLCBwICE9PSBwICsgMCkgdGhyb3cgcDtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIEVhKGUsIHQsIHIpIHtcbiAgICB2YXIgbiA9IG0oKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGcoZSkodCwgcik7XG4gICAgfSBjYXRjaCAoYSkge1xuICAgICAgaWYgKHkobiksIGEgIT09IGEgKyAwKSB0aHJvdyBhO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gX2EoZSwgdCwgciwgbiwgYSkge1xuICAgIHZhciBpID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZyhlKSh0LCByLCBuLCBhKTtcbiAgICB9IGNhdGNoICh1KSB7XG4gICAgICBpZiAoeShpKSwgdSAhPT0gdSArIDApIHRocm93IHU7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBPYShlLCB0LCByLCBuLCBhLCBpLCB1LCBzLCBsLCBkKSB7XG4gICAgdmFyIGggPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIGcoZSkodCwgciwgbiwgYSwgaSwgdSwgcywgbCwgZCk7XG4gICAgfSBjYXRjaCAocCkge1xuICAgICAgaWYgKHkoaCksIHAgIT09IHAgKyAwKSB0aHJvdyBwO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24geGEoZSwgdCwgciwgbiwgYSwgaSwgdSwgcywgbCkge1xuICAgIHZhciBkID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICBnKGUpKHQsIHIsIG4sIGEsIGksIHUsIHMsIGwpO1xuICAgIH0gY2F0Y2ggKGgpIHtcbiAgICAgIGlmICh5KGQpLCBoICE9PSBoICsgMCkgdGhyb3cgaDtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIEFhKGUsIHQsIHIsIG4sIGEsIGksIHUpIHtcbiAgICB2YXIgcyA9IG0oKTtcbiAgICB0cnkge1xuICAgICAgZyhlKSh0LCByLCBuLCBhLCBpLCB1KTtcbiAgICB9IGNhdGNoIChsKSB7XG4gICAgICBpZiAoeShzKSwgbCAhPT0gbCArIDApIHRocm93IGw7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBTYShlLCB0LCByLCBuKSB7XG4gICAgdmFyIGEgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnKGUpKHQsIHIsIG4pO1xuICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgIGlmICh5KGEpLCBpICE9PSBpICsgMCkgdGhyb3cgaTtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIElhKGUsIHQsIHIsIG4sIGEsIGksIHUsIHMsIGwsIGQsIGgsIHApIHtcbiAgICB2YXIgdyA9IG0oKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGcoZSkodCwgciwgbiwgYSwgaSwgdSwgcywgbCwgZCwgaCwgcCk7XG4gICAgfSBjYXRjaCAoYikge1xuICAgICAgaWYgKHkodyksIGIgIT09IGIgKyAwKSB0aHJvdyBiO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gRGEoZSwgdCwgciwgbiwgYSwgaSwgdSwgcywgbCwgZCwgaCwgcCwgdywgYiwgXywgUykge1xuICAgIHZhciBBID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICBnKGUpKHQsIHIsIG4sIGEsIGksIHUsIHMsIGwsIGQsIGgsIHAsIHcsIGIsIF8sIFMpO1xuICAgIH0gY2F0Y2ggKEkpIHtcbiAgICAgIGlmICh5KEEpLCBJICE9PSBJICsgMCkgdGhyb3cgSTtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIE1hKGUsIHQsIHIsIG4pIHtcbiAgICB2YXIgYSA9IG0oKTtcbiAgICB0cnkge1xuICAgICAgSm4oZSwgdCwgciwgbik7XG4gICAgfSBjYXRjaCAoaSkge1xuICAgICAgaWYgKHkoYSksIGkgIT09IGkgKyAwKSB0aHJvdyBpO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gRmEoZSwgdCwgciwgbiwgYSkge1xuICAgIHZhciBpID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gS24oZSwgdCwgciwgbiwgYSk7XG4gICAgfSBjYXRjaCAodSkge1xuICAgICAgaWYgKHkoaSksIHUgIT09IHUgKyAwKSB0aHJvdyB1O1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcXQoKSB7XG4gICAgaWYgKEogPiAwKSB7XG4gICAgICBjdCA9IHF0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocWUoKSwgSiA+IDApIHtcbiAgICAgIGN0ID0gcXQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICB2YXIgdDtcbiAgICAgIGMuY2FsbGVkUnVuID0gITAsICFKdCAmJiAoWWUoKSwgVChjKSwgKHQgPSBjLm9uUnVudGltZUluaXRpYWxpemVkKSA9PT0gbnVsbCB8fCB0ID09PSB2b2lkIDAgfHwgdC5jYWxsKGMpLCBaZSgpKTtcbiAgICB9XG4gICAgYy5zZXRTdGF0dXMgPyAoYy5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gYy5zZXRTdGF0dXMoXCJcIiksIDEpLCBlKCk7XG4gICAgfSwgMSkpIDogZSgpO1xuICB9XG4gIGZ1bmN0aW9uIGphKCkge1xuICAgIGlmIChjLnByZUluaXQpXG4gICAgICBmb3IgKHR5cGVvZiBjLnByZUluaXQgPT0gXCJmdW5jdGlvblwiICYmIChjLnByZUluaXQgPSBbYy5wcmVJbml0XSk7IGMucHJlSW5pdC5sZW5ndGggPiAwOyApXG4gICAgICAgIGMucHJlSW5pdC5zaGlmdCgpKCk7XG4gIH1cbiAgcmV0dXJuIGphKCksIHF0KCksIGYgPSB4LCBmO1xufTtcbmZ1bmN0aW9uIEJlKG8pIHtcbiAgcmV0dXJuIExlKFF0LCBvKTtcbn1cbmZ1bmN0aW9uIENvKCkge1xuICByZXR1cm4gS2EoUXQpO1xufVxuZnVuY3Rpb24gVG8obykge1xuICBCZSh7XG4gICAgb3ZlcnJpZGVzOiBvLFxuICAgIGVxdWFsaXR5Rm46IE9iamVjdC5pcyxcbiAgICBmaXJlSW1tZWRpYXRlbHk6ICExXG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZW8obywgZikge1xuICByZXR1cm4gdG8oUXQsIG8sIGYpO1xufVxuY29uc3QgUG8gPSBcIjNjMDcwMjdkYmZkNmRhNDczMzBhYzE4ZTc0ZTY5MjQwMTlkOWFjOWE0YzFlMTYxYjgwMDY2NmY5ZTNjOTI1Y2FcIiwgV2UgPSBbXG4gIFtcImF6dGVjXCIsIFwiQXp0ZWNcIl0sXG4gIFtcImNvZGVfMTI4XCIsIFwiQ29kZTEyOFwiXSxcbiAgW1wiY29kZV8zOVwiLCBcIkNvZGUzOVwiXSxcbiAgW1wiY29kZV85M1wiLCBcIkNvZGU5M1wiXSxcbiAgW1wiY29kYWJhclwiLCBcIkNvZGFiYXJcIl0sXG4gIFtcImRhdGFiYXJcIiwgXCJEYXRhQmFyXCJdLFxuICBbXCJkYXRhYmFyX2V4cGFuZGVkXCIsIFwiRGF0YUJhckV4cGFuZGVkXCJdLFxuICBbXCJkYXRhYmFyX2xpbWl0ZWRcIiwgXCJEYXRhQmFyTGltaXRlZFwiXSxcbiAgW1wiZGF0YV9tYXRyaXhcIiwgXCJEYXRhTWF0cml4XCJdLFxuICBbXCJkeF9maWxtX2VkZ2VcIiwgXCJEWEZpbG1FZGdlXCJdLFxuICBbXCJlYW5fMTNcIiwgXCJFQU4tMTNcIl0sXG4gIFtcImVhbl84XCIsIFwiRUFOLThcIl0sXG4gIFtcIml0ZlwiLCBcIklURlwiXSxcbiAgW1wibWF4aV9jb2RlXCIsIFwiTWF4aUNvZGVcIl0sXG4gIFtcIm1pY3JvX3FyX2NvZGVcIiwgXCJNaWNyb1FSQ29kZVwiXSxcbiAgW1wicGRmNDE3XCIsIFwiUERGNDE3XCJdLFxuICBbXCJxcl9jb2RlXCIsIFwiUVJDb2RlXCJdLFxuICBbXCJybV9xcl9jb2RlXCIsIFwick1RUkNvZGVcIl0sXG4gIFtcInVwY19hXCIsIFwiVVBDLUFcIl0sXG4gIFtcInVwY19lXCIsIFwiVVBDLUVcIl0sXG4gIFtcImxpbmVhcl9jb2Rlc1wiLCBcIkxpbmVhci1Db2Rlc1wiXSxcbiAgW1wibWF0cml4X2NvZGVzXCIsIFwiTWF0cml4LUNvZGVzXCJdLFxuICBbXCJhbnlcIiwgXCJBbnlcIl1cbl0sIHJvID0gWy4uLldlLCBbXCJ1bmtub3duXCJdXS5tYXAoKG8pID0+IG9bMF0pLCBadCA9IG5ldyBNYXAoXG4gIFdlXG4pO1xuZnVuY3Rpb24gbm8obykge1xuICBmb3IgKGNvbnN0IFtmLCBjXSBvZiBadClcbiAgICBpZiAobyA9PT0gYylcbiAgICAgIHJldHVybiBmO1xuICByZXR1cm4gXCJ1bmtub3duXCI7XG59XG5mdW5jdGlvbiBhbyhvKSB7XG4gIGlmIChVZShvKSlcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IG8ubmF0dXJhbFdpZHRoLFxuICAgICAgaGVpZ2h0OiBvLm5hdHVyYWxIZWlnaHRcbiAgICB9O1xuICBpZiAoVmUobykpXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBvLndpZHRoLmJhc2VWYWwudmFsdWUsXG4gICAgICBoZWlnaHQ6IG8uaGVpZ2h0LmJhc2VWYWwudmFsdWVcbiAgICB9O1xuICBpZiAoa2UobykpXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBvLnZpZGVvV2lkdGgsXG4gICAgICBoZWlnaHQ6IG8udmlkZW9IZWlnaHRcbiAgICB9O1xuICBpZiAoTmUobykpXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBvLndpZHRoLFxuICAgICAgaGVpZ2h0OiBvLmhlaWdodFxuICAgIH07XG4gIGlmIChHZShvKSlcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IG8uZGlzcGxheVdpZHRoLFxuICAgICAgaGVpZ2h0OiBvLmRpc3BsYXlIZWlnaHRcbiAgICB9O1xuICBpZiAoSGUobykpXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBvLndpZHRoLFxuICAgICAgaGVpZ2h0OiBvLmhlaWdodFxuICAgIH07XG4gIGlmICh6ZShvKSlcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IG8ud2lkdGgsXG4gICAgICBoZWlnaHQ6IG8uaGVpZ2h0XG4gICAgfTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICBcIlRoZSBwcm92aWRlZCB2YWx1ZSBpcyBub3Qgb2YgdHlwZSAnKEJsb2Igb3IgSFRNTENhbnZhc0VsZW1lbnQgb3IgSFRNTEltYWdlRWxlbWVudCBvciBIVE1MVmlkZW9FbGVtZW50IG9yIEltYWdlQml0bWFwIG9yIEltYWdlRGF0YSBvciBPZmZzY3JlZW5DYW52YXMgb3IgU1ZHSW1hZ2VFbGVtZW50IG9yIFZpZGVvRnJhbWUpJy5cIlxuICApO1xufVxuZnVuY3Rpb24gVWUobykge1xuICB2YXIgZiwgYztcbiAgdHJ5IHtcbiAgICByZXR1cm4gbyBpbnN0YW5jZW9mICgoYyA9IChmID0gbyA9PSBudWxsID8gdm9pZCAwIDogby5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogZi5kZWZhdWx0VmlldykgPT0gbnVsbCA/IHZvaWQgMCA6IGMuSFRNTEltYWdlRWxlbWVudCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gVmUobykge1xuICB2YXIgZiwgYztcbiAgdHJ5IHtcbiAgICByZXR1cm4gbyBpbnN0YW5jZW9mICgoYyA9IChmID0gbyA9PSBudWxsID8gdm9pZCAwIDogby5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogZi5kZWZhdWx0VmlldykgPT0gbnVsbCA/IHZvaWQgMCA6IGMuU1ZHSW1hZ2VFbGVtZW50KTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBrZShvKSB7XG4gIHZhciBmLCBjO1xuICB0cnkge1xuICAgIHJldHVybiBvIGluc3RhbmNlb2YgKChjID0gKGYgPSBvID09IG51bGwgPyB2b2lkIDAgOiBvLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBmLmRlZmF1bHRWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogYy5IVE1MVmlkZW9FbGVtZW50KTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBIZShvKSB7XG4gIHZhciBmLCBjO1xuICB0cnkge1xuICAgIHJldHVybiBvIGluc3RhbmNlb2YgKChjID0gKGYgPSBvID09IG51bGwgPyB2b2lkIDAgOiBvLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBmLmRlZmF1bHRWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogYy5IVE1MQ2FudmFzRWxlbWVudCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gTmUobykge1xuICB0cnkge1xuICAgIHJldHVybiBvIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSBcIltvYmplY3QgSW1hZ2VCaXRtYXBdXCI7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gemUobykge1xuICB0cnkge1xuICAgIHJldHVybiBvIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gXCJbb2JqZWN0IE9mZnNjcmVlbkNhbnZhc11cIjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBHZShvKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG8gaW5zdGFuY2VvZiBWaWRlb0ZyYW1lIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gXCJbb2JqZWN0IFZpZGVvRnJhbWVdXCI7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gb28obykge1xuICB0cnkge1xuICAgIHJldHVybiBvIGluc3RhbmNlb2YgQmxvYiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBCbG9iXVwiO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmZ1bmN0aW9uIGlvKG8pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbyBpbnN0YW5jZW9mIEltYWdlRGF0YSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBJbWFnZURhdGFdXCI7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gc28obywgZikge1xuICB0cnkge1xuICAgIGNvbnN0IGMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKG8sIGYpO1xuICAgIGlmIChjLmdldENvbnRleHQoXCIyZFwiKSBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRClcbiAgICAgIHJldHVybiBjO1xuICAgIHRocm93IHZvaWQgMDtcbiAgfSBjYXRjaCB7XG4gICAgY29uc3QgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgcmV0dXJuIGMud2lkdGggPSBvLCBjLmhlaWdodCA9IGYsIGM7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIFhlKG8pIHtcbiAgaWYgKFVlKG8pICYmICFhd2FpdCBmbyhvKSlcbiAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgXCJGYWlsZWQgdG8gbG9hZCBvciBkZWNvZGUgSFRNTEltYWdlRWxlbWVudC5cIixcbiAgICAgIFwiSW52YWxpZFN0YXRlRXJyb3JcIlxuICAgICk7XG4gIGlmIChWZShvKSAmJiAhYXdhaXQgaG8obykpXG4gICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcbiAgICAgIFwiRmFpbGVkIHRvIGxvYWQgb3IgZGVjb2RlIFNWR0ltYWdlRWxlbWVudC5cIixcbiAgICAgIFwiSW52YWxpZFN0YXRlRXJyb3JcIlxuICAgICk7XG4gIGlmIChHZShvKSAmJiBwbyhvKSlcbiAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiVmlkZW9GcmFtZSBpcyBjbG9zZWQuXCIsIFwiSW52YWxpZFN0YXRlRXJyb3JcIik7XG4gIGlmIChrZShvKSAmJiAoby5yZWFkeVN0YXRlID09PSAwIHx8IG8ucmVhZHlTdGF0ZSA9PT0gMSkpXG4gICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIkludmFsaWQgZWxlbWVudCBvciBzdGF0ZS5cIiwgXCJJbnZhbGlkU3RhdGVFcnJvclwiKTtcbiAgaWYgKE5lKG8pICYmIHlvKG8pKVxuICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXG4gICAgICBcIlRoZSBpbWFnZSBzb3VyY2UgaXMgZGV0YWNoZWQuXCIsXG4gICAgICBcIkludmFsaWRTdGF0ZUVycm9yXCJcbiAgICApO1xuICBjb25zdCB7IHdpZHRoOiBmLCBoZWlnaHQ6IGMgfSA9IGFvKG8pO1xuICBpZiAoZiA9PT0gMCB8fCBjID09PSAwKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCAkID0gc28oZiwgYykuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAkLmRyYXdJbWFnZShvLCAwLCAwKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gJC5nZXRJbWFnZURhdGEoMCwgMCwgZiwgYyk7XG4gIH0gY2F0Y2gge1xuICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJTb3VyY2Ugd291bGQgdGFpbnQgb3JpZ2luLlwiLCBcIlNlY3VyaXR5RXJyb3JcIik7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHVvKG8pIHtcbiAgbGV0IGY7XG4gIHRyeSB7XG4gICAgZiA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKG8pO1xuICB9IGNhdGNoIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGdsb2JhbFRoaXMuSW1hZ2UpIHtcbiAgICAgICAgZiA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBsZXQgJCA9IFwiXCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgJCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobyksIGYuc3JjID0gJCwgYXdhaXQgZi5kZWNvZGUoKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKCQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgICBcIkZhaWxlZCB0byBsb2FkIG9yIGRlY29kZSBCbG9iLlwiLFxuICAgICAgICBcIkludmFsaWRTdGF0ZUVycm9yXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhd2FpdCBYZShmKTtcbn1cbmZ1bmN0aW9uIGNvKG8pIHtcbiAgY29uc3QgeyB3aWR0aDogZiwgaGVpZ2h0OiBjIH0gPSBvO1xuICBpZiAoZiA9PT0gMCB8fCBjID09PSAwKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBUID0gby5nZXRDb250ZXh0KFwiMmRcIik7XG4gIHRyeSB7XG4gICAgcmV0dXJuIFQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGYsIGMpO1xuICB9IGNhdGNoIHtcbiAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiU291cmNlIHdvdWxkIHRhaW50IG9yaWdpbi5cIiwgXCJTZWN1cml0eUVycm9yXCIpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBsbyhvKSB7XG4gIGlmIChvbyhvKSlcbiAgICByZXR1cm4gYXdhaXQgdW8obyk7XG4gIGlmIChpbyhvKSkge1xuICAgIGlmICh2byhvKSlcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXG4gICAgICAgIFwiVGhlIGltYWdlIGRhdGEgaGFzIGJlZW4gZGV0YWNoZWQuXCIsXG4gICAgICAgIFwiSW52YWxpZFN0YXRlRXJyb3JcIlxuICAgICAgKTtcbiAgICByZXR1cm4gbztcbiAgfVxuICByZXR1cm4gSGUobykgfHwgemUobykgPyBjbyhvKSA6IGF3YWl0IFhlKG8pO1xufVxuYXN5bmMgZnVuY3Rpb24gZm8obykge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBvLmRlY29kZSgpLCAhMDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBobyhvKSB7XG4gIHZhciBmO1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCAoKGYgPSBvLmRlY29kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGYuY2FsbChvKSksICEwO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmZ1bmN0aW9uIHBvKG8pIHtcbiAgcmV0dXJuIG8uZm9ybWF0ID09PSBudWxsO1xufVxuZnVuY3Rpb24gdm8obykge1xuICByZXR1cm4gby5kYXRhLmJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwO1xufVxuZnVuY3Rpb24geW8obykge1xuICByZXR1cm4gby53aWR0aCA9PT0gMCAmJiBvLmhlaWdodCA9PT0gMDtcbn1cbmZ1bmN0aW9uIFJlKG8sIGYpIHtcbiAgcmV0dXJuIG1vKG8pID8gbmV3IERPTUV4Y2VwdGlvbihgJHtmfTogJHtvLm1lc3NhZ2V9YCwgby5uYW1lKSA6IGdvKG8pID8gbmV3IG8uY29uc3RydWN0b3IoYCR7Zn06ICR7by5tZXNzYWdlfWApIDogbmV3IEVycm9yKGAke2Z9OiAke299YCk7XG59XG5mdW5jdGlvbiBtbyhvKSB7XG4gIHJldHVybiBvIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gXCJbb2JqZWN0IERPTUV4Y2VwdGlvbl1cIjtcbn1cbmZ1bmN0aW9uIGdvKG8pIHtcbiAgcmV0dXJuIG8gaW5zdGFuY2VvZiBFcnJvciB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBFcnJvcl1cIjtcbn1cbnZhciBwdDtcbmNsYXNzIEVvIHtcbiAgY29uc3RydWN0b3IoZiA9IHt9KSB7XG4gICAgRGUodGhpcywgcHQpO1xuICAgIHZhciBjO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBUID0gKGMgPSBmID09IG51bGwgPyB2b2lkIDAgOiBmLmZvcm1hdHMpID09IG51bGwgPyB2b2lkIDAgOiBjLmZpbHRlcihcbiAgICAgICAgKCQpID0+ICQgIT09IFwidW5rbm93blwiXG4gICAgICApO1xuICAgICAgaWYgKChUID09IG51bGwgPyB2b2lkIDAgOiBULmxlbmd0aCkgPT09IDApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJIaW50IG9wdGlvbiBwcm92aWRlZCwgYnV0IGlzIGVtcHR5LlwiKTtcbiAgICAgIGZvciAoY29uc3QgJCBvZiBUICE9IG51bGwgPyBUIDogW10pXG4gICAgICAgIGlmICghWnQuaGFzKCQpKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIHJlYWQgdGhlICdmb3JtYXRzJyBwcm9wZXJ0eSBmcm9tICdCYXJjb2RlRGV0ZWN0b3JPcHRpb25zJzogVGhlIHByb3ZpZGVkIHZhbHVlICckeyR9JyBpcyBub3QgYSB2YWxpZCBlbnVtIHZhbHVlIG9mIHR5cGUgQmFyY29kZUZvcm1hdC5gXG4gICAgICAgICAgKTtcbiAgICAgIE1lKHRoaXMsIHB0LCBUICE9IG51bGwgPyBUIDogW10pLCBCZSh7IGZpcmVJbW1lZGlhdGVseTogITAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoVCkge1xuICAgICAgdGhyb3cgUmUoXG4gICAgICAgIFQsXG4gICAgICAgIFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnQmFyY29kZURldGVjdG9yJ1wiXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgYXN5bmMgZ2V0U3VwcG9ydGVkRm9ybWF0cygpIHtcbiAgICByZXR1cm4gcm8uZmlsdGVyKChmKSA9PiBmICE9PSBcInVua25vd25cIik7XG4gIH1cbiAgYXN5bmMgZGV0ZWN0KGYpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYyA9IGF3YWl0IGxvKGYpO1xuICAgICAgaWYgKGMgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIGxldCBUO1xuICAgICAgY29uc3QgJCA9IHtcbiAgICAgICAgdHJ5Q29kZTM5RXh0ZW5kZWRNb2RlOiAhMSxcbiAgICAgICAgdGV4dE1vZGU6IFwiUGxhaW5cIixcbiAgICAgICAgZm9ybWF0czogSWUodGhpcywgcHQpLm1hcCgoeCkgPT4gWnQuZ2V0KHgpKVxuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIFQgPSBhd2FpdCBlbyhjLCAkKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdGhyb3cgY29uc29sZS5lcnJvcih4KSwgbmV3IERPTUV4Y2VwdGlvbihcbiAgICAgICAgICBcIkJhcmNvZGUgZGV0ZWN0aW9uIHNlcnZpY2UgdW5hdmFpbGFibGUuXCIsXG4gICAgICAgICAgXCJOb3RTdXBwb3J0ZWRFcnJvclwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gVC5tYXAoKHgpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHRvcExlZnQ6IHsgeDogRCwgeTogUiB9LFxuICAgICAgICAgIHRvcFJpZ2h0OiB7IHg6IE8sIHk6IE0gfSxcbiAgICAgICAgICBib3R0b21MZWZ0OiB7IHg6IEYsIHk6IHEgfSxcbiAgICAgICAgICBib3R0b21SaWdodDogeyB4OiBydCwgeTogWSB9XG4gICAgICAgIH0gPSB4LnBvc2l0aW9uLCBzdCA9IE1hdGgubWluKEQsIE8sIEYsIHJ0KSwgayA9IE1hdGgubWluKFIsIE0sIHEsIFkpLCBaID0gTWF0aC5tYXgoRCwgTywgRiwgcnQpLCBudCA9IE1hdGgubWF4KFIsIE0sIHEsIFkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJvdW5kaW5nQm94OiBuZXcgRE9NUmVjdFJlYWRPbmx5KFxuICAgICAgICAgICAgc3QsXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgWiAtIHN0LFxuICAgICAgICAgICAgbnQgLSBrXG4gICAgICAgICAgKSxcbiAgICAgICAgICByYXdWYWx1ZTogeC50ZXh0LFxuICAgICAgICAgIGZvcm1hdDogbm8oeC5mb3JtYXQpLFxuICAgICAgICAgIGNvcm5lclBvaW50czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiBELFxuICAgICAgICAgICAgICB5OiBSXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiBPLFxuICAgICAgICAgICAgICB5OiBNXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiBydCxcbiAgICAgICAgICAgICAgeTogWVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogRixcbiAgICAgICAgICAgICAgeTogcVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGMpIHtcbiAgICAgIHRocm93IFJlKFxuICAgICAgICBjLFxuICAgICAgICBcIkZhaWxlZCB0byBleGVjdXRlICdkZXRlY3QnIG9uICdCYXJjb2RlRGV0ZWN0b3InXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5wdCA9IG5ldyBXZWFrTWFwKCk7XG5leHBvcnQge1xuICBFbyBhcyBCYXJjb2RlRGV0ZWN0b3IsXG4gIGJvIGFzIFpYSU5HX0NQUF9DT01NSVQsXG4gIFBvIGFzIFpYSU5HX1dBU01fU0hBMjU2LFxuICAkbyBhcyBaWElOR19XQVNNX1ZFUlNJT04sXG4gIEJlIGFzIHByZXBhcmVaWGluZ01vZHVsZSxcbiAgQ28gYXMgcHVyZ2VaWGluZ01vZHVsZSxcbiAgVG8gYXMgc2V0WlhpbmdNb2R1bGVPdmVycmlkZXNcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/barcode-detector/dist/es/ponyfill.js\n");

/***/ })

};
;