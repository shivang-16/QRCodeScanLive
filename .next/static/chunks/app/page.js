/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./app/page.tsx":
/*!**********************!*\
  !*** ./app/page.tsx ***!
  \**********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Home)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _yudiel_react_qr_scanner__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @yudiel/react-qr-scanner */ \"(app-pages-browser)/./node_modules/@yudiel/react-qr-scanner/dist/index.esm.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction Home() {\n    _s();\n    const [result, setResult] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const handleScan = (result)=>{\n        if (result && result.length > 0) {\n            setResult(result[0].rawValue);\n            setError('');\n        }\n    };\n    const handleError = (error)=>{\n        console.error('QR Scanner Error:', error);\n        setError('Error accessing camera or scanning QR code. Please check camera permissions.');\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"min-h-screen bg-gray-100 flex flex-col items-center justify-center p-4\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"w-full max-w-md mx-auto bg-white rounded-lg shadow-lg p-6\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                    className: \"text-3xl font-bold text-center text-gray-800 mb-8\",\n                    children: \"QR Code Scanner\"\n                }, void 0, false, {\n                    fileName: \"/home/runner/workspace/app/page.tsx\",\n                    lineNumber: 25,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"mb-6\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"relative w-full aspect-square bg-black rounded-lg overflow-hidden\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_yudiel_react_qr_scanner__WEBPACK_IMPORTED_MODULE_2__.Scanner, {\n                            onScan: handleScan,\n                            onError: handleError,\n                            constraints: {\n                                facingMode: 'environment'\n                            },\n                            formats: [\n                                'qr_code'\n                            ],\n                            scanDelay: 500,\n                            styles: {\n                                container: {\n                                    width: '100%',\n                                    height: '100%'\n                                },\n                                video: {\n                                    width: '100%',\n                                    height: '100%',\n                                    objectFit: 'cover'\n                                }\n                            }\n                        }, void 0, false, {\n                            fileName: \"/home/runner/workspace/app/page.tsx\",\n                            lineNumber: 32,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/home/runner/workspace/app/page.tsx\",\n                        lineNumber: 31,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/home/runner/workspace/app/page.tsx\",\n                    lineNumber: 30,\n                    columnNumber: 9\n                }, this),\n                error && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"mb-4 bg-red-50 border border-red-200 rounded-lg p-4\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-red-600 text-sm text-center\",\n                        children: error\n                    }, void 0, false, {\n                        fileName: \"/home/runner/workspace/app/page.tsx\",\n                        lineNumber: 58,\n                        columnNumber: 13\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/home/runner/workspace/app/page.tsx\",\n                    lineNumber: 57,\n                    columnNumber: 11\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"bg-gray-50 rounded-lg p-4\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                            className: \"text-lg font-semibold text-gray-700 mb-2\",\n                            children: \"Scan Result:\"\n                        }, void 0, false, {\n                            fileName: \"/home/runner/workspace/app/page.tsx\",\n                            lineNumber: 64,\n                            columnNumber: 11\n                        }, this),\n                        result ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"bg-white border rounded p-3\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"text-gray-800 break-all\",\n                                    children: result\n                                }, void 0, false, {\n                                    fileName: \"/home/runner/workspace/app/page.tsx\",\n                                    lineNumber: 69,\n                                    columnNumber: 15\n                                }, this),\n                                result.startsWith('http') && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    href: result,\n                                    target: \"_blank\",\n                                    rel: \"noopener noreferrer\",\n                                    className: \"inline-block mt-2 text-blue-600 hover:text-blue-800 underline text-sm\",\n                                    children: \"Open Link\"\n                                }, void 0, false, {\n                                    fileName: \"/home/runner/workspace/app/page.tsx\",\n                                    lineNumber: 71,\n                                    columnNumber: 17\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/runner/workspace/app/page.tsx\",\n                            lineNumber: 68,\n                            columnNumber: 13\n                        }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-gray-500 italic\",\n                            children: \"Point your camera at a QR code to scan it\"\n                        }, void 0, false, {\n                            fileName: \"/home/runner/workspace/app/page.tsx\",\n                            lineNumber: 82,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/runner/workspace/app/page.tsx\",\n                    lineNumber: 63,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"mt-6 text-center\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-sm text-gray-600\",\n                        children: \"Hold your device steady and point the camera at a QR code\"\n                    }, void 0, false, {\n                        fileName: \"/home/runner/workspace/app/page.tsx\",\n                        lineNumber: 90,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/home/runner/workspace/app/page.tsx\",\n                    lineNumber: 89,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/home/runner/workspace/app/page.tsx\",\n            lineNumber: 23,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/home/runner/workspace/app/page.tsx\",\n        lineNumber: 22,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"lvnMm+rwq5qY95na+FqdtBG6jpQ=\");\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBRXVDO0FBQ1c7QUFFbkMsU0FBU0c7O0lBQ3RCLE1BQU0sQ0FBQ0MsUUFBUUMsVUFBVSxHQUFHSiwrQ0FBUUEsQ0FBUztJQUM3QyxNQUFNLENBQUNLLE9BQU9DLFNBQVMsR0FBR04sK0NBQVFBLENBQVM7SUFDM0MsTUFBTU8sYUFBYSxDQUFDSjtRQUNsQixJQUFJQSxVQUFVQSxPQUFPSyxNQUFNLEdBQUcsR0FBRztZQUMvQkosVUFBVUQsTUFBTSxDQUFDLEVBQUUsQ0FBQ00sUUFBUTtZQUM1QkgsU0FBUztRQUNYO0lBQ0Y7SUFFQSxNQUFNSSxjQUFjLENBQUNMO1FBQ25CTSxRQUFRTixLQUFLLENBQUMscUJBQXFCQTtRQUNuQ0MsU0FBUztJQUNYO0lBRUEscUJBQ0UsOERBQUNNO1FBQUlDLFdBQVU7a0JBQ2IsNEVBQUNEO1lBQUlDLFdBQVU7OzhCQUViLDhEQUFDQztvQkFBR0QsV0FBVTs4QkFBb0Q7Ozs7Ozs4QkFLbEUsOERBQUNEO29CQUFJQyxXQUFVOzhCQUNiLDRFQUFDRDt3QkFBSUMsV0FBVTtrQ0FDYiw0RUFBQ1osNkRBQU9BOzRCQUNOYyxRQUFRUjs0QkFDUlMsU0FBU047NEJBQ1RPLGFBQWE7Z0NBQ1hDLFlBQVk7NEJBQ2Q7NEJBQ0FDLFNBQVM7Z0NBQUM7NkJBQVU7NEJBQ3BCQyxXQUFXOzRCQUNYQyxRQUFRO2dDQUNOQyxXQUFXO29DQUNUQyxPQUFPO29DQUNQQyxRQUFRO2dDQUNWO2dDQUNBQyxPQUFPO29DQUNMRixPQUFPO29DQUNQQyxRQUFRO29DQUNSRSxXQUFXO2dDQUNiOzRCQUNGOzs7Ozs7Ozs7Ozs7Ozs7O2dCQU1MckIsdUJBQ0MsOERBQUNPO29CQUFJQyxXQUFVOzhCQUNiLDRFQUFDYzt3QkFBRWQsV0FBVTtrQ0FBb0NSOzs7Ozs7Ozs7Ozs4QkFLckQsOERBQUNPO29CQUFJQyxXQUFVOztzQ0FDYiw4REFBQ2U7NEJBQUdmLFdBQVU7c0NBQTJDOzs7Ozs7d0JBR3hEVix1QkFDQyw4REFBQ1M7NEJBQUlDLFdBQVU7OzhDQUNiLDhEQUFDYztvQ0FBRWQsV0FBVTs4Q0FBMkJWOzs7Ozs7Z0NBQ3ZDQSxPQUFPMEIsVUFBVSxDQUFDLHlCQUNqQiw4REFBQ0M7b0NBQ0NDLE1BQU01QjtvQ0FDTjZCLFFBQU87b0NBQ1BDLEtBQUk7b0NBQ0pwQixXQUFVOzhDQUNYOzs7Ozs7Ozs7OztpREFNTCw4REFBQ2M7NEJBQUVkLFdBQVU7c0NBQXVCOzs7Ozs7Ozs7Ozs7OEJBT3hDLDhEQUFDRDtvQkFBSUMsV0FBVTs4QkFDYiw0RUFBQ2M7d0JBQUVkLFdBQVU7a0NBQXdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTy9DO0dBM0Z3Qlg7S0FBQUEiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2UvYXBwL3BhZ2UudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFNjYW5uZXIgfSBmcm9tICdAeXVkaWVsL3JlYWN0LXFyLXNjYW5uZXInXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUoKSB7XG4gIGNvbnN0IFtyZXN1bHQsIHNldFJlc3VsdF0gPSB1c2VTdGF0ZTxzdHJpbmc+KCcnKVxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZz4oJycpXG4gIGNvbnN0IGhhbmRsZVNjYW4gPSAocmVzdWx0OiBhbnlbXSkgPT4ge1xuICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHNldFJlc3VsdChyZXN1bHRbMF0ucmF3VmFsdWUpXG4gICAgICBzZXRFcnJvcignJylcbiAgICB9XG4gIH1cblxuICBjb25zdCBoYW5kbGVFcnJvciA9IChlcnJvcjogYW55KSA9PiB7XG4gICAgY29uc29sZS5lcnJvcignUVIgU2Nhbm5lciBFcnJvcjonLCBlcnJvcilcbiAgICBzZXRFcnJvcignRXJyb3IgYWNjZXNzaW5nIGNhbWVyYSBvciBzY2FubmluZyBRUiBjb2RlLiBQbGVhc2UgY2hlY2sgY2FtZXJhIHBlcm1pc3Npb25zLicpXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwibWluLWgtc2NyZWVuIGJnLWdyYXktMTAwIGZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHAtNFwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWF4LXctbWQgbXgtYXV0byBiZy13aGl0ZSByb3VuZGVkLWxnIHNoYWRvdy1sZyBwLTZcIj5cbiAgICAgICAgey8qIEhlYWRlciAqL31cbiAgICAgICAgPGgxIGNsYXNzTmFtZT1cInRleHQtM3hsIGZvbnQtYm9sZCB0ZXh0LWNlbnRlciB0ZXh0LWdyYXktODAwIG1iLThcIj5cbiAgICAgICAgICBRUiBDb2RlIFNjYW5uZXJcbiAgICAgICAgPC9oMT5cblxuICAgICAgICB7LyogU2Nhbm5lciBDb250YWluZXIgKi99XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWItNlwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmVsYXRpdmUgdy1mdWxsIGFzcGVjdC1zcXVhcmUgYmctYmxhY2sgcm91bmRlZC1sZyBvdmVyZmxvdy1oaWRkZW5cIj5cbiAgICAgICAgICAgIDxTY2FubmVyXG4gICAgICAgICAgICAgIG9uU2Nhbj17aGFuZGxlU2Nhbn1cbiAgICAgICAgICAgICAgb25FcnJvcj17aGFuZGxlRXJyb3J9XG4gICAgICAgICAgICAgIGNvbnN0cmFpbnRzPXt7XG4gICAgICAgICAgICAgICAgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JyxcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgZm9ybWF0cz17Wydxcl9jb2RlJ119XG4gICAgICAgICAgICAgIHNjYW5EZWxheT17NTAwfVxuICAgICAgICAgICAgICBzdHlsZXM9e3tcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IHtcbiAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHZpZGVvOiB7XG4gICAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICBvYmplY3RGaXQ6ICdjb3ZlcicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIHsvKiBFcnJvciBNZXNzYWdlICovfVxuICAgICAgICB7ZXJyb3IgJiYgKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWItNCBiZy1yZWQtNTAgYm9yZGVyIGJvcmRlci1yZWQtMjAwIHJvdW5kZWQtbGcgcC00XCI+XG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXJlZC02MDAgdGV4dC1zbSB0ZXh0LWNlbnRlclwiPntlcnJvcn08L3A+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG5cbiAgICAgICAgey8qIFJlc3VsdCBTZWN0aW9uICovfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLWdyYXktNTAgcm91bmRlZC1sZyBwLTRcIj5cbiAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LXNlbWlib2xkIHRleHQtZ3JheS03MDAgbWItMlwiPlxuICAgICAgICAgICAgU2NhbiBSZXN1bHQ6XG4gICAgICAgICAgPC9oMj5cbiAgICAgICAgICB7cmVzdWx0ID8gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy13aGl0ZSBib3JkZXIgcm91bmRlZCBwLTNcIj5cbiAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTgwMCBicmVhay1hbGxcIj57cmVzdWx0fTwvcD5cbiAgICAgICAgICAgICAge3Jlc3VsdC5zdGFydHNXaXRoKCdodHRwJykgJiYgKFxuICAgICAgICAgICAgICAgIDxhXG4gICAgICAgICAgICAgICAgICBocmVmPXtyZXN1bHR9XG4gICAgICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgICAgICAgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJpbmxpbmUtYmxvY2sgbXQtMiB0ZXh0LWJsdWUtNjAwIGhvdmVyOnRleHQtYmx1ZS04MDAgdW5kZXJsaW5lIHRleHQtc21cIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIE9wZW4gTGlua1xuICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNTAwIGl0YWxpY1wiPlxuICAgICAgICAgICAgICBQb2ludCB5b3VyIGNhbWVyYSBhdCBhIFFSIGNvZGUgdG8gc2NhbiBpdFxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICl9XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIHsvKiBJbnN0cnVjdGlvbnMgKi99XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtNiB0ZXh0LWNlbnRlclwiPlxuICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ncmF5LTYwMFwiPlxuICAgICAgICAgICAgSG9sZCB5b3VyIGRldmljZSBzdGVhZHkgYW5kIHBvaW50IHRoZSBjYW1lcmEgYXQgYSBRUiBjb2RlXG4gICAgICAgICAgPC9wPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59Il0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJTY2FubmVyIiwiSG9tZSIsInJlc3VsdCIsInNldFJlc3VsdCIsImVycm9yIiwic2V0RXJyb3IiLCJoYW5kbGVTY2FuIiwibGVuZ3RoIiwicmF3VmFsdWUiLCJoYW5kbGVFcnJvciIsImNvbnNvbGUiLCJkaXYiLCJjbGFzc05hbWUiLCJoMSIsIm9uU2NhbiIsIm9uRXJyb3IiLCJjb25zdHJhaW50cyIsImZhY2luZ01vZGUiLCJmb3JtYXRzIiwic2NhbkRlbGF5Iiwic3R5bGVzIiwiY29udGFpbmVyIiwid2lkdGgiLCJoZWlnaHQiLCJ2aWRlbyIsIm9iamVjdEZpdCIsInAiLCJoMiIsInN0YXJ0c1dpdGgiLCJhIiwiaHJlZiIsInRhcmdldCIsInJlbCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@yudiel/react-qr-scanner/dist/index.esm.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@yudiel/react-qr-scanner/dist/index.esm.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Scanner: () => (/* binding */ k),\n/* harmony export */   boundingBox: () => (/* binding */ f),\n/* harmony export */   centerText: () => (/* binding */ u),\n/* harmony export */   outline: () => (/* binding */ N),\n/* harmony export */   prepareZXingModule: () => (/* reexport safe */ barcode_detector__WEBPACK_IMPORTED_MODULE_2__.prepareZXingModule),\n/* harmony export */   setZXingModuleOverrides: () => (/* reexport safe */ barcode_detector__WEBPACK_IMPORTED_MODULE_2__.setZXingModuleOverrides),\n/* harmony export */   useDevices: () => (/* binding */ K)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var webrtc_adapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! webrtc-adapter */ \"(app-pages-browser)/./node_modules/webrtc-adapter/src/js/adapter_core.js\");\n/* harmony import */ var barcode_detector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! barcode-detector */ \"(app-pages-browser)/./node_modules/barcode-detector/dist/es/index.js\");\nfunction a(o){const{onClick:e,disabled:g,className:t}=o,i={cursor:g?\"default\":\"pointer\",stroke:g?\"grey\":\"yellow\",strokeLineJoin:\"round\",strokeLineCap:\"round\",strokeWidth:1.5,...o.style};return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\",{onClick:g?void 0:e,className:t,style:i,width:\"28px\",height:\"28px\",viewBox:\"0 0 24 24\",fill:\"none\",xmlns:\"http://www.w3.org/2000/svg\"},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\",{d:\"M3 3L6.00007 6.00007M21 21L19.8455 19.8221M9.74194 4.06811C9.83646 4.04279 9.93334 4.02428 10.0319 4.01299C10.1453 4 10.2683 4 10.5141 4H13.5327C13.7786 4 13.9015 4 14.015 4.01299C14.6068 4.08078 15.1375 4.40882 15.4628 4.90782C15.5252 5.00345 15.5802 5.11345 15.6901 5.33333C15.7451 5.44329 15.7726 5.49827 15.8037 5.54609C15.9664 5.79559 16.2318 5.95961 16.5277 5.9935C16.5844 6 16.6459 6 16.7688 6H17.8234C18.9435 6 19.5036 6 19.9314 6.21799C20.3077 6.40973 20.6137 6.71569 20.8055 7.09202C21.0234 7.51984 21.0234 8.0799 21.0234 9.2V15.3496M19.8455 19.8221C19.4278 20 18.8702 20 17.8234 20H6.22344C5.10333 20 4.54328 20 4.11546 19.782C3.73913 19.5903 3.43317 19.2843 3.24142 18.908C3.02344 18.4802 3.02344 17.9201 3.02344 16.8V9.2C3.02344 8.0799 3.02344 7.51984 3.24142 7.09202C3.43317 6.71569 3.73913 6.40973 4.11546 6.21799C4.51385 6.015 5.0269 6.00103 6.00007 6.00007M19.8455 19.8221L14.5619 14.5619M14.5619 14.5619C14.0349 15.4243 13.0847 16 12 16C10.3431 16 9 14.6569 9 13C9 11.9153 9.57566 10.9651 10.4381 10.4381M14.5619 14.5619L10.4381 10.4381M10.4381 10.4381L6.00007 6.00007\"}))}function B(o){const{onClick:e,disabled:g,className:t}=o,i={cursor:g?\"default\":\"pointer\",stroke:g?\"grey\":\"yellow\",strokeLineJoin:\"round\",strokeLineCap:\"round\",strokeWidth:1.5,...o.style};return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\",{onClick:g?void 0:e,className:t,style:i,width:\"28px\",height:\"28px\",viewBox:\"0 0 24 24\",fill:\"none\",xmlns:\"http://www.w3.org/2000/svg\"},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\",{d:\"M12 16C13.6569 16 15 14.6569 15 13C15 11.3431 13.6569 10 12 10C10.3431 10 9 11.3431 9 13C9 14.6569 10.3431 16 12 16Z\"}),react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\",{d:\"M3 16.8V9.2C3 8.0799 3 7.51984 3.21799 7.09202C3.40973 6.71569 3.71569 6.40973 4.09202 6.21799C4.51984 6 5.0799 6 6.2 6H7.25464C7.37758 6 7.43905 6 7.49576 5.9935C7.79166 5.95961 8.05705 5.79559 8.21969 5.54609C8.25086 5.49827 8.27836 5.44328 8.33333 5.33333C8.44329 5.11342 8.49827 5.00346 8.56062 4.90782C8.8859 4.40882 9.41668 4.08078 10.0085 4.01299C10.1219 4 10.2448 4 10.4907 4H13.5093C13.7552 4 13.8781 4 13.9915 4.01299C14.5833 4.08078 15.1141 4.40882 15.4394 4.90782C15.5017 5.00345 15.5567 5.11345 15.6667 5.33333C15.7216 5.44329 15.7491 5.49827 15.7803 5.54609C15.943 5.79559 16.2083 5.95961 16.5042 5.9935C16.561 6 16.6224 6 16.7454 6H17.8C18.9201 6 19.4802 6 19.908 6.21799C20.2843 6.40973 20.5903 6.71569 20.782 7.09202C21 7.51984 21 8.0799 21 9.2V16.8C21 17.9201 21 18.4802 20.782 18.908C20.5903 19.2843 20.2843 19.5903 19.908 19.782C19.4802 20 18.9201 20 17.8 20H6.2C5.0799 20 4.51984 20 4.09202 19.782C3.71569 19.5903 3.40973 19.2843 3.21799 18.908C3 18.4802 3 17.9201 3 16.8Z\"}))}function r(e){const{scanning:g,startScanning:t,stopScanning:i}=e,[w,n]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1);function r(){n(!0),g?i():t(),setTimeout((()=>n(!1)),1e3)}return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{style:{bottom:85,right:8,position:\"absolute\",zIndex:2,cursor:w?\"default\":\"pointer\"}},g?react__WEBPACK_IMPORTED_MODULE_0__.createElement(a,{disabled:w,onClick:r}):react__WEBPACK_IMPORTED_MODULE_0__.createElement(B,{disabled:w,onClick:r}))}function s(o){const{onClick:e,className:g,style:t}=o;return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\",{onClick:e,width:\"30px\",height:\"30px\",viewBox:\"0 0 24 24\",className:g,style:t,xmlns:\"http://www.w3.org/2000/svg\"},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\",{strokeWidth:.2,stroke:\"yellow\",fill:\"yellow\",d:\"M13.225 9l5.025-7h-7.972l-3.3 11h5.359l-2.452 8.648.75.364L20.374 9zm.438 3H8.322l2.7-9H16.3l-5.025 7h7.101l-6.7 8.953z\"}))}function C(o){const{onClick:e,className:g,style:t}=o;return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\",{onClick:e,width:\"30px\",height:\"30px\",viewBox:\"0 0 24 24\",className:g,style:t,xmlns:\"http://www.w3.org/2000/svg\"},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\",{strokeWidth:.2,stroke:\"yellow\",fill:\"yellow\",d:\"M14.516 15.158l.714.714-4.595 6.14-.75-.364L12.337 13H6.978L8.22 8.861l.803.803L8.322 12h3.036l1.793 1.792-1.475 5.16zm5.984 4.05L4.793 3.5l.707-.707 3.492 3.492L10.278 2h7.972l-5.025 7h7.149l-3.71 4.957 4.543 4.543zM12.707 10l3.243 3.243L18.376 10zM9.795 7.088l2.079 2.079L16.3 3h-5.278z\"}))}function E(o){const{status:e,scanning:g,torchToggle:t}=o;function i(A){t(A)}return g&&t?react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{style:{bottom:35,right:8,position:\"absolute\",zIndex:2,cursor:\"pointer\"}},e?react__WEBPACK_IMPORTED_MODULE_0__.createElement(C,{onClick:()=>i(!1)}):react__WEBPACK_IMPORTED_MODULE_0__.createElement(s,{onClick:()=>i(!0)})):null}function c(o){const{onClick:e,className:g,disabled:t=!1}=o,i={cursor:t?\"default\":\"pointer\",stroke:t?\"grey\":\"yellow\",fill:t?\"grey\":\"yellow\",...o.style};return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\",{onClick:t?void 0:e,width:\"30px\",height:\"30px\",viewBox:\"0 0 24 24\",className:g,style:i,xmlns:\"http://www.w3.org/2000/svg\"},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\",{strokeWidth:.3,d:\"M16.279,17.039c-1.396,1.209 -3.216,1.941 -5.206,1.941c-4.393,0 -7.96,-3.567 -7.96,-7.96c-0,-4.393 3.567,-7.96 7.96,-7.96c4.393,0 7.96,3.567 7.96,7.96c-0,2.044 -0.772,3.909 -2.04,5.319l0.165,0.165c1.194,1.194 2.388,2.388 3.583,3.582c0.455,0.456 -0.252,1.163 -0.707,0.708l-3.755,-3.755Zm1.754,-6.019c-0,-3.841 -3.119,-6.96 -6.96,-6.96c-3.842,0 -6.96,3.119 -6.96,6.96c-0,3.841 3.118,6.96 6.96,6.96c3.841,0 6.96,-3.119 6.96,-6.96Zm-7.46,0.5l-1.5,0c-0.645,0 -0.643,-1 -0,-1l1.5,0l-0,-1.5c-0,-0.645 1,-0.643 1,0l-0,1.5l1.5,0c0.645,0 0.643,1 -0,1l-1.5,0l-0,1.5c-0,0.645 -1,0.643 -1,0l-0,-1.5Z\"}))}function h(o){const{onClick:e,className:g,disabled:t=!1}=o,i={cursor:t?\"default\":\"pointer\",stroke:t?\"grey\":\"yellow\",fill:t?\"grey\":\"yellow\",...o.style};return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\",{onClick:t?void 0:e,width:\"30px\",height:\"30px\",viewBox:\"0 0 24 24\",className:g,style:i,xmlns:\"http://www.w3.org/2000/svg\"},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\",{strokeWidth:.3,d:\"M16.279,17.039c-1.396,1.209 -3.216,1.941 -5.206,1.941c-4.393,0 -7.96,-3.567 -7.96,-7.96c-0,-4.393 3.567,-7.96 7.96,-7.96c4.393,0 7.96,3.567 7.96,7.96c-0,2.044 -0.772,3.909 -2.04,5.319l0.165,0.165c1.194,1.194 2.388,2.388 3.583,3.582c0.455,0.456 -0.252,1.163 -0.707,0.708l-3.755,-3.755Zm1.754,-6.019c-0,-3.841 -3.119,-6.96 -6.96,-6.96c-3.842,0 -6.96,3.119 -6.96,6.96c-0,3.841 3.118,6.96 6.96,6.96c3.841,0 6.96,-3.119 6.96,-6.96Zm-4.96,-0.5c0.645,0 0.643,1 -0,1l-4,0c-0.645,0 -0.643,-1 -0,-1l4,0Z\"}))}function q(o){const{scanning:g,capabilities:t,onZoom:i,value:w}=o;if(!g||!i)return null;const n=(t.max-t.min)/3;return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{style:{bottom:130,right:8,position:\"absolute\",zIndex:2,cursor:\"pointer\"}},react__WEBPACK_IMPORTED_MODULE_0__.createElement(h,{disabled:w<=t.min,onClick:function(){i(Math.max(w-n,t.min))}})),react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{style:{bottom:180,right:8,position:\"absolute\",zIndex:2,cursor:\"pointer\"}},react__WEBPACK_IMPORTED_MODULE_0__.createElement(c,{disabled:w>=t.max,onClick:function(){i(Math.min(w+n,t.max))}})))}const l={fullContainer:{width:\"100%\",height:\"100%\",position:\"relative\",display:\"flex\",alignItems:\"center\",justifyContent:\"center\",overflow:\"hidden\"},innerContainer:{width:\"100%\",height:\"100%\",display:\"flex\",alignItems:\"center\",justifyContent:\"center\",position:\"relative\"},overlay:{position:\"absolute\",top:0,right:0,bottom:0,left:0,pointerEvents:\"none\",display:\"flex\",alignItems:\"center\",justifyContent:\"center\"},borderBox:{position:\"relative\",width:\"70%\",aspectRatio:\"1 / 1\",border:\"2px dashed rgba(239, 68, 68, 0.4)\",borderRadius:\"0.5rem\"},cornerTopLeft:{position:\"absolute\",width:\"15%\",height:\"15%\",border:\"4px solid #ef4444\",top:0,left:0,borderBottomColor:\"transparent\",borderRightColor:\"transparent\",borderTopLeftRadius:\"0.5rem\"},cornerTopRight:{position:\"absolute\",width:\"15%\",height:\"15%\",border:\"4px solid #ef4444\",top:0,right:0,borderBottomColor:\"transparent\",borderLeftColor:\"transparent\",borderTopRightRadius:\"0.5rem\"},cornerBottomLeft:{position:\"absolute\",width:\"15%\",height:\"15%\",border:\"4px solid #ef4444\",bottom:0,left:0,borderTopColor:\"transparent\",borderRightColor:\"transparent\",borderBottomLeftRadius:\"0.5rem\"},cornerBottomRight:{position:\"absolute\",width:\"15%\",height:\"15%\",border:\"4px solid #ef4444\",bottom:0,right:0,borderTopColor:\"transparent\",borderLeftColor:\"transparent\",borderBottomRightRadius:\"0.5rem\"}};function M(o){const{scanning:e,capabilities:g,onOff:t,torch:i,zoom:w,startScanning:n,stopScanning:a}=o;return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{style:l.fullContainer},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{style:l.innerContainer},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{style:l.overlay},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{style:l.borderBox},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{style:l.cornerTopLeft}),react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{style:l.cornerTopRight}),react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{style:l.cornerBottomLeft}),react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{style:l.cornerBottomRight}))),t&&react__WEBPACK_IMPORTED_MODULE_0__.createElement(r,{scanning:e,startScanning:n,stopScanning:a}),i&&g.torch&&react__WEBPACK_IMPORTED_MODULE_0__.createElement(E,{scanning:e,status:i.status,torchToggle:i.toggle}),w&&g.zoom&&react__WEBPACK_IMPORTED_MODULE_0__.createElement(q,{scanning:e,capabilities:g.zoom,value:w.value,onZoom:w.onChange})))}const G=\"data:audio/mp3;base64,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\";var I=A=>A instanceof Date,Y=A=>null==A;const D=A=>\"object\"==typeof A;var F=A=>!Y(A)&&!Array.isArray(A)&&D(A)&&!I(A),T=A=>Y(A)||!D(A);function m(A,o){if(T(A)||T(o))return A===o;if(I(A)&&I(o))return A.getTime()===o.getTime();const e=Object.keys(A),g=Object.keys(o);if(e.length!==g.length)return!1;for(const t of e){const e=A[t];if(!g.includes(t))return!1;if(\"ref\"!==t){const A=o[t];if(I(e)&&I(A)||F(e)&&F(A)||Array.isArray(e)&&Array.isArray(A)?!m(e,A):e!==A)return!1}}return!0}const V={facingMode:\"environment\",width:{min:640,ideal:720,max:1920},height:{min:640,ideal:720,max:1080}},Q={finder:!0,torch:!0,tracker:void 0,onOff:!1,zoom:!1},R={width:\"100%\",height:\"100%\",position:\"relative\",display:\"flex\",alignItems:\"center\",justifyContent:\"center\",overflow:\"hidden\",aspectRatio:\"1/1\"},d={width:\"100%\",height:\"100%\",objectFit:\"cover\",overflow:\"hidden\"};function N(A,o){for(const e of A){const[A,...g]=e.cornerPoints;o.lineWidth=2,o.strokeStyle=\"yellow\",o.beginPath(),o.moveTo(A.x,A.y);for(const{x:A,y:e}of g)o.lineTo(A,e);o.lineTo(A.x,A.y),o.closePath(),o.stroke()}}function f(A,o){for(const e of A){const{boundingBox:{x:A,y:g,width:t,height:i}}=e;o.lineWidth=2,o.strokeStyle=\"yellow\",o.strokeRect(A,g,t,i)}}function u(A,o){A.forEach((A=>{const{boundingBox:e,rawValue:g}=A,t=e.x+e.width/2,i=e.y+e.height/2,w=Math.max(12,50*e.width/o.canvas.width),n=w;let a;o.font=`${w}px sans-serif`,o.textAlign=\"left\";try{a=JSON.stringify(JSON.parse(g),null,2)}catch(A){a=g}const B=a.split(\"\\n\"),r=Math.max(...B.map((A=>o.measureText(A).width))),s=B.length*n,C=t-r/2-10,E=i-s/2-10,c=r+20,h=s+10;o.beginPath(),o.moveTo(C+8,E),o.lineTo(C+c-8,E),o.quadraticCurveTo(C+c,E,C+c,E+8),o.lineTo(C+c,E+h-8),o.quadraticCurveTo(C+c,E+h,C+c-8,E+h),o.lineTo(C+8,E+h),o.quadraticCurveTo(C,E+h,C,E+h-8),o.lineTo(C,E+8),o.quadraticCurveTo(C,E,C+8,E),o.closePath(),o.fillStyle=\"rgba(255, 255, 0, 0.9)\",o.fill(),B.forEach(((A,e)=>{const g=i+e*n-(B.length-1)*n/2;let w=t-r/2,a=0;const s=[...A.matchAll(/\"([^\"]+)\":/g)],C=[...A.matchAll(/:\\s*(\"[^\"]*\"|\\d+|true|false|null)/g)];s.forEach(((e,t)=>{var i,n;const B=e[0].replace(\":\",\"\"),r=A.substring(a,e.index);if(o.fillStyle=\"black\",o.fillText(r,w,g),w+=o.measureText(r).width,o.fillStyle=\"blue\",o.fillText(B,w,g),w+=o.measureText(B).width,a=e.index+B.length,o.fillStyle=\"black\",o.fillText(\": \",w,g),w+=o.measureText(\": \").width,t<C.length){const e=C[t],B=A.substring(a,e.index);o.fillStyle=\"black\",o.fillText(B,w,g),w+=o.measureText(B).width;const r=null!==(n=null===(i=e[0].match(/:\\s*(.*)/))||void 0===i?void 0:i[1])&&void 0!==n?n:\"\";o.fillStyle=\"green\",o.fillText(r,w,g),w+=o.measureText(r).width,a=e.index+e[0].length}})),o.fillStyle=\"black\";const E=A.substring(a);o.fillText(E,w,g)}))}))}function p(A){if(null===A)throw new Error(\"Canvas should always be defined when component is mounted.\");const o=A.getContext(\"2d\");if(null===o)throw new Error(\"Canvas 2D context should be non-null\");o.clearRect(0,0,A.width,A.height)}function k(e){var a;const{onScan:B,constraints:r,formats:s=[\"qr_code\"],paused:C=!1,components:E,children:c,styles:h,classNames:q,allowMultiple:l,scanDelay:I,onError:Y,sound:D}=e,F=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),T=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),N=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),f=(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)((()=>({...V,...r})),[r]),u=(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)((()=>({...Q,...E})),[E]),[k,K]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1),[y,L]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!0),[J,x]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(f),U=function(){const A=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(Promise.resolve({type:\"stop\",data:{}})),e=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),w=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),[n,a]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({}),[B,r]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({}),s=(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((async(A,o)=>{var g,t,i;if(!window.isSecureContext)throw new Error(\"camera access is only permitted in secure context. Use HTTPS or localhost rather than HTTP.\");if(void 0===(null===(g=null===navigator||void 0===navigator?void 0:navigator.mediaDevices)||void 0===g?void 0:g.getUserMedia))throw new Error(\"this browser has no Stream API support\");const n=await navigator.mediaDevices.getUserMedia({audio:!1,video:o});void 0!==A.srcObject?A.srcObject=n:void 0!==A.mozSrcObject?A.mozSrcObject=n:window.URL.createObjectURL?A.src=window.URL.createObjectURL(n):window.webkitURL?A.src=window.webkitURL.createObjectURL(n):A.src=n.id,await Promise.race([A.play(),new Promise((A=>setTimeout(A,3e3))).then((()=>{throw new Error(\"Loading camera stream timed out after 3 seconds.\")}))]),await new Promise((A=>setTimeout(A,500)));const[B]=n.getVideoTracks();return r(B.getSettings()),a(null!==(i=null===(t=null==B?void 0:B.getCapabilities)||void 0===t?void 0:t.call(B))&&void 0!==i?i:{}),e.current=n,w.current=B,{type:\"start\",data:{videoEl:A,stream:n,constraints:o}}}),[]),C=(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((async(A,o)=>{A.src=\"\",A.srcObject=null,A.load();for(const A of o.getTracks())o.removeTrack(A),A.stop();return e.current=null,w.current=null,r({}),{type:\"stop\",data:{}}}),[]),E=(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((async(o,{constraints:e,restart:g=!1})=>{if(A.current=A.current.then((A=>{if(\"start\"===A.type){const{data:{videoEl:t,stream:i,constraints:w}}=A;return g||o!==t||e!==w?C(t,i).then((()=>s(o,e))):A}return s(o,e)})),\"stop\"===(await A.current).type)throw new Error(\"Something went wrong with the camera task queue (start task).\")}),[s,C]),c=(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((async()=>{if(A.current=A.current.then((A=>{if(\"stop\"===A.type)return A;const{data:{videoEl:o,stream:e}}=A;return C(o,e)})),\"start\"===(await A.current).type)throw new Error(\"Something went wrong with the camera task queue (stop task).\")}),[C]),h=(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((async A=>{const o=w.current;if(!o)throw new Error(\"No active video track found.\");{A.advanced&&A.advanced[0].zoom&&o.getCapabilities().torch&&await o.applyConstraints({advanced:[{torch:!1}]}),await o.applyConstraints(A);const e=o.getCapabilities(),g=o.getSettings();a(e),r(g)}}),[]);return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>()=>{(async()=>{await c()})()}),[c]),{capabilities:n,settings:B,startCamera:E,stopCamera:c,updateConstraints:h}}(),{startScanning:Z,stopScanning:W}=function(A){const{videoElementRef:o,onScan:e,onFound:w,retryDelay:a=100,scanDelay:B=0,formats:r=[],allowMultiple:s=!1,sound:C=!0}=A,E=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new barcode_detector__WEBPACK_IMPORTED_MODULE_2__.BarcodeDetector({formats:r})),c=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),h=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{E.current=new barcode_detector__WEBPACK_IMPORTED_MODULE_2__.BarcodeDetector({formats:r})}),[r]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{\"undefined\"!=typeof window&&C&&(c.current=new Audio(\"string\"==typeof C?C:G))}),[C]);const q=(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((A=>async g=>{if(null!==o.current&&o.current.readyState>1){const{lastScan:t,contentBefore:i,lastScanHadContent:n}=A;if(g-t<a)h.current=window.requestAnimationFrame(q(A));else{const t=await E.current.detect(o.current),a=t.some((A=>!i.includes(A.rawValue))),r=t.length>0;let l=A.lastOnScan;(a||s&&r&&g-l>=B)&&(C&&c.current&&c.current.paused&&c.current.play().catch((A=>console.error(\"Error playing the sound\",A))),l=g,e(t)),r&&w(t),!r&&n&&w(t);const M={lastScan:g,lastOnScan:l,lastScanHadContent:r,contentBefore:a?t.map((A=>A.rawValue)):i};h.current=window.requestAnimationFrame(q(M))}}}),[o.current,e,w,a]);return{startScanning:(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((()=>{const A=performance.now(),o={lastScan:A,lastOnScan:A,contentBefore:[],lastScanHadContent:!1};h.current=window.requestAnimationFrame(q(o))}),[q]),stopScanning:(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((()=>{null!==h.current&&(window.cancelAnimationFrame(h.current),h.current=null)}),[])}}({videoElementRef:F,onScan:B,onFound:A=>function(A,o,e,g){const t=e;if(null==t)throw new Error(\"onFound handler should only be called when component is mounted. Thus tracking canvas is always defined.\");const i=o;if(null==i)throw new Error(\"onFound handler should only be called when component is mounted. Thus video element is always defined.\");if(0===A.length||void 0===g)p(t);else{const o=i.offsetWidth,e=i.offsetHeight,w=i.videoWidth,n=i.videoHeight,a=Math.max(o/w,e/n),B=w*a,r=n*a,s=B/w,C=r/n,E=(o-B)/2,c=(e-r)/2,h=({x:A,y:o})=>({x:Math.floor(A*s),y:Math.floor(o*C)}),q=({x:A,y:o})=>({x:Math.floor(A+E),y:Math.floor(o+c)}),l=A.map((A=>{const{boundingBox:o,cornerPoints:e}=A,{x:g,y:t}=q(h({x:o.x,y:o.y})),{x:i,y:w}=h({x:o.width,y:o.height});return{...A,cornerPoints:e.map((A=>q(h(A)))),boundingBox:DOMRectReadOnly.fromRect({x:g,y:t,width:i,height:w})}}));t.width=i.offsetWidth,t.height=i.offsetHeight;const M=t.getContext(\"2d\");if(null===M)throw new Error(\"onFound handler should only be called when component is mounted. Thus tracking canvas 2D context is always defined.\");g(l,M)}}(A,F.current,N.current,u.tracker),formats:s,retryDelay:void 0===u.tracker?500:10,scanDelay:I,allowMultiple:l,sound:D});(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>(K(!0),()=>{K(!1)})),[]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{k&&(W(),Z())}),[null==E?void 0:E.tracker]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{if(!m(f,J)){const A=f;(null==r?void 0:r.deviceId)&&delete A.facingMode,x(A)}}),[r]);const v=(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)((()=>({constraints:J,shouldStream:k&&!C})),[J,k,C]),b=async()=>{const A=F.current;if(null==A)throw new Error(\"Video should be defined when component is mounted.\");const o=T.current;if(null==o)throw new Error(\"Canvas should be defined when component is mounted.\");const e=o.getContext(\"2d\");if(null==e)throw new Error(\"Canvas should be defined when component is mounted.\");if(v.shouldStream){await U.stopCamera(),L(!1);try{await U.startCamera(A,v),A?L(!0):await U.stopCamera()}catch(A){null==Y||Y(A),console.error(\"error\",A)}}else o.width=A.videoWidth,o.height=A.videoHeight,e.drawImage(A,0,0,A.videoWidth,A.videoHeight),await U.stopCamera(),L(!1)};(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{(async()=>{await b()})()}),[v]);const O=(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)((()=>v.shouldStream&&y),[v.shouldStream,y]);return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{if(O){if(void 0===T.current)throw new Error(\"shouldScan effect should only be triggered when component is mounted. Thus pause frame canvas is defined\");if(p(T.current),void 0===N.current)throw new Error(\"shouldScan effect should only be triggered when component is mounted. Thus tracking canvas is defined\");p(N.current);const A=F.current;if(null==A)throw new Error(\"shouldScan effect should only be triggered when component is mounted. Thus video element is defined\");Z()}}),[O]),react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{style:{...R,...null==h?void 0:h.container},className:null==q?void 0:q.container},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"video\",{ref:F,style:{...d,...null==h?void 0:h.video,visibility:C?\"hidden\":\"visible\"},className:null==q?void 0:q.video,autoPlay:!0,muted:!0,playsInline:!0}),react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"canvas\",{ref:T,style:{display:C?\"block\":\"none\",position:\"absolute\",width:\"100%\",height:\"100%\"}}),react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"canvas\",{ref:N,style:{position:\"absolute\",width:\"100%\",height:\"100%\"}}),react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{style:{position:\"absolute\",width:\"100%\",height:\"100%\"}},u.finder&&react__WEBPACK_IMPORTED_MODULE_0__.createElement(M,{scanning:y,capabilities:U.capabilities,onOff:u.onOff,zoom:u.zoom&&U.settings.zoom?{value:U.settings.zoom,onChange:async A=>{const o={...J,advanced:[{zoom:A}]};await U.updateConstraints(o)}}:void 0,torch:u.torch?{status:null!==(a=U.settings.torch)&&void 0!==a&&a,toggle:async A=>{const o={...J,advanced:[{torch:A}]};await U.updateConstraints(o)}}:void 0,startScanning:async()=>await b(),stopScanning:async()=>{await U.stopCamera(),p(N.current),L(!1)}}),c))}function K(){const[A,e]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{(async()=>{e(await async function(){return(await navigator.mediaDevices.enumerateDevices()).filter((({kind:A})=>\"videoinput\"===A))}())})()}),[]),A}\n//# sourceMappingURL=index.esm.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AeXVkaWVsL3JlYWN0LXFyLXNjYW5uZXIvZGlzdC9pbmRleC5lc20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBOFAsY0FBYyxNQUFNLGlDQUFpQyxNQUFNLCtIQUErSCxPQUFPLGdEQUFlLFFBQVEscUlBQXFJLENBQUMsZ0RBQWUsU0FBUyxta0NBQW1rQyxHQUFHLGNBQWMsTUFBTSxpQ0FBaUMsTUFBTSwrSEFBK0gsT0FBTyxnREFBZSxRQUFRLHFJQUFxSSxDQUFDLGdEQUFlLFNBQVMseUhBQXlILEVBQUUsZ0RBQWUsU0FBUyxzK0JBQXMrQixHQUFHLGNBQWMsTUFBTSwwQ0FBMEMsU0FBUywrQ0FBQyxLQUFLLGFBQWEsNENBQTRDLE9BQU8sZ0RBQWUsUUFBUSxPQUFPLDZFQUE2RSxHQUFHLGdEQUFlLElBQUkscUJBQXFCLEVBQUUsZ0RBQWUsSUFBSSxxQkFBcUIsR0FBRyxjQUFjLE1BQU0sOEJBQThCLEdBQUcsT0FBTyxnREFBZSxRQUFRLGdIQUFnSCxDQUFDLGdEQUFlLFNBQVMseUtBQXlLLEdBQUcsY0FBYyxNQUFNLDhCQUE4QixHQUFHLE9BQU8sZ0RBQWUsUUFBUSxnSEFBZ0gsQ0FBQyxnREFBZSxTQUFTLGtWQUFrVixHQUFHLGNBQWMsTUFBTSxrQ0FBa0MsR0FBRyxjQUFjLEtBQUssWUFBWSxnREFBZSxRQUFRLE9BQU8saUVBQWlFLEdBQUcsZ0RBQWUsSUFBSSxrQkFBa0IsRUFBRSxnREFBZSxJQUFJLGtCQUFrQixRQUFRLGNBQWMsTUFBTSxvQ0FBb0MsTUFBTSx5RkFBeUYsT0FBTyxnREFBZSxRQUFRLHlIQUF5SCxDQUFDLGdEQUFlLFNBQVMsNmxCQUE2bEIsR0FBRyxjQUFjLE1BQU0sb0NBQW9DLE1BQU0seUZBQXlGLE9BQU8sZ0RBQWUsUUFBUSx5SEFBeUgsQ0FBQyxnREFBZSxTQUFTLGlnQkFBaWdCLEdBQUcsY0FBYyxNQUFNLDJDQUEyQyxHQUFHLHNCQUFzQix3QkFBd0Is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QUksbUZBQW1GLHlDQUF5QyxTQUFTLGdCQUFnQixPQUFPLEdBQUcsOEJBQThCLHVCQUF1QixtRUFBbUUsU0FBUyxnQkFBZ0IsUUFBUSxHQUFHLDhCQUE4QixnRUFBZ0UseUNBQXlDLE1BQU0sYUFBYSxXQUFXLCtDQUFDLEtBQUssT0FBTyxnREFBQyxPQUFPLFdBQVcseUJBQXlCLGtFQUFrRSxPQUFPLHNCQUFzQixJQUFJLElBQUksUUFBMkY7QUFDMW1wRCIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQHl1ZGllbC9yZWFjdC1xci1zY2FubmVyL2Rpc3QvaW5kZXguZXNtLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQSx7dXNlU3RhdGUgYXMgbyxGcmFnbWVudCBhcyBlLHVzZVJlZiBhcyBnLHVzZUNhbGxiYWNrIGFzIHQsdXNlRWZmZWN0IGFzIGksdXNlTWVtbyBhcyB3fWZyb21cInJlYWN0XCI7aW1wb3J0XCJ3ZWJydGMtYWRhcHRlclwiO2ltcG9ydHtCYXJjb2RlRGV0ZWN0b3IgYXMgbn1mcm9tXCJiYXJjb2RlLWRldGVjdG9yXCI7ZXhwb3J0e3ByZXBhcmVaWGluZ01vZHVsZSxzZXRaWGluZ01vZHVsZU92ZXJyaWRlc31mcm9tXCJiYXJjb2RlLWRldGVjdG9yXCI7ZnVuY3Rpb24gYShvKXtjb25zdHtvbkNsaWNrOmUsZGlzYWJsZWQ6ZyxjbGFzc05hbWU6dH09byxpPXtjdXJzb3I6Zz9cImRlZmF1bHRcIjpcInBvaW50ZXJcIixzdHJva2U6Zz9cImdyZXlcIjpcInllbGxvd1wiLHN0cm9rZUxpbmVKb2luOlwicm91bmRcIixzdHJva2VMaW5lQ2FwOlwicm91bmRcIixzdHJva2VXaWR0aDoxLjUsLi4uby5zdHlsZX07cmV0dXJuIEEuY3JlYXRlRWxlbWVudChcInN2Z1wiLHtvbkNsaWNrOmc/dm9pZCAwOmUsY2xhc3NOYW1lOnQsc3R5bGU6aSx3aWR0aDpcIjI4cHhcIixoZWlnaHQ6XCIyOHB4XCIsdmlld0JveDpcIjAgMCAyNCAyNFwiLGZpbGw6XCJub25lXCIseG1sbnM6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wifSxBLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIse2Q6XCJNMyAzTDYuMDAwMDcgNi4wMDAwN00yMSAyMUwxOS44NDU1IDE5LjgyMjFNOS43NDE5NCA0LjA2ODExQzkuODM2NDYgNC4wNDI3OSA5LjkzMzM0IDQuMDI0MjggMTAuMDMxOSA0LjAxMjk5QzEwLjE0NTMgNCAxMC4yNjgzIDQgMTAuNTE0MSA0SDEzLjUzMjdDMTMuNzc4NiA0IDEzLjkwMTUgNCAxNC4wMTUgNC4wMTI5OUMxNC42MDY4IDQuMDgwNzggMTUuMTM3NSA0LjQwODgyIDE1LjQ2MjggNC45MDc4MkMxNS41MjUyIDUuMDAzNDUgMTUuNTgwMiA1LjExMzQ1IDE1LjY5MDEgNS4zMzMzM0MxNS43NDUxIDUuNDQzMjkgMTUuNzcyNiA1LjQ5ODI3IDE1LjgwMzcgNS41NDYwOUMxNS45NjY0IDUuNzk1NTkgMTYuMjMxOCA1Ljk1OTYxIDE2LjUyNzcgNS45OTM1QzE2LjU4NDQgNiAxNi42NDU5IDYgMTYuNzY4OCA2SDE3LjgyMzRDMTguOTQzNSA2IDE5LjUwMzYgNiAxOS45MzE0IDYuMjE3OTlDMjAuMzA3NyA2LjQwOTczIDIwLjYxMzcgNi43MTU2OSAyMC44MDU1IDcuMDkyMDJDMjEuMDIzNCA3LjUxOTg0IDIxLjAyMzQgOC4wNzk5IDIxLjAyMzQgOS4yVjE1LjM0OTZNMTkuODQ1NSAxOS44MjIxQzE5LjQyNzggMjAgMTguODcwMiAyMCAxNy44MjM0IDIwSDYuMjIzNDRDNS4xMDMzMyAyMCA0LjU0MzI4IDIwIDQuMTE1NDYgMTkuNzgyQzMuNzM5MTMgMTkuNTkwMyAzLjQzMzE3IDE5LjI4NDMgMy4yNDE0MiAxOC45MDhDMy4wMjM0NCAxOC40ODAyIDMuMDIzNDQgMTcuOTIwMSAzLjAyMzQ0IDE2LjhWOS4yQzMuMDIzNDQgOC4wNzk5IDMuMDIzNDQgNy41MTk4NCAzLjI0MTQyIDcuMDkyMDJDMy40MzMxNyA2LjcxNTY5IDMuNzM5MTMgNi40MDk3MyA0LjExNTQ2IDYuMjE3OTlDNC41MTM4NSA2LjAxNSA1LjAyNjkgNi4wMDEwMyA2LjAwMDA3IDYuMDAwMDdNMTkuODQ1NSAxOS44MjIxTDE0LjU2MTkgMTQuNTYxOU0xNC41NjE5IDE0LjU2MTlDMTQuMDM0OSAxNS40MjQzIDEzLjA4NDcgMTYgMTIgMTZDMTAuMzQzMSAxNiA5IDE0LjY1NjkgOSAxM0M5IDExLjkxNTMgOS41NzU2NiAxMC45NjUxIDEwLjQzODEgMTAuNDM4MU0xNC41NjE5IDE0LjU2MTlMMTAuNDM4MSAxMC40MzgxTTEwLjQzODEgMTAuNDM4MUw2LjAwMDA3IDYuMDAwMDdcIn0pKX1mdW5jdGlvbiBCKG8pe2NvbnN0e29uQ2xpY2s6ZSxkaXNhYmxlZDpnLGNsYXNzTmFtZTp0fT1vLGk9e2N1cnNvcjpnP1wiZGVmYXVsdFwiOlwicG9pbnRlclwiLHN0cm9rZTpnP1wiZ3JleVwiOlwieWVsbG93XCIsc3Ryb2tlTGluZUpvaW46XCJyb3VuZFwiLHN0cm9rZUxpbmVDYXA6XCJyb3VuZFwiLHN0cm9rZVdpZHRoOjEuNSwuLi5vLnN0eWxlfTtyZXR1cm4gQS5jcmVhdGVFbGVtZW50KFwic3ZnXCIse29uQ2xpY2s6Zz92b2lkIDA6ZSxjbGFzc05hbWU6dCxzdHlsZTppLHdpZHRoOlwiMjhweFwiLGhlaWdodDpcIjI4cHhcIix2aWV3Qm94OlwiMCAwIDI0IDI0XCIsZmlsbDpcIm5vbmVcIix4bWxuczpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJ9LEEuY3JlYXRlRWxlbWVudChcInBhdGhcIix7ZDpcIk0xMiAxNkMxMy42NTY5IDE2IDE1IDE0LjY1NjkgMTUgMTNDMTUgMTEuMzQzMSAxMy42NTY5IDEwIDEyIDEwQzEwLjM0MzEgMTAgOSAxMS4zNDMxIDkgMTNDOSAxNC42NTY5IDEwLjM0MzEgMTYgMTIgMTZaXCJ9KSxBLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIse2Q6XCJNMyAxNi44VjkuMkMzIDguMDc5OSAzIDcuNTE5ODQgMy4yMTc5OSA3LjA5MjAyQzMuNDA5NzMgNi43MTU2OSAzLjcxNTY5IDYuNDA5NzMgNC4wOTIwMiA2LjIxNzk5QzQuNTE5ODQgNiA1LjA3OTkgNiA2LjIgNkg3LjI1NDY0QzcuMzc3NTggNiA3LjQzOTA1IDYgNy40OTU3NiA1Ljk5MzVDNy43OTE2NiA1Ljk1OTYxIDguMDU3MDUgNS43OTU1OSA4LjIxOTY5IDUuNTQ2MDlDOC4yNTA4NiA1LjQ5ODI3IDguMjc4MzYgNS40NDMyOCA4LjMzMzMzIDUuMzMzMzNDOC40NDMyOSA1LjExMzQyIDguNDk4MjcgNS4wMDM0NiA4LjU2MDYyIDQuOTA3ODJDOC44ODU5IDQuNDA4ODIgOS40MTY2OCA0LjA4MDc4IDEwLjAwODUgNC4wMTI5OUMxMC4xMjE5IDQgMTAuMjQ0OCA0IDEwLjQ5MDcgNEgxMy41MDkzQzEzLjc1NTIgNCAxMy44NzgxIDQgMTMuOTkxNSA0LjAxMjk5QzE0LjU4MzMgNC4wODA3OCAxNS4xMTQxIDQuNDA4ODIgMTUuNDM5NCA0LjkwNzgyQzE1LjUwMTcgNS4wMDM0NSAxNS41NTY3IDUuMTEzNDUgMTUuNjY2NyA1LjMzMzMzQzE1LjcyMTYgNS40NDMyOSAxNS43NDkxIDUuNDk4MjcgMTUuNzgwMyA1LjU0NjA5QzE1Ljk0MyA1Ljc5NTU5IDE2LjIwODMgNS45NTk2MSAxNi41MDQyIDUuOTkzNUMxNi41NjEgNiAxNi42MjI0IDYgMTYuNzQ1NCA2SDE3LjhDMTguOTIwMSA2IDE5LjQ4MDIgNiAxOS45MDggNi4yMTc5OUMyMC4yODQzIDYuNDA5NzMgMjAuNTkwMyA2LjcxNTY5IDIwLjc4MiA3LjA5MjAyQzIxIDcuNTE5ODQgMjEgOC4wNzk5IDIxIDkuMlYxNi44QzIxIDE3LjkyMDEgMjEgMTguNDgwMiAyMC43ODIgMTguOTA4QzIwLjU5MDMgMTkuMjg0MyAyMC4yODQzIDE5LjU5MDMgMTkuOTA4IDE5Ljc4MkMxOS40ODAyIDIwIDE4LjkyMDEgMjAgMTcuOCAyMEg2LjJDNS4wNzk5IDIwIDQuNTE5ODQgMjAgNC4wOTIwMiAxOS43ODJDMy43MTU2OSAxOS41OTAzIDMuNDA5NzMgMTkuMjg0MyAzLjIxNzk5IDE4LjkwOEMzIDE4LjQ4MDIgMyAxNy45MjAxIDMgMTYuOFpcIn0pKX1mdW5jdGlvbiByKGUpe2NvbnN0e3NjYW5uaW5nOmcsc3RhcnRTY2FubmluZzp0LHN0b3BTY2FubmluZzppfT1lLFt3LG5dPW8oITEpO2Z1bmN0aW9uIHIoKXtuKCEwKSxnP2koKTp0KCksc2V0VGltZW91dCgoKCk9Pm4oITEpKSwxZTMpfXJldHVybiBBLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7c3R5bGU6e2JvdHRvbTo4NSxyaWdodDo4LHBvc2l0aW9uOlwiYWJzb2x1dGVcIix6SW5kZXg6MixjdXJzb3I6dz9cImRlZmF1bHRcIjpcInBvaW50ZXJcIn19LGc/QS5jcmVhdGVFbGVtZW50KGEse2Rpc2FibGVkOncsb25DbGljazpyfSk6QS5jcmVhdGVFbGVtZW50KEIse2Rpc2FibGVkOncsb25DbGljazpyfSkpfWZ1bmN0aW9uIHMobyl7Y29uc3R7b25DbGljazplLGNsYXNzTmFtZTpnLHN0eWxlOnR9PW87cmV0dXJuIEEuY3JlYXRlRWxlbWVudChcInN2Z1wiLHtvbkNsaWNrOmUsd2lkdGg6XCIzMHB4XCIsaGVpZ2h0OlwiMzBweFwiLHZpZXdCb3g6XCIwIDAgMjQgMjRcIixjbGFzc05hbWU6ZyxzdHlsZTp0LHhtbG5zOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIn0sQS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtzdHJva2VXaWR0aDouMixzdHJva2U6XCJ5ZWxsb3dcIixmaWxsOlwieWVsbG93XCIsZDpcIk0xMy4yMjUgOWw1LjAyNS03aC03Ljk3MmwtMy4zIDExaDUuMzU5bC0yLjQ1MiA4LjY0OC43NS4zNjRMMjAuMzc0IDl6bS40MzggM0g4LjMyMmwyLjctOUgxNi4zbC01LjAyNSA3aDcuMTAxbC02LjcgOC45NTN6XCJ9KSl9ZnVuY3Rpb24gQyhvKXtjb25zdHtvbkNsaWNrOmUsY2xhc3NOYW1lOmcsc3R5bGU6dH09bztyZXR1cm4gQS5jcmVhdGVFbGVtZW50KFwic3ZnXCIse29uQ2xpY2s6ZSx3aWR0aDpcIjMwcHhcIixoZWlnaHQ6XCIzMHB4XCIsdmlld0JveDpcIjAgMCAyNCAyNFwiLGNsYXNzTmFtZTpnLHN0eWxlOnQseG1sbnM6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wifSxBLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIse3N0cm9rZVdpZHRoOi4yLHN0cm9rZTpcInllbGxvd1wiLGZpbGw6XCJ5ZWxsb3dcIixkOlwiTTE0LjUxNiAxNS4xNThsLjcxNC43MTQtNC41OTUgNi4xNC0uNzUtLjM2NEwxMi4zMzcgMTNINi45NzhMOC4yMiA4Ljg2MWwuODAzLjgwM0w4LjMyMiAxMmgzLjAzNmwxLjc5MyAxLjc5Mi0xLjQ3NSA1LjE2em01Ljk4NCA0LjA1TDQuNzkzIDMuNWwuNzA3LS43MDcgMy40OTIgMy40OTJMMTAuMjc4IDJoNy45NzJsLTUuMDI1IDdoNy4xNDlsLTMuNzEgNC45NTcgNC41NDMgNC41NDN6TTEyLjcwNyAxMGwzLjI0MyAzLjI0M0wxOC4zNzYgMTB6TTkuNzk1IDcuMDg4bDIuMDc5IDIuMDc5TDE2LjMgM2gtNS4yNzh6XCJ9KSl9ZnVuY3Rpb24gRShvKXtjb25zdHtzdGF0dXM6ZSxzY2FubmluZzpnLHRvcmNoVG9nZ2xlOnR9PW87ZnVuY3Rpb24gaShBKXt0KEEpfXJldHVybiBnJiZ0P0EuY3JlYXRlRWxlbWVudChcImRpdlwiLHtzdHlsZTp7Ym90dG9tOjM1LHJpZ2h0OjgscG9zaXRpb246XCJhYnNvbHV0ZVwiLHpJbmRleDoyLGN1cnNvcjpcInBvaW50ZXJcIn19LGU/QS5jcmVhdGVFbGVtZW50KEMse29uQ2xpY2s6KCk9PmkoITEpfSk6QS5jcmVhdGVFbGVtZW50KHMse29uQ2xpY2s6KCk9PmkoITApfSkpOm51bGx9ZnVuY3Rpb24gYyhvKXtjb25zdHtvbkNsaWNrOmUsY2xhc3NOYW1lOmcsZGlzYWJsZWQ6dD0hMX09byxpPXtjdXJzb3I6dD9cImRlZmF1bHRcIjpcInBvaW50ZXJcIixzdHJva2U6dD9cImdyZXlcIjpcInllbGxvd1wiLGZpbGw6dD9cImdyZXlcIjpcInllbGxvd1wiLC4uLm8uc3R5bGV9O3JldHVybiBBLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIix7b25DbGljazp0P3ZvaWQgMDplLHdpZHRoOlwiMzBweFwiLGhlaWdodDpcIjMwcHhcIix2aWV3Qm94OlwiMCAwIDI0IDI0XCIsY2xhc3NOYW1lOmcsc3R5bGU6aSx4bWxuczpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJ9LEEuY3JlYXRlRWxlbWVudChcInBhdGhcIix7c3Ryb2tlV2lkdGg6LjMsZDpcIk0xNi4yNzksMTcuMDM5Yy0xLjM5NiwxLjIwOSAtMy4yMTYsMS45NDEgLTUuMjA2LDEuOTQxYy00LjM5MywwIC03Ljk2LC0zLjU2NyAtNy45NiwtNy45NmMtMCwtNC4zOTMgMy41NjcsLTcuOTYgNy45NiwtNy45NmM0LjM5MywwIDcuOTYsMy41NjcgNy45Niw3Ljk2Yy0wLDIuMDQ0IC0wLjc3MiwzLjkwOSAtMi4wNCw1LjMxOWwwLjE2NSwwLjE2NWMxLjE5NCwxLjE5NCAyLjM4OCwyLjM4OCAzLjU4MywzLjU4MmMwLjQ1NSwwLjQ1NiAtMC4yNTIsMS4xNjMgLTAuNzA3LDAuNzA4bC0zLjc1NSwtMy43NTVabTEuNzU0LC02LjAxOWMtMCwtMy44NDEgLTMuMTE5LC02Ljk2IC02Ljk2LC02Ljk2Yy0zLjg0MiwwIC02Ljk2LDMuMTE5IC02Ljk2LDYuOTZjLTAsMy44NDEgMy4xMTgsNi45NiA2Ljk2LDYuOTZjMy44NDEsMCA2Ljk2LC0zLjExOSA2Ljk2LC02Ljk2Wm0tNy40NiwwLjVsLTEuNSwwYy0wLjY0NSwwIC0wLjY0MywtMSAtMCwtMWwxLjUsMGwtMCwtMS41Yy0wLC0wLjY0NSAxLC0wLjY0MyAxLDBsLTAsMS41bDEuNSwwYzAuNjQ1LDAgMC42NDMsMSAtMCwxbC0xLjUsMGwtMCwxLjVjLTAsMC42NDUgLTEsMC42NDMgLTEsMGwtMCwtMS41WlwifSkpfWZ1bmN0aW9uIGgobyl7Y29uc3R7b25DbGljazplLGNsYXNzTmFtZTpnLGRpc2FibGVkOnQ9ITF9PW8saT17Y3Vyc29yOnQ/XCJkZWZhdWx0XCI6XCJwb2ludGVyXCIsc3Ryb2tlOnQ/XCJncmV5XCI6XCJ5ZWxsb3dcIixmaWxsOnQ/XCJncmV5XCI6XCJ5ZWxsb3dcIiwuLi5vLnN0eWxlfTtyZXR1cm4gQS5jcmVhdGVFbGVtZW50KFwic3ZnXCIse29uQ2xpY2s6dD92b2lkIDA6ZSx3aWR0aDpcIjMwcHhcIixoZWlnaHQ6XCIzMHB4XCIsdmlld0JveDpcIjAgMCAyNCAyNFwiLGNsYXNzTmFtZTpnLHN0eWxlOmkseG1sbnM6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wifSxBLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIse3N0cm9rZVdpZHRoOi4zLGQ6XCJNMTYuMjc5LDE3LjAzOWMtMS4zOTYsMS4yMDkgLTMuMjE2LDEuOTQxIC01LjIwNiwxLjk0MWMtNC4zOTMsMCAtNy45NiwtMy41NjcgLTcuOTYsLTcuOTZjLTAsLTQuMzkzIDMuNTY3LC03Ljk2IDcuOTYsLTcuOTZjNC4zOTMsMCA3Ljk2LDMuNTY3IDcuOTYsNy45NmMtMCwyLjA0NCAtMC43NzIsMy45MDkgLTIuMDQsNS4zMTlsMC4xNjUsMC4xNjVjMS4xOTQsMS4xOTQgMi4zODgsMi4zODggMy41ODMsMy41ODJjMC40NTUsMC40NTYgLTAuMjUyLDEuMTYzIC0wLjcwNywwLjcwOGwtMy43NTUsLTMuNzU1Wm0xLjc1NCwtNi4wMTljLTAsLTMuODQxIC0zLjExOSwtNi45NiAtNi45NiwtNi45NmMtMy44NDIsMCAtNi45NiwzLjExOSAtNi45Niw2Ljk2Yy0wLDMuODQxIDMuMTE4LDYuOTYgNi45Niw2Ljk2YzMuODQxLDAgNi45NiwtMy4xMTkgNi45NiwtNi45NlptLTQuOTYsLTAuNWMwLjY0NSwwIDAuNjQzLDEgLTAsMWwtNCwwYy0wLjY0NSwwIC0wLjY0MywtMSAtMCwtMWw0LDBaXCJ9KSl9ZnVuY3Rpb24gcShvKXtjb25zdHtzY2FubmluZzpnLGNhcGFiaWxpdGllczp0LG9uWm9vbTppLHZhbHVlOnd9PW87aWYoIWd8fCFpKXJldHVybiBudWxsO2NvbnN0IG49KHQubWF4LXQubWluKS8zO3JldHVybiBBLmNyZWF0ZUVsZW1lbnQoZSxudWxsLEEuY3JlYXRlRWxlbWVudChcImRpdlwiLHtzdHlsZTp7Ym90dG9tOjEzMCxyaWdodDo4LHBvc2l0aW9uOlwiYWJzb2x1dGVcIix6SW5kZXg6MixjdXJzb3I6XCJwb2ludGVyXCJ9fSxBLmNyZWF0ZUVsZW1lbnQoaCx7ZGlzYWJsZWQ6dzw9dC5taW4sb25DbGljazpmdW5jdGlvbigpe2koTWF0aC5tYXgody1uLHQubWluKSl9fSkpLEEuY3JlYXRlRWxlbWVudChcImRpdlwiLHtzdHlsZTp7Ym90dG9tOjE4MCxyaWdodDo4LHBvc2l0aW9uOlwiYWJzb2x1dGVcIix6SW5kZXg6MixjdXJzb3I6XCJwb2ludGVyXCJ9fSxBLmNyZWF0ZUVsZW1lbnQoYyx7ZGlzYWJsZWQ6dz49dC5tYXgsb25DbGljazpmdW5jdGlvbigpe2koTWF0aC5taW4odytuLHQubWF4KSl9fSkpKX1jb25zdCBsPXtmdWxsQ29udGFpbmVyOnt3aWR0aDpcIjEwMCVcIixoZWlnaHQ6XCIxMDAlXCIscG9zaXRpb246XCJyZWxhdGl2ZVwiLGRpc3BsYXk6XCJmbGV4XCIsYWxpZ25JdGVtczpcImNlbnRlclwiLGp1c3RpZnlDb250ZW50OlwiY2VudGVyXCIsb3ZlcmZsb3c6XCJoaWRkZW5cIn0saW5uZXJDb250YWluZXI6e3dpZHRoOlwiMTAwJVwiLGhlaWdodDpcIjEwMCVcIixkaXNwbGF5OlwiZmxleFwiLGFsaWduSXRlbXM6XCJjZW50ZXJcIixqdXN0aWZ5Q29udGVudDpcImNlbnRlclwiLHBvc2l0aW9uOlwicmVsYXRpdmVcIn0sb3ZlcmxheTp7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDowLHJpZ2h0OjAsYm90dG9tOjAsbGVmdDowLHBvaW50ZXJFdmVudHM6XCJub25lXCIsZGlzcGxheTpcImZsZXhcIixhbGlnbkl0ZW1zOlwiY2VudGVyXCIsanVzdGlmeUNvbnRlbnQ6XCJjZW50ZXJcIn0sYm9yZGVyQm94Ontwb3NpdGlvbjpcInJlbGF0aXZlXCIsd2lkdGg6XCI3MCVcIixhc3BlY3RSYXRpbzpcIjEgLyAxXCIsYm9yZGVyOlwiMnB4IGRhc2hlZCByZ2JhKDIzOSwgNjgsIDY4LCAwLjQpXCIsYm9yZGVyUmFkaXVzOlwiMC41cmVtXCJ9LGNvcm5lclRvcExlZnQ6e3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix3aWR0aDpcIjE1JVwiLGhlaWdodDpcIjE1JVwiLGJvcmRlcjpcIjRweCBzb2xpZCAjZWY0NDQ0XCIsdG9wOjAsbGVmdDowLGJvcmRlckJvdHRvbUNvbG9yOlwidHJhbnNwYXJlbnRcIixib3JkZXJSaWdodENvbG9yOlwidHJhbnNwYXJlbnRcIixib3JkZXJUb3BMZWZ0UmFkaXVzOlwiMC41cmVtXCJ9LGNvcm5lclRvcFJpZ2h0Ontwb3NpdGlvbjpcImFic29sdXRlXCIsd2lkdGg6XCIxNSVcIixoZWlnaHQ6XCIxNSVcIixib3JkZXI6XCI0cHggc29saWQgI2VmNDQ0NFwiLHRvcDowLHJpZ2h0OjAsYm9yZGVyQm90dG9tQ29sb3I6XCJ0cmFuc3BhcmVudFwiLGJvcmRlckxlZnRDb2xvcjpcInRyYW5zcGFyZW50XCIsYm9yZGVyVG9wUmlnaHRSYWRpdXM6XCIwLjVyZW1cIn0sY29ybmVyQm90dG9tTGVmdDp7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHdpZHRoOlwiMTUlXCIsaGVpZ2h0OlwiMTUlXCIsYm9yZGVyOlwiNHB4IHNvbGlkICNlZjQ0NDRcIixib3R0b206MCxsZWZ0OjAsYm9yZGVyVG9wQ29sb3I6XCJ0cmFuc3BhcmVudFwiLGJvcmRlclJpZ2h0Q29sb3I6XCJ0cmFuc3BhcmVudFwiLGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6XCIwLjVyZW1cIn0sY29ybmVyQm90dG9tUmlnaHQ6e3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix3aWR0aDpcIjE1JVwiLGhlaWdodDpcIjE1JVwiLGJvcmRlcjpcIjRweCBzb2xpZCAjZWY0NDQ0XCIsYm90dG9tOjAscmlnaHQ6MCxib3JkZXJUb3BDb2xvcjpcInRyYW5zcGFyZW50XCIsYm9yZGVyTGVmdENvbG9yOlwidHJhbnNwYXJlbnRcIixib3JkZXJCb3R0b21SaWdodFJhZGl1czpcIjAuNXJlbVwifX07ZnVuY3Rpb24gTShvKXtjb25zdHtzY2FubmluZzplLGNhcGFiaWxpdGllczpnLG9uT2ZmOnQsdG9yY2g6aSx6b29tOncsc3RhcnRTY2FubmluZzpuLHN0b3BTY2FubmluZzphfT1vO3JldHVybiBBLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7c3R5bGU6bC5mdWxsQ29udGFpbmVyfSxBLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7c3R5bGU6bC5pbm5lckNvbnRhaW5lcn0sQS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse3N0eWxlOmwub3ZlcmxheX0sQS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse3N0eWxlOmwuYm9yZGVyQm94fSxBLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7c3R5bGU6bC5jb3JuZXJUb3BMZWZ0fSksQS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse3N0eWxlOmwuY29ybmVyVG9wUmlnaHR9KSxBLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7c3R5bGU6bC5jb3JuZXJCb3R0b21MZWZ0fSksQS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse3N0eWxlOmwuY29ybmVyQm90dG9tUmlnaHR9KSkpLHQmJkEuY3JlYXRlRWxlbWVudChyLHtzY2FubmluZzplLHN0YXJ0U2Nhbm5pbmc6bixzdG9wU2Nhbm5pbmc6YX0pLGkmJmcudG9yY2gmJkEuY3JlYXRlRWxlbWVudChFLHtzY2FubmluZzplLHN0YXR1czppLnN0YXR1cyx0b3JjaFRvZ2dsZTppLnRvZ2dsZX0pLHcmJmcuem9vbSYmQS5jcmVhdGVFbGVtZW50KHEse3NjYW5uaW5nOmUsY2FwYWJpbGl0aWVzOmcuem9vbSx2YWx1ZTp3LnZhbHVlLG9uWm9vbTp3Lm9uQ2hhbmdlfSkpKX1jb25zdCBHPVwiZGF0YTphdWRpby9tcDM7YmFzZTY0LC8vUGtaQUFoZ2hFMEFLVG9BSnJhL24wRlF5Z0FBQUdJa1lKZ21DWVhCTUFBR0NUSnozemhDRU0vL3ovLzFoei8vOE1NTU1OMDhzc1Y2ZTVERFdJUXJlQWdDdkZLeThiWGdJS01rVUREQmd6SndJQnRrUk1RQW9jeElGZHhnaFFHS0RvRXppQXpReE9CT2RIOTJpL2lHaSt6RENBRUlYNDZhNzNIclN5Ylp3MXgzSlpqWHA3ZFNOeS9QNjhyamNidDdwN2Zha01QNUxWTXl6Q2FqMXBqdmVqWVlBSURnREd6RUNqRUFrMUpsMzU1OUhJb244aHpsZlBWVEN2R0paemZjS1N4WGZ5TVdNODgvLzlWS1N4WGR0bmI5dm9tT3V1UnlpV1ZZYmYrWDh6cDZmS0dISWR5Y3VXTU1NTU1NS1NucCs2d3NZYy85Zi83ejdyUFBXSE41NTZwNmZQOE1NTVAvLy9QUFAvNytHSEs5UFQ2cDdmL3VubGRQMm5wN1llSGp3ZWlZQTRHTE5BZ0FpSTd1NTduNS8vb2M1L3lmazZ6bk9jUGh3T0J3Z2dIQ01wQTRIQTRLRXlIT2M1em5PK2hQSWM1Ly8rZnFKaDhYUVBoOTBKVTV4UWluT2YvLzg3L3p2UCtnZ0FZdWhDS0h4ZEErSHhkMEVBNEtLSEE0Y2lCM2tPWGZYQi9nbWY4cC9COTZsQU1LQWdBQURVK0J1akFSSGd3ZGlzZ0hNZkFVSEFpY2VCZzRBU0JnWkJpQklCSDRaYUhPSnNMaGY4UitIWUVjaUlnWVN3ai8rQmk3RXFCaCtBY0JuNVA2Qmg0VHVCbXJBTUJpWkg3Z2FMRVdnZXcvL1BrWkZNbHllazYwTXBZQVNoenFxWmhtNmdDVVdlRVVXQWV3RVdZR040WDRHREVQd0dFOFM0R0RvT0lHQVlLZ0lRT2t6Ly9nR0FSQVVCK0N3R3hUd01BQUNBRWd5QXdkQWxBeEtoekF4WGlaLy8vQXhjRXdBd0pqREF6aUNBQXdRZ2RBd1JnZEFzSlFEQW1BY0d6WUR3QWhaSUFLQWNJUUI0R1Q5VFFNSjkvNEdpMUZ2L0FjQVlVcUtCQXdHZ05Bd1ZCQUF3R2h3QXdkQmxBeEZnMUF3bGd6QXdOQnVBa0pRREJnRUVERXFHRUNnQ2hGZ0JnTC8vQ0lzd1lZSC8vK0hLQ3BrNEswQzlBYUtLQ0FPQmVNY1I0WDlDNDRCd0FCQ2dHQXNHWUNnVHdIQWNBd1hBaUF3U0FRVi8vL0NKUDlsd01CUUF3QUFBV0dvNWxWTENjYWVuZVZoSkFWR2FpMy8vaW9hVUVmLy9nYVRBWUdDajhCbkV3ZnJJcURjc0lRYi92bWhVLzhmQXMwRzhZR0d3S1NUOElnajRHQ0FUaXBrc1Z6WThwLy85MEZXSndoNDVBa1gvLzRmQ0Y5d01FZ2tMM3VRYytnYkdKOHQ0TUJBTUJQL2hFWGY5RlJ1V0JjQWZJRmpZelFkb0xDQndoN0lXVmx4YVgvdzhvTUNQLytFUVQ1cG9HQjFJcjkwRGhpVjZhZi9qRllCcFQyQmdvUXl5dDJNMFRvQmRFYVp5enQ4blRvM3hkTkRDVFNkLy9vNkYwNkNqb294UnI0alZGLzBiT0tENk9NVU5EUnhpTVVWRlIwRkZRUGhHWFJqRHByNE1BRUE0d0lRVWhZT0l3Ly9Qa1pFNG5yZzA4c094NEFDUTBDb3BEMmFBQWx3VFRCeFFlTWN3ZDh3OGdaVEFnQUJYd0dBQk9renBJMHdBUUFFeG5XZlA0eDhaakt1bldkWjFvMVFlNmxGR0tDTlVMT1JRQ0VMQUFQblJVZi9HSXgvMEZIR2ZvM1NkWjBxUDJjdWtYS0xsUnRCS0ZnQVF3Q2t3SmdGUllCRUVBVG1Ec0xTWTJRaVFZQ0VuRXJhK1VabzZGMWFLTVJyNkdob2FQLytqLy9vditpK2hqTHFCZ01rWW9xQ2hvbzFHcUNqb1kwNlRwUnFqakxPWXpSUm1NdWl6bWdkS2hkRjhralRBQUFQTUN3R3N3emdsZ3dBSmZ6cXhtaW9LSC8vLy8vLy8vLy8vLy8raWpMT0F3Rm1OMGYvLy8vLy8vLy9RLy8vOFpqUC85REdZeUZ3SURCZUIzTUE0QWxCV2lkS001c3B5a0FVQVFPQ2FrSyt1ZEdxTjhWRFlqVFJ1Ti8vMGJWWC8vNktpbzR4UUZ2Ly9uZi8va0tPb0FFSUI2U1k2aGN4ZW5wODUvLy80L0RFUGYvODRYdmw0dkY0ZHd0eGZFSmdDWVFITVNnS0NST3A0K2ZuLy8vL0w0dFFmMHVuejg5T2VjTHhlTDB1bDA5eTZlbnpwNGRJaEtBUUZBNWhLZkx1MW5VNy9XcjcxclJLSlVCUVNVVnQvLy8vbDA4R1VQVldnQUFZQWVOS3N4YlFOQUFoUXgzL29LR01NNmRaMVl5NnNhak1iZktpbzdsTmN2MHNTY1o0N2xOY3czMmVrVkZNUDlmcC9mK21rbEk2YXQ2dS9kQk1RdVc2eStDNUJjZ3dBQS8vUGtaRW9tR2cxSFlHZTByaVdzQ3FiRXdpWTBCSkZKTXhyQ2N4R2dRMlZLOHh4Q0Yxd3NBQmdRQkJnUUJBWUFGQ2tZQ2dBTGtLNGZKMDBFNWN0Sk4xVXh5NWF1M1hvR2NNNGRTTjBFWVp3emhXMFdDaDFQWnd6aG5GRlF4dG5iTzJkMEt0NkNkWGJydWdna1RFWDVSczRURVFVVnNkVlhhQ2N1V1hJQlFVR213bWdvQUdjSmlNNGRTaW9IUWRCbkVZK2hqY2Jvdi8vamNiLzQzRzQzRy9qQ1JpYmZ4dWdkQm5EcVVMTzJkdXZRdW16dG5jYm80eEdLS054dWdvb3hHSXhRVUxvT2dGZ1VNVEEvamJyeGlNRG1FVEwrZUxoY1BUaHpPZWVPWmZMNWZJY0JZdVhEL09Idjh0Ly9MSkZ4anhRWUhIS0RHRmtaTXRsbUtNMFJnUWZiVnR4RklIYlFCRFJ1elJndUVJMWM5WFovcldtclpmVlUzT2MvOXV0Tk55Z1JRa0NvSGxBWXN0Tk42REoxSUlOcG9JTnBwditXRy8rZzJtbW5VbW1tcEJBb0pJSmhud0I1eGt5bW42MDZEZi90MDAweGhVMDNVWEM1T2w4dUZ5WHkrWHkvbDh2NXc0Y0xrNFhBdndBWVV2bC9RTDVmVGRsS1prRUVFRUd1bWFLYVgwMHpJT2VtZjZDSC8vL3l3STNMS3BpUTJFZjR4WVdNU0R5STBYd3ppa3BMMGFqVkhaM2o5REdJamV1WGNOZmpuOTYvUy9UVXovWC92WC8vLy81Sy9yK3Y3Sm4rTGxBb0daT0lRSXdNS0JRTS95cHBLWVVSbWhHWmtSMmIvL1BrWkUwbUhnMUhFRzh3eWlEN21sd0F5RFU4bkpIaTVodGFrWm1aR05pUmNwa0poQm1VbVpZUWNNMVZERUVCZ2dORFYvQVNFWlJZS0ZaSWhrWEtMbEttazdJVlRLbVpOSjVLaGlxVlVxcFgrazcrcWxWS3lWL1pJcVpERkRXVEpsRnlpNVRKcEtoaVhLQlF5WnpJUzVKaEJvYXlWL0FRV1ZwR1drY1lUVjVPL3JJVlN2OC8wbmtyK3Y2L3Z5Ui9YOWYxL1pOOGtmNS9uOTkvbitmNS9sVEttZjkvbVJQOHlGVXFwV1N2NHlKVXFwWDlrai9NbVpOSjVLL3ovUDlKNVAvdjZ5RlV6L0NFb3l3Z1VNcVprei9Gc3NFQ0lzVnEwYVBSclJSYXRGRkZ5a1FaSjJVa2wvLy81S2pta3NPYUE3QUxST0pMRG5Fc0xicTNHVE1WcndiLzBkR3ptTTBEbGZCbEhRT21yZFIwTVlpOTJUWDZiL2NtREhMY2x5VVZZTy80TzhzRlRLRlRLRmY4eWhVeWhVeWhYektsREtsQ3NyLytaVW9WbFNzci8rWlFxWlVvWlVvY2VNZmNvWlVvWlVvVmxmT1BHY21ESEtjcHluS2c5eVhKY3IzSmNseVhKY2x5WU8rRFhKY2x5Zmd4RlpWYjNLY3FEL2cyTXh6c1k3Mkw5THViUFIwZEN5ZjVLNU5OZCtUdjlHWFJkVjBYSmNseWZjbC9uK2s4a2Y2U1gvaVZ5bnZYZi8vLzRNZy8xT2t4Z3VZem1NNWpNY0xITXh3d0doZ05Dd1hNTEFjd01YVExpMU1EN3c3dG1UZEJ2TW1FMHhRRnpDd0hNREFkLy9Qa1pHTXBpZ2ttQUdPVXZDZlRnY2dBdUMrSVRzd01GekM0b01MaFlNQnluMHh2VStwOVRyMHhVeGYvMHh2Ly8vMVBCWURoZ05URlRGVEdUR1RHVEdUR1RHVEdUR0M0R1RGTURBY0xBZE1WTVZNVUxBY01CcGdZRGhjREdGd3NZWEZCaWtMR0Z3TUdBNE1CeGdjREtmVEVNVW9BeDJCaXNEK21LcDVUdjFPa3hreGt4a3hreGt4a3hreGxPMHhWUEppLzZudi8vLy9VN0N3SFRGVEZUR1RHVEdUR1UrcDcxUHBqSmlwaWhZRHBpcGkvNm4xT3YvL0M0R0M0R1RHVEdUR1RGVThXQlNaZExoV0IvL3lLbG90eUxaRmlMZjh0eXlSVWlwRlNLa1ZHUkJaUU1pV0MzeXgvL3d4VUdLc1N2REZRR0hVQUwzUU1zSERGSVlwQ1l5MkJtYWd5NkJqTGd5NkJoM29kNThEQ0xBaXpCZ1JiK0VRaXlFUWl3R0JGdURBaTMvLy8vLzIwUXFTQkpmL3FjdW12Ly8vLy93TVpkR1hBWU11MWdZeTZNdUJFWmRCZ3k0QmpMZ3k2QmpMZ3k2QmpMZ3k2QmpMUXk2REJsejJjSkRMZ1JHWEFNWmRHWEFZTXVoTVpjQ0l5NnNKR2FvR011cHB3TlJsM1dCakxneTYzd2lFV0F3SXQvK0VRaTBJaEZzRENMQWkwR0JGa0dCRmdNSkNxYXFZQWdBWUloQkJ2d2Y3a3djcVJxN1YzSWN0YWN2bE42TnhxZ29veFJSdU5SaWlqRVpqTUdSdU12ejlGR296USsxWDJxZTFUMVMvLytWaGFXQXRLd3RNTC8vUGtaRUlrYmdjYUFIYzF4Q0pyamVBQXRmdVVBdExBV2YvLy9tV2VQSDk1WkZnc3lzc3ZNODgranpPNksrejdPTTQ4c0grV0Rpd2VaeDVZT0srenhXTEdKV3NhNnhhZEF2MDJmVFpMU3BzRnB2TFNnYTB0TWdXZ1VnV213Z1VteVdsOHRNZ1dXbUxTb0ZKc29GbHBTd3NteUJnNEhoRWRnd0hBWVBCd0dEZ2VCZzhId01IZzREQjRQQmdPQXdjT3dNSEx3RG41bEF3Y0RnaURnWUR3TUhBLzRNQjMvLytFUWVEQWR3aUR3WUxQaEVXUVlMT0RCWUVSWkJndDhJaTM0R0xCYUI1cGZBWjBGdkVBUS9VZnd4VUxseCtJWHgrOGY1Q0VMSDhmeEtoQUlERm9IQkVEUmMzLy8vL2d3SGdhUlhnTUhZTUIyRVUvZ3daL2dZYnczZ1kzUWJnWU5nYmdZaUFiZ3dOMy8rRVFiQkVHNE1CdURBYkF3RzRSQnRBd2JnMi8vLy8rQjlCNkYvLy8vLy8vLy8vaEVkRC8vLy8vLy8vLy84RFJhaEVRR0NJbk1OZzNMQkVsZ05qRGNpQ3dHL2xnTml3R3hXRy8vL21HNGJmLytXQTNLdzNLeUlNTncyS3czTU5nM01OZzNNTmlJTWlRMk9LMHhNaUEzS3lKTEFFWmdSQVJtQkVERVlGd0JCZ0VnRWVvbW93b2w1WUFKS3dDREFJQUo4c0FFK2dHQmdDSllBUVVaLzEzTHViTXU1ZHlpWU9BaEt3RUZHZjlBT296L2c0Q0ZBSW9sL2xnQWp5c0Fnc0FFbFlCUC8vLy9sZ0prc0JNLy9sZ1JVeEYvL1BrWkdBcGdnc0lBSHQyd2lOTG9nZ0FxQ3o4UkZTd0lxWWlvaXBrakVqSENDU04vK1dKZzVpWU9ZbVBLNWtybVRtWms1bVo4c1RKWW1mOHlKaU5pSWlzaS95d1JtUmtaa1pHWkdSbVJFUmtSRVpFUkdSRVJrUkVaRVJHeEVmLy8vaEVUSU1FeUJpWkV5QmlaRXp3aUpnREV3VTREVjJnUUdGT0JnbVA4R0FpQXdSQWlCZ0lnWUNJR0FpLzRNQkhBd1JnakF3Umdqd01FUUlnTWNnWThEQkdDTURCR0NNREV5Sm4vLy8rQmlZUUlCbE9iajRlWUxJd3NqQU9CR0ZrWUJvRVE4NGVVTEl3ODhMSUE4OFBLSG53OHNQS0ZrZUhsQU5BaUFhRlVEQWlNWVBJSG1EekJaQmhaQi8vLzhHQk9BMXNIL0F3bmk3QXduaFBDSVR3WUUvQ0t6Qmd0OElnOEdBNElnNkVRZHd3NFliK0Yxc0lndHdZQ3dHQXNBd1dBc0JnTEFZQ3dEQllDd0RCYUhVREYrVkVES2dDMkJndEJhREFXZ1lMUVcvLy8vZ1lMQVdRTUZnTEFNRm9MY0dBdC8vLy80Uk1BQm1CU2o0Tmd3TU9HSEJzSGhkY0xyd2JCNFhYQzYrRjE0WWNMcnd3NE5nOE1PR0hCc0h3dzROZzhBVUM0QW9NUU1DNGZndzN3dXRWNFFJc0FnRllJQldDQ1ZnSGVWZ0hlV0FCQ3dBSVZnSCtZQndCNWFSQXN0S2dWNkJhMW9NZzlhdnRVVk4vcWRMV2NpRC9jcUQzSmc2REZQdVRCLy8vLy9sWUFuLy9tQzhDK1lMd0w1Z3ZndkdDLy9Qa1pGRXBMZ01LWVh0MnhCNUxvZ0FBcmJkYytDOFZndmxZTC9tQzhDK1lMd0w1WUJmTU5nTmt3WGl4RFdvSFBNYzRWVXhWQTJUQmVEWlBZWHpYbDgxNWZLMTRzTHhZWHZLMS8vTmVYelhsODE1Zk10ZERMU3czVXNNdExDc3RNdExETFN3c0ZoV1dsZ3QvLzhzRmhXNmYvLy8vLytXRjd6WGw4c0w1cnkrVnJ4cnkrV0Yvd01Md1g0TUMrRVF2L0F3dkJmQXhzallBeXFwS0EwbHBMQXd2QmZCZ1h2Ly8vNFJBMkRBTkFZR2dOZ1lHZ05nWUd3TitFUXZmL0JnWHdZRi8vOERDK0Y0RGQ2TmdHQmY0QWdGd2JCME1NRjF3dXVEWU1Cc0d3dXNEWU9Cc0hBMkR2ZzJEUXV1RFlPaGRjTU1GMTRZWURHWURFR3dmaGhnYkIwTU4vLy80UkJhRVFXZ1pCeW9ZUldZTUZ2d2lEc0d3YUYxZ2JCMzRHRHdkQzY0WFcvdzFhS3hEVmdhdGlyNFljTHJRYkJ3Tmc3Ly8vLy8vLy8vLy8vK0VTZmdaUHlmZi8vLy8vLy8vLzRNRm1CdnZNQUVSWjhDQzVhZE5qMDJFMlMwcWJDQlNCWmFZdE4vLy9vRmxwVTJRTVhJRkFZdVFLOUF0QW83SXhMVHBzSUZKcy81YVpSeFFhd2F4R2ZJZzlDc3JJK1BVcWtXZE9IcDdPRHNPbDZjT0haNGRzdWxmTEk5LzhCQUFnTUJBQ3NCTEFDVmdCam9BV0FFNU9UTTZXREFSMHpvZE1kSENzSkxBU1dBanpDUWdzQkpoQVNXQWp5c0k4d2tKTUlDVS8vUGtaRmtlcWdjYVlEZDF0aDZEb2dBQXFDdUl4UXd0REE1TWRNVUxneVk2WXFuWHFkZXA1VHBNZE1WUk5STC9VVDlBTjZqQ2lTaktBWlJOUmhBTW9tZ0ZRRGZDSUp3WUNRaUNBaUNNR0FrR0FnREJKVUEzZVZBTUVnai8vLy84U3JERklZcWg1ZzhrUE1Ia0R6QjVPRmtZZVlQSitIbER6QjUrQVlWUURpYkN5SVBMTEVaSXNqSWxpV1MwV3l3V3l5V3VXQ3lXSmFMWmJMSllESGdMQUl0RnZ5My8vLzRlWVBLQmxRVGg1UVlFT0RCYi8vaGhvTmc3L0M2MkRZUEZVS3dLc1ZnTldCcThWa1ZjVmtWVVZZckgvL2hHZmYvOEl6OEdUNy8vLy8vL3dpWDRNTDNnd3Znd3ZmNE1MM2daZXFvSFZHeUJsNHZnWmZMMkYxb05nNExyZzJEY0xyZzJEUXcwTHJoaDhMcjRZY01OQnNHaGRjR0JjTU9HR0FGR0FHTVFzRjFndXVHRzRYWFYvNHVRWE9MbUYxa0wvOGxDWGt1U2s0TzgvRnpIenVQMGhJdWNmL0NJRkFNQ2dGUGdZRkFLQXdDZ0dCUUNnR0hZTzRHQlZNNEdnUUk0UkNNRVFLUU90UWpVSTFDTmNJMTRNcURLd0RJQUdRRHpoNXdzakR5dzh1SG1EelllVVBOK0RFWVJSaEZFSW93WWdEUWdJaFdEQXBnd0tBd0tRWUZBWUZRTUtrWURPeEhBenNSZ01LQlVHQlgvaDV2K0htNGVjUE5oNUE4d0J3amhaSGhaQUhsRHpCWkFGa0FlUVBLSG5DeUlMSUFzaWg1UXNnRHovL1BrWkxRZ0lnc01BRnAxeENHTG9nQUFBMnJrQjV3OG9lWUxJUThrUE1Ia0N5R0huQU1Lb0dtQWdGa1VQTUhtRFlBdGZIUEhOa3IvSllsOGM4bENXSFBITWtxU281b25NQWtCRG5mSlgvLzhJZ0RCZ0JoRWRBYXhTUU1IVUdBRUlnQVY0cmlzQ2NpcEJPTVZSVkJPLy8vL2hFdkF4c0F3dmYvLy8vOE1QRER3dzRYV0M2NFhYRER3dzRZY01QQzZ3WWIvd1lHZ2lHd01wbE1EWWhUQ0lhQ0lhQmdhLy8vLy84R0ErRVFkZ1lQQjRNQjRHRHdkaEVIOElnOElnOEdBNkVRY0VRZjhEQnhsQmpvQXdlRHVGd2dDUVhpTC8vaUxpS0NLQ0w0WENpS1JGd0Vnb1JUNGlxcE1RVTFGTXk0eE1EQ3FxcXFxcXFyLy8vL3h1RGQ4ZnYvRFZ3ckFyRUlnNkVRZGhFSEFZUEJ3TUIrRVJZQmkwV0F3V0FaMEZvR0xZT0IrSmZnWjBGb0dkQmFEQllibitXSG05eFc3L056emM4M1BMRHpjOHJlV2xBN1Mwb0hhbXgvLzZCZmxwVTJDMHFiQmFmLzh5ay95c24rVmtNaFRLUXJLVms4eUU4cklWa0t5WXNBbi81V0MrWUlDbUNBcFdDR1RreHRLTWNWV2xnRk1FQlRCQVgvLy8vMEMwQzBDLy8vLy8vLy8vTFRGcHZUWkxUbHB2LzBDaTB4YVl0T2dXbXlteVdrQXhjV21UWlRZVFk4dE1teWdVV21MVElGcHNGcHY5Tm55d0xtTEN4MlJnV21RS1RaOThVam56WjEvKytENE02Ly8vLy8zLy9Qa1pPZ2pJZzhJQUZjYnhDYVRvZ0FBb0N1SXpmSjh2Zko4V2NzNWZCbkQ1Ly8rK0w1Zi8vLy8vLy8vNm5DS3YvLytvMG8wRlVZd3FETkdDd2dVTUtDMFZWR2tWdi8vNFlmOExyeFZDcmlxRFZvYXNEVnVLc05XdzFiaXNCcXdWa1ZrVlgvL2d5LzRZWU1NR0doaGd3d05nNExyaGRjTHJBWVdHQUEwekJzSDROZzNDNi8vLy8vNE1Bb0dCUUlEQUtCZ1VDQXdDZ1lFQXNEQW9FQXdLQkFZQllNQW9HQlFJQmdVQ1lHQlFJQmdVQ3dpQkFZQllNQW9SQWdSQW9HQkJNQm9vQ0FZRkFrSWdURVV4RnYvRVd4RnhGaEZvaTBMaFF1RmlMQ0wvRVdxVEVGTlJUTXVNVEF3cXFxcS8vLy8vLzhUV0pyaVYvaEVSQXdSZ1lpRVlHSWhHQm1JUmdZaUVZTUVRTUVjRE1TaUExR1l3TVIrVURNVGtBN0tJZ01SR0lHR00wU0lyUkdqUmxoRVY0anhvdjhyUi81WVJGaEVkUVNWaUNzUjVpUkpXSUt4UGxnUVlnU1ZpU3NSNVdKTVFKTEM3OElpS0VSRjRSRWVFUkdFUkVFUkh3TVJHT0JtSVJoRVJoRVJBd1JBWWlFUUdJaEdCbUlSQWFqa2dHNVRFRVJFREJId1lJd1lJNFJFWENJVi80TUNtREFyZ3dLQVlVTy9nWVZDa0dCVUdCVGdZVUNzR0JVSWhVRENvVUNJVkJnVkJnVkJnVWhFS1FNS2hVRENvVUJnVkF3b0ZBWUZjR0JRREk2b0E1K3FRaUZBTWpCVUdCWEN5RVBJRmtPSC8vUGtaUE1qNmdyNkFGZFZ3aWZrQmR3QW9DMklsaDUvOFBQaDVRc2loNUllVUEwVEFackU4UFAvLy8vd01SaUlJcUlEOHBpQXhFSXdNeENNREVRakNJai8vQmlJRFJvOElvZ2lpLzRNS3dZVmhFb0VTa0RFaUlHSkVnWWxmQmdtREJJTUVBWWdTQmlCSVJFQXdTRVJILzhJN3dQZnVDTzRJN3YvOEdCdkF3M0J2Ly8vLy9nd04zNFJCdUJnMkJ1QmcyQnVCZzJCdUVRYmhFRytFUWJBd0c0TUJ0d2lEYURBYmhFR3dNQnVEQWJBd0c0R0RZRzhEQnNEY0RCdU53RFJXRGNJZzJBd2JBMzRSQnYvLy9DSU52Q0lOZ01SSU4vLy8vL3dpRzRERGVHK1RFRk5SVE11TVRBd3FxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxL3pCNE9MQVA4ckJ4V0Rpc0hsWU9LeGI1V0xURmdzTVdpdzE4TERPbmpQeFpveGFkRE9nc0xBdExBYkt5bVZoc3JEWldHL0xBYjh3Mkd5d0d5c05sZ05GZ05HRnd1QlF1V25UWkxUb0ZGcGlzTEpzRnAwQ3kwdm9GQVFMRlprTUNBUXdJQkNzQy81V0JDd0JDd0JDd0JDc0NlVmdVd0lCQ3dCREV3RU1DQVFyQWhnVUNsZ0NGZ1RsZ0NHSmdKNWdRVEdKd0tXQUtZRkFwZ1FUR0JRTDVrWTBITWpRWW5BaFdKdkt3SVdBSVZnUXJBcFlBaFdCUEJnRUNJRUJnRS84SWdYaEVDUWlCQU1Da2NERXdFd01DQVFHQVFJaG9JaHNHQnNJaHZnd04vL1BrWk40aXJncjJBQU9WcWlVVGhlZ0FuQ3RNZ3dOd2lHLzhJaHVEQTFoRU5oRU5nWWJLWUhiMklCaG9OaEVOQXdOLy8vLzhJaHNES1pTLy8vLzhJaHVCaHNwZ2MwS1FSRFdFUTMvLy9DTmY0R0FJTURBd2dBd0FBd2hBd0F3WUFJZ3dpSEJnQU1BWUdBQUdIdi8vL0NJQnFCcUVTREVJZ1JZR29HSEJpREVJZ0dvR2dNQVlneGd3Z3hDSUVUd1lGWU1Db01DdURBcEJnVThEQ29VLy9nWTNHLy93WUZPQmhVS0JFS1FZRmZCZ1Y4SWhTRVFvQmtZSzhJaFQvd01LaFhCZ1VDSVU0UkNvUkN2Z1lWQ3NEQ3AzQTFTcUFZRkFpRlAvLy8vZ1kzRzFURUZOUlRNdU1UQXdWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVmd3Q0F3Q0JFQy8vLy8vLy84SWdVSWdXRVFJQmdVQ0F3VFFNQ0FRREFvRWhFQ0FZRkl3R2FSTUJvdFdBYXNkd0gvS3FCbWhGZ2FLSTRHUmdLVnBqQ0JUQ0JQTUpITk1GTUlGS3dubGdKNWhVeGhVd0dXbHBBTXVNdVdMVEZwdlFLUUxRS0xUSUZKc29GSUZGWmIvOHdvUXdvVC8vL01JRjhyQytXQXBoQXBoQXBwZ3BZQ2xnc213QkM2YkhvRkZwVUNpMHdHWEZndVdDd0ZMZ1VzZ1g2QlphVk5qMENpMDMvLytFUUtFUUtFUUxDSUZBeE1CY0RBZ0ZBd0lCUVlCT0RBS0JnVUNBWUVBdURBS0JnVUNBWUZBZ1JBbmd3Q2d3Q3dpQklSQW1FLy9Qa1pONGlvZ2oyQUZkVnhpVXJoZXdBaE9rd1FJQmdRMGdiT0k0R1JoT0JpWUNnWUVBdi8vLy9DSUZBeU1CUVlCZi8vL0NJRjhJZ1VEQWdGQmdFQXdJUndNQ0NjREV3RkF3SUJmLy8vQ0lFUUdNREdFWENLQnBDSURDRVFEQ0FzWUluREZRTU1BdVlTb1RRTVZmQmxmLy8rREtmQmdBaUdEQVFNSU1JZ0NJUVlBREFFR0Fnd1AvLy8vOEl0Z051Mi84REFBQWlBQmdIaEVDQmdRR0VRQVJBOEdBZUVRSU1BQkVDRVFJTUF3WUJCZ0NEQUFSQTRHQUFnWUFDREFBUkF3aUFnd0RoRUQ0UkFCRUJDSUdCZ0RvSDJkZ1p3Q0JnQVAvL0JoWC8rRENpVEVGTlJUTXVNVEF3cXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcUYxd3cvLy8vLy8vL2hkZUdHRERCaHdqZUYxMDJFMmZUWUFvd01MakUwelREZnl5TVlqRURKVHdNTFN3RmkwL2dRTG9GSUZwc2VnV215QlFzV2xRTDlBcE5ndElXbjh0TWdYNkJhQlgrV21RTDlObjAyZjlOa3RJZ1VnV213V2w5QXZ5MDZiQ0JTYkphVXRJbXlXa1FLTFRJRmdZV29GRnBBS0Z3TUx6Wmd3QXd2TFRJRmxwVTJmUUxRSy8vLzRZZjRZYUYxc0xyZzJEQXV1RFlORERRdzROZ3dMcmhoNFhYQzY0TmczQzYwTU53YkI0WFdDNjRZY01PRFlQQ0pZRGxNUUJsd1JMZzJET0Yxdi8vLy8vUGtaTTBlS2d6MEFFK1V1Q25MRmZBQWszRnNnMkRBWVgvd3cvLzRZYUdHRERoZGJEREFDRndNdVhBMkRBRGx5Z3VzRFlPQnNHaGh2Ly93TlUvQ0tRdXNGMW9YWCtGMXd1dUdHQzZ3WFdEREJkYkM2d1hYaEh2Ly80QUhJRmdDMEJaQUE0QmE0RmtBRHdGc0MzQXRRQU9jQzBCWUF0Z0FjQUE5K0JZQXNnVzRGdmdXT0FCd0Mxb3EraXQ0UlQwVlZHMFZGR2tWeXdvMS9SV1U0VTU5VGxGYjFHdlJYLy8vL1FLOU5qLzlBdE5uMDJmVFk5TmhObEFyL1FLLy9UWVRaTFNKc0lGZW14Ly8vb0YvNWFaTmowMlUyQzB5QmFCZm9GQVM2YktCZm9GVlRFRk5SVE11TVRBd1ZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlFpQThHQU8vNFJBZi8vLy8vL3dZQTRHQU8rRVFIQXdCNEdEb0I0R0E0SFFSQjBCaGxESUJwRUFjQmdQRElCZ1BBZURBSElGQVl1TFRwc3BzSnNGcGkwaGFSQXBBdEFzdElZS0NsZ0YveXNGL3lzRS95c0YvL0xBSjZwbFRsWUMxWlV5cG1xdFdWSzFWcXlwbFNGZ0JhcXFjd0FBVklxY3JFQkFBS21NQkVSQ1Fod0Q1aUlDSVFFeUFCTUFBQkJWR1hGNGdJQTRETEFBV0FFUWdMVlNzQmFxMVpVditZS0NsZ0VMQUovLy8vNVlCUC8vTEFMNVdDK1ZnbitXQVgvTFQrZ1cvL1BrWk1JaExncnNBRnQxeWlEN0ZpQjZBOXF3bXdWaXliQ2JDYkNCU0JhYkNCU0JhYlBwc2VnV213V245QXBBcEFwTmdDR0JtRXdXbExTcHNmLy8vL2hFSGdZT0IzLy8vLzRHRGtpQnhNSGhFZGdZT0I0R0R3Y0JnNEhXMjNnb29GWUhkLytCbkF6OE84VnYvL0ZhQm00ckJXaDM4ZXMyemJBdEQxbTJQVkJxQnJCcUJyQUY3QUYzLzVlbDg0TWt1SFRneXkrZEwwZFJuRWFqTUl5T244UnNaNUhHRy9rYklwSElrWVVpRDB5MldjdGxaYVdTd3JLeDZGWmJ4bkw1NHVsMDRlTGh3OU9sODRkbDg2Y09IVDNJcGI1WjhxS3BWeDYvajBFa0xjdFZURUZOUlRNdU1UQXdnV1FMUUFIZ0xmLy8vLy80Rm4rRVFFU0VjSWdJbkNJUlc5VGtyQ3pIMFlJampXdEkrWWVDRDB3b0xDQlF3c0tSV1VhUlZDQlpGWlJ0UnRGUlRsVGxUaFJ0QXIwQzBDLy8wMkUyZlRaUUsvMENrMmY5VGxGUlRsVGxGVC85VGxGVkZSRmIvOVRoVGh5bklRYldrQVJFdWU1UzExcktkbGtERVZBQmg2MUV4WVBVK3RPRDRNUWdjbjRpd2lnaXZ4RlJGb1hEY1JRTGhvaXdpb1hDZUFrRkJjTmlMOFJVUlFCSUtFVkVXaUxCY0tJcUlwRVhDNFFSZUlvSXBDSUtBUU14RkFGQXNJdUlyLzRZWUxyLy93dzRYV0Jnd0M2NFhYL2hoZ3czaGh3dXY4TU5oaGd1dmhkY0FVWWdhWVRBQW9XRERnMkRRYkJnLy9Qa1pQWWU2Z3p1QURkMXVES3NCaEJBZTg5Y1lZZEdqdERUMmhEbWxEMmxlYU92OW9YME9YLzBOTkxwbE5mOGV3YWtOV0dyVGZUUnBwaE5KdGZhZWg3VDEvdFN0ZHRUcHFONTMybHBYLzEva21RNWVhZjJob2FWOXBhR2xlSkF2ZDByZXIycFd1MWFyMnZrNTZ2VnJWNUhqMU5vcCsvbGZ2NVpwa2VtNWtYLzJ2dGF0YTJycTc4M25idnRiVzZWalc2YTJycTEzK3JPNlZ5c1Y1OEs3dGJwMHJ1NlZydHFhMWE2N3RyNnNhdTF1bFlybmZhMnY5MjdWcnQyMU5TdU41WDkyNy9ENGRpQVFBTmg0Z0VJZnhCK0lRRy9ELzRnRHcvaUdJUkQrSFJBVEVGTlJUTXVNVEF3cXFxcXFxcXFxcXFxcXFxcXFpSUVLL2l0aXRGWC8vLzhWY1Z1SzM4VnNWaFhCT1FUcHEvcW04UUNBY0JtSXhnZGZGWkNIRUNweEZCRkF1RkVVQzRjTGhzUlRFVkVVRFZvRFFEK0tyRllpckZYK0t3S29WZ1ZVVlVWZUt3R3JoV1JXQlZpcUZZRFY0ck1WaUt5R3JvYXVCZy9BMFlUaFZnTkFFVlFxdzFmaXNpczRxdUt4eFdZckFhdHhXSXFvcWcxZEZZeFZ4V0lyQWF2QWFBQXJJckFxb3FoV1lySXF2eFdNVllyQVJDQURoY0tvVllhdkRWZ3FoVjRxb3JJckhGV0t1S3hGVmlzY1ZVVllhc0FhQWZGWS80WWNNTmhkZnd1dUdHQzY0WWZEREEyRHd1c0FOeWdiQndBeGhBRUN3Tmc4TU9GMWhENC8vUGtaT2tjNGc3eUJqZDFzRE5rRGhncVl3dGNZb1V5aVEwTkNreFEwTkNRa1NJYkdLSXlSR0VvNW1VYU5FaEdLRUhNbWFHaEkwVW9rT1J2TW1abVpTWlNpTVpRa1JuS0taa3pSb1NOQ1FwUTBORVpvYU5GSmtoaDNLT1VKRWhJY29TSkNRa0l6bERsRWpNRE15TXBRMEpDUXpOQ1JHYU5DUklTRVpvWmlob2FJd2xFSEtOR2lNekZFalJtU0l3bEhNeVptY3lpR3lNeFJ5aElrSXhSU1pva1NFWUdCa2lSb2pBUEVTTkdqUXh2S0hNbU1vU0tUSkNRa0l3bEZLTERZV0dob1poWVdBQVVHQnNBd3NNRFlVQWNLNFhEUGhRVnd3TEFIL0RmZ0hDNlRFRk5SYXFxQmdqd1lJLy93WUkvOEdDTC8vLytEQkZoRVJnd1JjSWlQQXpHWWdNUktJRGNza0JnakF4RUl3WUk0R2lSd05FamhGSDRNUndZakEwYU9FVWY4SW8vQmlMZ3hHRVVZUlJRaWovQmlLREVZTVIrREJHQmlNUlFpSWdZSXdpSXdZSWdpSWdNUkdJRFVTamhFUmVFUkVCaUlSQXdSL3dZSS84SWlQNE1FY0dDSUlpT0VSSDhHQ0lJaU1JaUlJaU9EQkhCZ2pCZ2p3aUlvUkVjSWlPRVJFREJGQ0tpQXhISmNJaU1HQ01HQ0x3WUk4SWlQaEVSZ3dSQXdSQVlqRVVJaUlHQ1AvQXhHSWdpSXNHQ0wvLzRSRVlNRVhoRVJCRVJoRXhoRXhBenlBWmlFV0RCR0VSR2VLc1ZzVlJWRmNWd1RuRmNWeFZnbllxaXBGVVYvL1BrWlBrY2ZnemVBRmFWeERnVUJnQWdhdHZJWXJnbllxZ25RSnlLNHJpcUs0cndUc1ZvcjRyUUFqQUJBZ25Rcml0RlNLb3FRVHNFNUMxaGF4ZkY3RjRYUXRVTFNGcUMxaTRMd1drWElXa1hSZEYrTHdxQW5NRTRpcUNkd1RvVnVLK0hBRVJXQWtBbGdKQjBPQjNEb2M4T1ljOFZDc1ZnSUIzRHVIQUVSVUFrQWtITU9Cd09BSWlzTzRkd0VBRUFFZzZBa0FsNENlSEE0QWtLaFhpb0JJT2l2OE9CM0YrTGdXa1h4ZUY4WG91eGNGMFhCZUY4WEJkRjhYaGRBZG91QzhBRXNYWVdzWE9Lc1ZCVS9GYUttSy9GVHhYRmJGVVZQaXYvOFZmeFhpdFZURUZOUlRNdU1UQXdWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVkFYWC84TU4vd3d3WWYvL0REQmg0WWYvK0RZT0REZkNJRkF3S0JRaWFBTkZnVURBZ0ZBd0lCY0FEd0Z1QlkvQXQ4QzF3TGZnQWRBdHdMR0Jhd0xjQzNBc2dXZUJZd0xYNFhXOExyQmhnaUZnTWxoWUxyaGg0WFdoZGI4TU9HR2hkY01QNFlhRjFndzhMcnd1dmhob1lZTHJZWFdEREJkY0d3ZkM2ME1OL3d3OEd3WjRYWEM2NEdaUXNGMXdiQm5ERDRYWGcyRGNMckJkYURZUGhoZ3VzRjF1R0dDNjRZZmhob05nMExyUXd3WWNNTkM2MkYxL2cyRFlYVzRYWEM2K0dIOERUSVc0WWVCL3dSL3dqd1IrRFAveTA2YkphUkF0QXRBdEFzLy9Qa1pOd1kyZ3JxQkZXMXhEaFRSZWdBQkxCc3RMNkJSYVZBc3RONWFZdE4vcHNJRmY1YVF0SWdXZ1VXazh0SW15V2tRTDlBdnkwcWJLYktiSmFmMDJmLzBDa0N5MDVhZEFzQzNLNytteDVhVkF2MEMvVFo4dE9teW13QjJwc3BzRnBQTFNscHkwcWJDQlNCWGxwazJFMkUyQzBwYVV0UDZCZnBzbHAwQ2tDeTBpYkphWkFvc1dRTExUSnNlbXdnVW16NkJaYVl0T2dVV21MVHBzSnNvRkpzbHBQTFQrbXdtei8vNkJmcHNmNkJTQlNiQ0JYb0ZlV2s5TmhOaEFyMEN5MC8rV25UWjh0Si9vRmY2YlArbXlXbi8vOHRNbXovbHBmLy8vLy8vOHNQVEVGTlJUTXVNVEF3VlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZCZ0p3aUNZTUJQLy9nd0UvLy8vLy93aUNBTUVna0lnZ0lxSURLcFVDSUlnd0U4SXpBNGorRVloR0FaTUl5REpBNWdHUmhHY0l5REloRVFpSUdBZ3dJUkR3aUFHQUF3WU1IQmdoR0FaTUdSQ01oR1lSZ0dSQTVnSXlESXdaUEJrL3daSVJtRVkvZ3lPQnhJTWdJekNNZ2NUZ3dSQmdqd1lKQmduZ3dUd1lKaEVRQmlCR0VSTUlyd09vdUF4QWdHQ1FZSWhFUmhFUURCR0RCQVJFZ3dUQ0lnR0NRWUpnd1NEQkh3aUk0TUVBd1NCaVJIQ0lrR0NZR0pFUWlJL0JnbjRSRVlSRWVCaUJJSDZYaEVSaEVUd29nb3kwNG1wWmliRm1KdVdZbXg4bi8vUGtaTjRacmdya0FGWlV5RGNqb2ZnQUE5cWMwSGFmWjhId05yamFHM3h0amFEdEp3VG8rRDU1T3c3ZnhOUk5TeUxQbHFKc0FyL2xtQS9GbVdZbTVhY1RRVmdUa1ZRVG5CT1FUZ1Z4VkJPQlZGV0s0SjNGVUU3Z0JBQk93VG9WUVRzVmhVRmNWUlhCT2hVQk9SV2l1S2tWWXJDcUsrS29xZ25RckFuRVYrSzhFN0ZRRTV4V0JPUVRvVlFUc1ZSVzhWNHFSVUZZVmdUc1ZoWGlvS2dyQ3FLd3FBbllxQ3RCT2hVaW9LK0NjaXNLOFZSVUZTS25pckZRVkJWRmNFNkZjVm9Kd0tvcUNyRlhGVUU3Z25BcWl1Q2NRVHNFN3hVOFZQOFZZcmduWXJDdVRFRk5SVE11TVRBd3FxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFuMy9sL0ovOHZITDVmL0Jod0NFVGdHcElET0FUZ0VJT0ZvRGNIemdFSURnQytwRzdldmUxUy82dGF0N3JYdXBEWFNTdFdvSXBHUzRUU01RTkl5U013cEl5QWFSa2taOEdKR2RCdGJ3WWtaNjN0Q0tSa29JcEdXREVqTENLUm1Fa2pPdnNFVWpKT3NJcEdhNmJPcmd4SXpzRWtqSUdKR1lVa1pWS0NLUm1xb0RrZ0VqTUpKR1NZTVNNQWlrWkozcWhwMGRxOXJ1M1gxSTM2RnVqUGJYdXh3S2JyLy93YUFCZmcwQUM2RFVEVURYQnFCb0FtUWF3SmlHcmhxRFVHb04vL1BrWkw4VVNnS2NBQWJscnJvVGdmUUFiaHRRQWFnMVFhd2FZTklBdVFhMTJMdjlzaTdGMk5uWGEyVnNpN2kvRFpsMnRsTDlsK3ZMOHRsVVRVVFVUVVlRRElCbEdVQXlpZnFKS0pxSitwNU1mL1U3VEVURVU3Q3hreFZPMVBLZHFlVTh1NHZxMmRkbnJzYk0yWnMvdGw5czY3VjJObGJJdTVzZ2FBMVExNEV4QW1BYUEwQnJEVkRYaHBnVFBEUUd1Qk1BMGdUS0dnQ1lnVEhEUUdyRFVHZ05jTlFhdzFob0FtY05JYVJJQXRBTFZFZ0MxZ3RlSThGcEJhQklBdGNSd2tBV2dGcEJhSUxWQmFJa0FXZ1J3amhJaVBFZURYd2EvNE5VR3IrRFJ3YUtCZ1gvOEloUC8vd2lGOEdCTUdCUC93WUVoRUtFUW1FUXVEQW9HRlRBd0xnd0xoRy80TXZDTThHU0RKQ053WlFPWGcyRHdiQjhNUEREaGh1R0dCc0hoaDhMcmY0TUNRWUZDSVVHSmdpRThHQlFNSUZoRUxERGhkYUdIaGRZR3dhR0dERGhodURZTUJzSGcyRDhNTUdIQnNIOEd3WURZTWhFS0VRZ01DZURBc0loQWlGQmdRSWhBWUZoRUtEQWtHQk1JaFlHRUM0R0ZDQkVMZ1lVS0RBdUVRc0dCUU1LRXdpRUJnVUdCY0loUVlGd1lGQXdnV0RBb1JDOEdCQVlFNFJDZ3dLRVF2aEVKZ1lVSUJoUWtJaEFpRUNJVUdCSU1DNFJDZ3dKQ0lVR0JBaUZnYVlMd2lFQTVjR1hDTmhHQkd3WkF3NE5nME1QQmtxTnFjb3FvcmxoLy9Qa1pQOGN5Z3JrQUZJMHdqbzdsZkFBamhxNFNuUG9yLy9wc29GZW15Z1dtd1dtLzBDMENpMDVhZEFwTm4vVFpRTFU1UlU5RlJGVkZkVG4xT0ZHMUd5d3YvVWJVYTlGZjBWb0ZnQ3dCYkF0UUxVQ3pBdGdBY2hIQU44SW1BYmdCdndEZDRSd2pRRGVBTjhJMEltRVFFUUFid1JnaVFqQkhoSEFOMEEzdmdHNkFiL0NJaEVnRzVBTjZFUUVTQWJtRVlJNFJBQnZZUm9SQUJ1WVJnRGVoRVFpQWlJUkFCdmNBM1FpUURmd2p3RGZDSUNQQ0pDSkNKNFJ3aVlSd2pCRXdEZWhFWVJnRGZDTkNPRVFFUUVjSStCYWdBZDRGckFzY0N4QXN3TGZ3TEFGZ0Mxd0xOVk1RVTFGTXk0eE1EQlZWVlZWVlZWVkJsQmt3TzN3WkFaTUl6Ly8vLy8vK0RKd08wSXdJMERzQTdjR1VJMzRSbjRSZ011RVpneXdaUWpBWlAvaEdBY21ES0VZRElCMjhHUUdRR1hoR2djZ1JvTWdSb0hZQnl3WkFaWU1tQnlneVFZRkNJVURDaFFZRTRNQ2dhWUovZ3dLRVFzR0JBaUVCZ1hBd2dRTHJoZGNHd2NHSEJzR0EyRGd3NFlZR3daQzYvaGRZTU1GMTRZY0xyWVljTVBERGhkWUd3ZUYxb1liNE1Dd1lFd1lFZ3dKQmdUQ0lRR0JJUkMvQmdRRENCY0loQU1LRmhFS0RBc0dCUVlGQXdnVGd3S0RBb01DUWlFZ3dJQmhBbkNJVUdCUWlGd2lFQmljSWhBaUZoRUlnSW9Cb29HaWVEUEErNEdlRFBDUC8vUGtaT29iWGdya0FFWTBqamF6aWVRZ0JLS0lCR2d5QkdoR2hHZ3lBZG9NbUVhRElCMmd5aEd3WllNc0kwR1NESUVhREtCMlFPV0VhREtCMmhHZ3lnY29IWUJ5Z2RrRHRneWdjbmd5QXloRzRNZ01nUmdSbURKQ05Ca0E3UWpBWklSb1JvTXVCeWhHZ3lBeUF5aEd3WllIS0J5QWNnTWdSb0hJRWJDTkNOQTdmQ05BN0FaQU8wR1NFWUVhRExBN2NEdGhHZ3lBeUF5UWpBT3dHVUl5REtFWUVhRVlFWUVhRWJBNUFaUVpBWkFaSU1nUmtHWEJsQmtDTWd5QXlRWllNbmdjbUViOEdVR1FJeURJQnl3WkFaT0VaaEdCR3dPMkVid2pjSTNoR1lNcVRFRk5SVE11TVRBd3FxcXFxcXFxcXFxcXFxcXFxcXFxcXVEcXo4R01EUUl2QmovLy8rREdERUdBTUFpZkJqOEl1RVRoRkNJRVFHUENMd2lRWUJGQ0tFU0RDRVRCaGhHQVpHRVo0TWpnY1NFWTRHb1JRaWd4Q0lFUUdQQ0tCaUJyZ3h3aUJFd01JUkFZNE1RTk1Ja0ltREVHSVJZTUlSWVJBWWhGQmp3WXdOUVlnd0JnQmg0R0FNUWl3WWd4QTBnYWhGQmdCamdZQkZoRmhGQ0tFV0JnRVdFVUdFSWdNUVlRTVlSQU1RaWd4aEZCaDRHa0lnUklSWVJBWTRSSU1RWWdZaEZBMThJb01RWVFpaEZoRWd3aEZDSURFR0lSUWllQmlFVUlvUlFZaEV3WURBRndHckJvZzB3YUFhUWF3YWNHc0dpRFFwOU1aTVZUM3BpSmpKaksvL1BrWk9ZWkJnam9hVUpRMERwcm9mUWdiaHEwZGVwNzFQcWVVNjlUcE1kTVZUNm4xT2xQS2RKanBpS2RGWmt4bFBLZEppSmorbUtwLzB4RlBCb0FtWWF3MEJwd0poRFNCTVExQnFBbUlFekRTR2dOWERSRFJocCtHc05NTkFFeUFtWWFnSmtCTUExQnBEWEFtRUNaaG9EWGhxQW1ZYXdKamdUSUNaQnJEU0dzTkFFeERWRFFHcUdnTkhEV0JNSWFRMEJyQW1jQ1lnVEhBbUlFekRXR2dOWWFPQk13MEJxRFNCTVlhQTA0YUExaHF3Smh3MEFUS0dxQk04TllFejRhUUprR29OTU5JYWcxK0dzQ1krQk1RSmxEVncwY0NZZkRYdzFobzRhUTBnVENURUZOUlRNdU1UQXdxcW9EMzd3anVoSGYvLy8vL2hHZi8vLy9oSGYvZ3ljRVp3Um40TW5ZTW5jSXpzR1R3T2RPQTUwN0E1MDdoR2VFWjhHVHVESjRSbjRIUG40TW40Um5oR2NESndNM1lNM2d6ZEJtNkROd1IzUWp2QTkyN0JtLy9CbTdCbS9CbThHYmdadkJtNEdib1IzZ3plRWQrRE44R2J2Qm02RVorQnpwNE1uNEhPbkJHZkE1ODhJenNEblRnWlBDTThJeitFWi9DTTREblRnT2RQQms4SXo0Ukp3R1RpZEJpN0F5Y1RnaVQ0Uko4R0U2RVNkaEVuZ1pQSndHVGllRENjRVNmd1lUb01KM0F5Y1R3aVRzREo1T2hFbndpYndZYitFVGR3aWJ3aWJ2Q0p1d1liLzRSTi9CdGYvallHeU52OGJITFV0U3pFMC9MUUJXLy9Qa1pQUWNIZ2pRQUZLVnJqZkRtZ0FnZTFlTUxJVGNzaE55MUxYOHNpMExVVFF0Q3lMUVRVdGVXUW12TEl0U3o0bWdtblRKb3BzMHVtRXltRFNQc25SOUh3ZkI4azdQdm4wZkF2d3RjTFhGL0YrTDR2UXRRV3VGb0MwQmFSZUY3QWVCZnd0Y1hCZEY0WGhlRndYQXRBdWk5QzFoYVJkaTZMd3ZpcmduVUU2RmNWQlZpc0tnckN2aW9LK0tvcWlxQWhoM0FRRlhod1ZZckZZQ1dITU9pb1ZBSTRkRldIUERnQ0FkRGdkRG1IY0JJQkVPK0hSV0FpS3NCTU80ZEZRQ0FkQVR3NkhCV0hCV0FnSEJVSE1PZi9nSUNzT0NvVjRxdzcrS3hXSEE2S2hWVEVGTlJUTXVNVEF3VlZWVlZWVlZWVlZWVlZWVlZWVlZDMTFGejErTlArL1hrcXByOU9mdWhRNmxaTldmK1hzWmMvc2krS05vT2ovTnRhaTlqN0lJU2daQWtsVHFRaGpUb05UZVFvcmVSZGFTRE9EV3ZZQVZGYVdXa1FtVnVaUFA4YlJVenE4OTZ2YytYUzZtbTVnbm5XN0pMblY0ejlONVhuVzRrODZ4K3V5SHl4bldrbWRib3J6cmFmZjJTdk90dmxqT3RqZC81WFJXOE1pdk9zcnkvSzNnVXpyRlBTMWVGVE90dFRzdWwxK2xMR2RiVjNjNTNoNTFtZGJLN3hQT3IxU3BuV2xNNjNrZWRablY0WFBLODZvbm5XN215cm5XVG1SVE9xYXNjb2FiWGQvTCt5dXpTOTVkdjFlZmpobDkybnRZeVR1SWI2d3VXUlpGbVdSYS8vUGtaT2NiL2dxTUFDRGYxTFRMb2ZnZ0E5cWMvZ0tSWmlibHFXWW0zRTI0bW9TUW5SOUJKajZKd2ZCYUZxV1paRm9XdkxVc2hOUHhOdVduNmJUWkhnb3pSVFNhTkFZNW9HakZRVmdUa0U2RlVWb3Jpb0s4VkJYQk84VlJVaW9BaHhWaW9LNHFBbklyWXJDcUtzVlJWQk9SWEJPUlZGY1ZjVndUZ1ZCVUJPUlVpc0s0ckNvS3dyeFhGWUU0RllWQVRqRmNWaFg0cmNWQlZGUVY0cnhWRlNLd3FDcEZjVitLOFZoWEZZVjRxaXZGVUU0RmFDZGl2Qk9SVUJPZkJPZ1RvRTZGVVZZcWlzS2dxQ3R4V0ZiRlFWeFhpc0tncVJVNHFpb0t1S3dxQ3Z4VkJrSC80TWdmNFJnNFJnZmd4WkJpemhGWUVWdURGdmhGYkJpM0NLeUVWc0dMZi80TWdBeGFERm9Hc1dZTVdnYXhZQnJGbmd4YURGbkNLd0lyQVlzd05hcytERmdSV1lHdFdZTVdCRlpneGJnYXhiZ3haQ0t3R0xJUldneFpDSzJFVm1ERm1ERmdNVzRHdFc4SXJBWXRCaTNCaTBHTEFZc0NLMElyUWl0NE1XZUVWZ1JXK0RGc0k5Y0RXOUFZdGd4WmhGYUJyVmdNV2d4YURGdkNLd0lySUd0V2hGYUJyRnVFVnZCaTNoRlpBMWkwSXJZTVdZTVdBeGFFVmtHTEFpc0NLekJpekNLMERXcklSZytFWUlSZ1FqQUJrSHdPREFCa0RoR0R3T0RCZ3lBRVlJUm9Sdnd3NFljS0lMWUtJTGZoUmc1aHRqWTRPUWJRMmhOQUg4c3UvL1BrWlA4Y1JnaldBRkFVWWp3RG9mUUFpOXBjSnJ5MUUxTFVzdVd2RTJFMExRVGNCK0UyTE1UY3RRRkVFY1duRllWd1RrQUk0clJXRllFNkJPaFd3VG9CQkFRZ25JcmlzRVRBTndJaUFiL0NPRVFFYmdHK0VjQTM4QTN3amhHQ01FZUVhRWVLb0p3SzRKMktvQVJCVkJPSUoxRldLb0owQ2NDdUNkUldGY1Y0cmlvSzRyQW5ZSjJLMFY4VllyOEU0eFdGVVZCVkZRRTZGWEJPUldGU0tvcnhWRmNWd1RvRTV3VHZCT29xd1RvVklKeml1S3dKeEFRZ25VVkJVZ25BcVFDYUNkeFdpckZhS3dyUldGY0U3RmZGZUs0cmduSXJBbllyQ29Lb3FnbkFxQ3JpcDRxZ25Dci8vLy8vOEl1OEJqdlA0Unk1LzhJemdnYzRadzRSbkQvaEdjUDhHVGhCazRlREp3Z3ljSU1uRHdqT0Q0TW5CQTNldTloRjNrR084Z3gzdkJqdkFOM2p2TUdPOENMdkFZNzJESGVBYnZYZStESGVoRjNrR084Z2J2SGVCRjNvRzcxM2dHNzEzdmd4M29NZDVCanZBaTd3R085QTNldThCanZNRGQ0NzBJdTl3TjNqdlFZN3dHTzl3TjNqdklSZDRCdTlkNkJ1OWQ2REhlQWJ2SGV3aTd5RVhlY0dPOUJqdlFOM3J2SUc3enlrR085QTNlTzlDTHZZTWQ2RVhlZ3gzZ0c3eDNrRGQ0NzBEZDQ3MkRIZXdZN3lESGVBS29td21oWkZrQW9mOHRDeTRtNWFDYmNUVXN3RllzeTAvTFFUWDlOQnFCZ0pnWWFZLy9Qa1pQY2FUZEN1QUZnV2xrSTBEZlFBZTlyOEp4ejZDU2hyOCsrSnNBcmdqeE5CTkMwTFFzeXlMTXNnUnhhbGx5eUxJc2kwTFVUVXRTMEFWd0ZQaWE4c2kwTE1UWGlhY3N4Tml6TE1UWVRjc2kxTE1zeTBFMkxVc3VKcUp2eE55eS9FMUxNdGVXZ200bXBabGtKdVdSWkZtV25MUVRmZ25jVkFUa1ZjVlFUc1ZJcVFUb1Z4V0ZlSzRyd1RtQVRDc0NjQW5RSnlLb3JpcUt3cnhXaXFLb3F3VG9WUldCT1JXQk9CVkZTS2dxNHFBbkFxQW5BclJWZ25JSjNGWVZRQWdDcmlxSzRxWXFpdkJPc1ZvSndLZ0ozRllWQldGZkJPSXFDb0NjaXZpcHhVRlNDZDRxUlY0ckN2RmFDYy9CT2hXOFZ4V0ZVVmhYNHIxZVgvK0RIZ2FZTU9FWC9DSmd3d1lRWThHT0RIL3dZZjRSQWlRaUF4Q0tCajRHQU1ZUlFpd1ljR0VHTUlvTWZoRUNJQmdFWEF3Q0poRUExQmpoRitCaENJREVHQVJZR29SQVlneENMd1llRVNFVUdNREVJb0dBTUFpQXdCaUJyQ0o4R01HR0VXRVVHSVJZTUFZQXhDS0JpQmdCcUREQTF3aUJFQmlEQUlzR0lNQU5BTk1Jb01BWWhFQmg0R01HTUdBUmZBeEJqOEdBTUFOWVJBWUJGQXdDSUJoZ1loRXdOUU1ZR0lSQU1BaXdOWVJRaTRSUVl3WWdhaEVCaUJxQmdFU0VVSXFhNlo2YlRCcEdrbVV3bWt3YVpwSmxOQ2tpZm1rYWFhQnltZ20wd21SUHhTRFRUYS8vUGtaT1lZVGdib1pVQVFJa0NFRmdBQWU4OThZVFpwSnRNSmhOaWxwaE5kTUpoTUdnbWVtRFNOSk5ta2FYNmFOSk45TUpoTWMwRTJtelNOSk1wZzB1bVUybURTNW9KbE5KdE5KbnBnMERTVEJvbWwwd216VEU4VFJwR2dtMDBta3p6Uk5OTUpnMGpRVFNiL05GTmROR2wwMktUelJUZlRQVFNiVEtaTkxwaE5KcE5tZ21VeW1rd2FhYVRLWi9UU1lUQm9Kci9pZnB0TXByOU1KbE5wdE1wZzBreW11bUV3bWYrbUV3bU9ta3ltVFQ1cHB2ODBlYUhUQ1lUSFRTYU5CTkp0TjgwLzB5YUJvSm8wazJhUFRQTkEwT2FTYVRKb3BsTUp2OU1nQkFCNE1CVUd3YndWd1VCa0ZBWURBVTROQm9NQnFoQUVMay8vaC95MS92ejYvNnpNbkVnbHdxbklzVlNIQnpBTU1JcVhpTGd4Uzh1Y29MQ0tsN1Z3aXBldXB3WXBlQXhTOFoyMmhTbDRVK3FFMUwyZ29LVXZhMUdVSnFYcXdrcGVBeFM4MUlRcFM4c21CcVhxbDZFMUx5RVZMeGRFSnFYb1NVdkFtcGVKaEZTOHJwSDNDS2w2RVZMeFBXRktYZ0RVdlZMMUxDYWw0a3VERkwyRVZMeEZsUENsTHlFVkwyRktYaGR3WXBlc3dHcGVxWGtHS1hxTEF4Uzh3WXBlcVdrOEtVdkFUVXZRWXBlaEpTOUJpbDZ5b1VwZWdpcGVaVDJ4MXZONU5SMlgzS3JSdVhqRm1hUzBBVUN5RTFCSGZsbVdaYWNUWXN2eTA1WmdBSXMrV1FDcUpvV1ovL1BrWk93WitnYVlCZ2JtNkVRTUFmUUFlOXI4WkNiaWFGa1d2NVppYmlhbG9BcmxyeXlEdENTbnlmUjhockU3UHBObWlhSXhEVEdLYWZUSmFscUpvSm9XUW00bW5MVXRTekUxTFVzeE55eTRtcFpscUpweTE0bWdEOFdwYWdLdkxJRWNKdVduTEl0Qk5oTmhOeE5nSDh0U3lMTVRmbG1BL2lhQ2FGcUpxV2Y0bXhaRm1DZEN2RldLd3FpdmduUUp6RmZ3VG9BSXdxZ25PS2dxQ29LNEoyS3dxaXNLd0p3S3dxQ3FLZ0p3SzRyWXFpcmduSUoySzhWaFZ3VG1Lb3JZcmlvSzRKd0t3clJXRlFFNUZVRTZCT3dUZ1Y0cVlxaXVDZEFuWXFBbk1WQlZGVVZBVGtWQlZpcmlvS29xQ3ZpdUs4VndUanhXRmZpdkZVVnhYQk9jVnVLdkZhS29xaXVDZGVFVzNCamIvZ3h2aEZ2Q0xZR044R053aTNDTGY4RGJ0dUVXLy9DTTcrREcrRVcrREc4RGJOZ2kzQ0xmQTJ6WUl0d1kzZ2JadURHOEdUL0JrK0RKK0RKL2hHZENNK0Vad01uUVpQOEdUOEdUb1JuZ2M2ZEJrNEl6d1pPQms4R1R2aEdkQmsrREc4RGJ0OERidGdZMkNMYkJqWUdOd2kyQTJ6WURiTjRSYmhGdEEyemNEYk53TnUzQ0xhRVc0UmJlRVcyREc4RGJOd1kzQmpZRGJOZ1kzQTJ6WUl0d2kzQ0xiZ2JkdkEyN1lHTi9DTGFERzRSYmd4c0RHNFJiOEl0c0k3b1IzY0diMDBtMHdtVFQ2YVRab0pnVXBNYzBrd2FhLy9Qa1pOY1lxZUxVQUFBVUhqdzhEZ1FBZTg4Y1lUWFRYTkJwWGlRZGZMVnBMSm9hQ1NKczBUUU5BYlJwSnBEV2xlYUdsRG1sZlE5ZlE3dEJab2EwSWVPdzNDY3E0NFRjSGdydWZEVnpRTkEwT20wd21EVE5FMEV5bWt5bXVtVTJtVTBhU1k2WkU4TkZNbWlhYVlORHB0TUduK2FKcGROcHROcHMwT21VMEo1MHdOdE1HbW1Fei96UVRKcHBwTnBsTUpsTTlNOEZBWUNvS0FBQXBncURJTUFDd0FRYkJzQU1HUUFRYUNrR2cwR2d5Q2tHZUNnTkFCd0FBVWdyd0ErQ29BUU5BZUhDQU9BZUF5SVFIQndnRGc0UVlEQUdnTUVFT0VBZUEwUTREeEFIaDBQRU1HWU1Cc0ZRWURQZ29ETUdRVjROQnFyeUFaZmhHZndqTURsNFJ2L3dqY0dULzRSL0NQQkgvL2hINEgzZ3p2NE03QSsvZ3pvUjRHZEJuQWYrRFBCbndqNE03Qm53aXZBMVFJcENLY0lwZ2FxREZnYXFCb2dNV0JxZ0dxZ3hRaW5BMFhCaThJcUVVQ0tCRmNENy9DUHdqMEkrRFBBLzhHZkJuUVo4SStFZUNQd1o0UjZFZmhHY0kwR1NESURKQ05DTUJrZ2RzSXdHUURrQms0SElFWmd5NFJvSFp3WlFqY0R0Q01nY29SZ1JvUmdIS0RKQmw0UmdISURLRElFWUVhRVpneVlNb1JzSXdHUUdRSXdHVUdVSTNBNUFaTUkyRWFETEJsd2pRWlFqQWpBWlFvcUlxcU4rcHlweC9xTklxb3FxTktOS2NxY2h3R3JDQVBxTi8vUGtaT3NhQ2dqaUJVWlJua2hFQmZBZ3c5dHcraXUxUlVxcDJxTlVOYWxPVkcxR2tWL1U1OHNMVTQ4c0xMQ2l3RlU0aEFZQStxUVFnYXNWaFZJWVFOV0t3bUFLcHZhc05vSElEbTRPUUhJRGxHd05nYkg0RCtKdVdRbTRtaFpGb0pzV2dtNEk0VGNiQTJ4dEE1T0RuR3lOb0hKK05nSEtEbC9MTUJYTFV0UzA0bXZMUXRlQXFDYUNiRm9XUW1oYThiUTJBY2cyaHQ4YkkyUnNqYUd5TnJqWUd3TnZqYkJ5amEvR3hGWUU0aXBCT0lyd1RpSzRKMkt1SzhCQUs0ckFuQUp3S2tFNEZZRTdGVVZnRUlxZ0lSVkJPNHFSWEZRVkJWQk9NVndDY0U1aXRCT29xQW5RcUNwQk9JcnhWQk9vSjBLd0p4Z25RckN1S3NWQlhpb0NjQ3FDZEFuWUp5S3NWWXFpcEJPZ2p3aUFqLzhJbmhINFJNSWtJaW9BQzRSaUpDTVJQLy8vL0NOay8vQmxrdjRNNkY4STlDLzhHV1QvOEkyU3dqWk9FYkpRWlpJR1dTaEd5WU1zbndqMFAvLy9DUFEvaEd5UVJzbjhJMlNDTmtnT3lWa29Nc25oR3lRTXNsQ05rb01zbDRNc25oR3lYQ05rNE1zbUViSi93WlpQOEkyU0E3SldUZ3l5UU1pS0RJaWVFWWlBY1JJaWhHSWtJeEZ3WkVVSXhFQTRpUkVnY1JZaWhHSW9IRVNJa0RpSkVVSXhGd2pFUUl4RXdaRVdESWloR0lvUmlLRVlpSGNZSlJJcjlrekRtTzVjSWFBcFhFL05BMFRUVEtaR3ltLzAvL1BrWk1RV2pkQ3NBd0FXQ3NROENmd29lODljeWFYVEtaQUNnS3hzbXliUUZRQ3lQUVBVYlJ0QTl4NlFBb2VnSEttUnRDbHBrMFJTa3dhQ1lFL0d5YWFaNlpGSlRhYVRDYlRhYlRCb21nbWsybXhTMHgwd2FTYVRJMmdjZ09jVDBUNU1pZWRNOU05TkNmQ2VHZ05oTUpsTkpvVDFNZE5KaE1qYU5QcHROR2ttaHRwbm1nbXYrS1FtUlNFMGFhWTZaVEtaVFJvSmcwVTBhQm9wZzBlbVUxL3hQelRUYWE1bzgwRFJUWm9KczBUUk5FVWhNaWtKczBQMHgwd21rd21VeW1rd2FLYjVwcHBOSmcwT2FJbmhwR2dtZWFTYlRCcDlOL3B0TkpvMERUTkFiT0NrR0F3R0FCZ0E0Tmd3QUFBTUFQQmdBUUtBeURBWmdvQ2tGSU5BQUJXQUVEQVVCVEFBQmdNQlRncUFDRGNHQUFRWURBVXFMVWxWdC8vLytCajRNSVJjR0gvaEUvL2hFd1kvd2k4R1BCajhHSDhJZ1JjSXY0UllNUWkrREFJc0lzSW44R0hDTENKQ0ovQmhCZ0JwZ3d3aWZoRmhFaEYvZ3dDSURBR0lNSU1BTVFZQkZoRkJnREg0R0FNUWlRTkFZQXd3WUJFQ0lBTUlBTUFBaUhCZ0FNSUFpQUlnNE1BQmdBQmhBREFoRUFHQUFSQ0JoQ0VRaEVJTUFCaDZFUUF3SU1BQmdDRVF3TUFRWUQ0TURDSWNHQUNJUWlId1lHREFoRU9FUTRNQUVOQjhoSkQ3UHNuWEowZlo5OCtENkxJdFFSM1BnblpIbWdQWVlSb3BrMHhqLy9Qa1pNa1UvZ0xzS2tJVHJrTDBDZnpJZXR2Z0p0TmROR2tta3dDUExJVGY4cytXcGFGbUFwQWpnRlVzeXo0OWpTVENhR01ta3lhUlpsa0pzV3BhaWFnS0JabG1Xb21oOGMrQ2RjblJPajRQaytBa2g5RTZEc0owZko4YytPVHMraWRrNEoyVGcrajdQcjhuQjlud2ZBYTU5azc1OTgrRDc0U2srZUVrRlFkRG1Lc09od0JFVllDZUFpQW1BaUhjQkVWNENZQ0lXbUNIRjZGcUMwaGFSY0Y0WFl2eGZGMkx3dkMrRnFDMHhjQzBDL0Z3TFNGb0YwWEJmaTdDMHhlaThMd3ZjTFFMb1dvWGhlQzBCYUlXb1hCZGlOaU1ZNmNaOFJrWnhuanFPb2pBejR6eDBIVWRCR296am9NdzZpTWpweGRpK0w0dUM1Ri94ZC9oYUl1aS9iWi8rREdCcDRSWU1RWWd3OEl2Z3cvQ0o0UmZCaC9oRUNLQmdFVUdPREg4SW5oRndZNEdvTWNJZ1JJTWNJbkNJQnJCaENJRVNFU0JwK0RFR0FSZmhFQTFneEJqQmo0UkFZUVlneGdZd2lZUmNJZ01BaUF3QmpDSmdZQWF3WVlSUU1RTUFZaEZnYWdZaEVBMEF4QTFBMUNKQmhCZ0VYd01RTkFpaEZoRkF4d1lBd2dhWU1QQ0pBMWhFQmlCcndZUWl3WXdpQkZ3WWhGZ3hnYXdpaEZDTEEwZ1lBd0NLRVNCb0JwQ0o0TUlSY0dPRVZCOUFMUjhCSmo3L1BvbkI5SHlFb0p3Zlo5RTREdDVPZVRubHFKdHhOQUg3bndmSFBvbko4RTc1OUU2UG9KSS8vUGtaT0FXS2dqb1pVQVFZa2EwRmZnZ2U5VmNmWk9DZEU3SjBUbytDYzhKV1RvK0Q3SjBFcVBvTzArVDVQc0pTZko5bjBUa0pVZkpPZVRrblBQbyt6NkoyVHMreWNFNzU5L2s3UGcrejVKMlRvbkJPZVRrSlVUZytUNUR0SjBUdms1UGprNURYUGcraWRIMkhZZlI5RTZQZ25SOWs1SnlmWjljblI5Y05ZSlNmUk9pZEU2UHMrQ2RuMGZCOEU2RHRQcytDZEh3Zkg1T0FsUjhueWZCOTgrU2RFNEowZmY1T2lkSDJUa25mUGtKTWZZU2crQ2Q4K0Q2UHNuUC9Kd1RrKytmWVNRTzArRDVKMGZaOEh3VGpuMkFXRGdkQUw4QXBBTFFDa084R0FDd01neUFWQmlBVmh6d1k0QmVESU1nRk1PaDBBckRnYzRCZUFWNGNnRnNPaHovd1AyMjVIR3c3d0NzTzRNOEFxSFAvK0RFR1E3LzhPZ3pnRm9NNEJmNE1od080QlQ0Y0RtSGNHZkRudzc4R2NWaFVGVEZYRmVLb3FZSjNpc0t1S2tWZ1RzVm9xQ3NLd3JDb0tzVlFUcUtvcllXb1hoZnhlRi94ZGk1OFhPTDRXbUxuRllWUVRvRTRGWGl1SzBWd1RuRlFWUlZGY1ZoVTRKekZmRGdkaHpCbkR1SGZBTGd5REFNUVpCZ0dRQ2dCVUFvREFNaDNCa0FzRE1HY0dBWWd4Qm4rSEFDMEFyd0N3TUFTNWFkQXJ5MHlCU0Jmb0ZCVmFLcUt3VlVWclJYVWE5RlVPRXFWVWpWM3lTUExrdmt6bE5sTm4wMkUyUzA2cHZWS1dBQ0VDcFcvL1BrWk44VkRnait6eW1xNWtyYjFld0F4SnZrcWUxWHlzRFZGU3FsVklvMm8waXNweUZWb3FLTklyS2NxTktjS2NGaFNqYUtpS3lLaFlXaXY2bkNuQ0tpamFqU25Qb3JLTktjS2NxY0lycU5vcUtOcWNLTm9xS05LTnFOS2NJcUtOLy9vcmY2QlNiS2JLQlNCWGxwMEN2UUtUWVRaLzBDL0xUeEZ4Rm9pZ2lvaWdDTEM0Y1JZUldJdEVYQzRjUmNJMElvRnd3WENpS3dqUVhDOExoUkZjUmNSUVJTRndvaWtSY0xoeEZSRmd1SGlLUkY4RTdGWVZoVkJPZ0NZVlJVQUNLS2dxZ0UwRTZBQ0pGWVZvSjBDY2duUXJBbk1Wd1RnRTZpb0tvUndEZGhIaEc0UkFSZ0RjQ01FYUVZSWlBYndSSVJ1RVNFY0l3UndpWVJ3alFqQkVnV29GdUJhNEZuZ1drSVFRaWd3aEV3aWd4L0NMLzRSZkNLRVFHUC93WWlFVXdZSHdZR0RBd1lBR0E0UkNFUUJFR0IwckNOY0dVNFJyQmxjSXNHR0RDRVNCaUVXRENCaENJRVdCaURBR0hDS0VVR0VHRUdNSWdNQWl3aWd4Q0lEQURRR0lSZkNJRVFEWGdZWVJmQmdCb0VTRVh3WS9DSkNLRVFJc0dJUk9ERUdJUlFZZ3c4SWdSWU1NR0FHR0RFREdEQUlvTWNEUUlrR01HR0JyZ3dDS0RBSXNJa0RVRFdER0REQTFoRTRSUU1RWWd3QmhoRkJoQmg0TUFNWVJNSW9SQWlBeEJqaEY0bWhaRnB4TkJOeTBMUVRVVFhoS2dsUjlGcVdwYUFQNVppLy9Qa1pOWVhrZ1RrR0VKd2xrWGNEZlFBZTlyOGJDYS9rNUp3VHJpYWNzaXpCSEU2Q1NIMXc3ZWZITFBnanVKcVduTElUWVRYOHRSTkFIL2lhbHFKdUp1V1phRmtDTzRtNWFFN0oyVG9uQjhFNTU5bnlFbkp5ZkI4Rm1KcnhOeE5oTlMxRTNMVDhzeE5DMEUwTFRscUp1V1FtM0UxNVppYUZxV1JaaWFDYWdQNWFDYmxrS29xQ3NDZGlvS29xd1RvRTZGY1Z3QWhSV0JPSXJDcEZiZ25FVlJWRlVWSUoySzRyQW5JcWlvS2dyY1Y0cml1SzBFNEZjVlFUc1Z4VUJPb0ozRlVFN2l0RllFN0ZZVlJYRlVWd1RrVm9xQW5ZSnhCTzRyUmVGNFhZV3NMV0xvdWk0THd1QzlBZHNMUUwwTFFBOUM4TGd2aTZMZ3VCYWhmRndYQXRJdlFRNHZDcUt3cnhYLzhFNXhYaXQ0SndLekJud2orREYrRjFndXZCaVFZa0RSSVI4SS9nejhHZDRSL3dZc0dMQmk4SThEUEJuZURQQm53Wi84SThEUDhJOEIvMEdkK0RQQSs4SS8rRWYrRE9nenZ3ajRSL2hIb00rRWU0TTRENzRNK0VmL0EvN2dmY0RQQm40UjdCbmZDUGd6NE03Qm5nZjhEUHdqd1I2Qi8zQ1B3ajBHZmd6K0VmQm5oSDhHZndpb1JRR0lCcWdSVURWQVlvR2lCRmNJb0Jxb01XRVVBMVVEUllSVUlxRVVBMVdCb29HaUFhcUJvZ1JVR0p3aWdNOEkvZ3orRE9DUHdqL0Jud2ozQm5CSGdaNE00SStET2hIaE5DejVhaWFDYi8vUGtaTTBZdWdyZ0FBQVNCRVVFQmZRQWU5cmNsbVdvbXBaOHNoTnl6TE1zeTFMTUJVQWZoTnhOaWNCSkNjRTVKMEpweXlMTVRjQlZMWGxvQ081YUNhZ0tBQ2lBcWZscVdZbXZFM0UzQkhsbUFyRm54TlJOQzFMVUJTNWFGb1doWkZtV1I4azVDVG54ejRQb25aOEU1UGcrajRMVXNoTlFINFRZdFN6TE1zaE5CTmhOU3lBVml5RTBGUUU0RllWb0owQ2NSVWduWXFpc0tvSnhGV0FoaXVLZ3JDdEZVRTdGUUU1aXFLZ3FSVkZXS29yd1RzVnhWRllFN0ZURlRCT3hWZ25BcVJYQk9QaXNLNEJPSzBWb3JpdUswRTVCT3hVaXZGY0U1RllFNUZRVkJYRlFFNkZRVkJWRllWeFdpb0NjQ29Mb3ZpNExvV2lMMExTTCtMb3VCYUl2QmFoZGk2TG9XZ0VNRm9DMWhhY1h4ZEMxNHVpcGlxS244VlBGYmlxS3NWYi8vQm0vK0VYZ3g0UmRoRmIvLy9oRTEvOEdMUC8vQ0t3SXJRam9HYS93UGV3WnFFZFlNMXdacUROQWV0Z3pXRWQ4R2FnellNMkRONE0xd2pvSTdCbStETmhIY0QzckE5YXdadUVkd1p2Q093anNHYUE5NjRNMUE5NzhJN2hIUVIwRE5nZTk4STZoSFlSMXdackJtd1BXZ1BXd1pzSTd3anFCNjNDT3ZnelFSM0Jtd1pzR2FnZXQ4RDNyQ09nWm9HYTRSMWd6WU0wRWR3WnNJNkNPK0RONFIxd1pzRDNvR2FCbXdqcUVkQXpYQ08vNFIwRE5BellSMFdnSThUUVQvL1BrWkw0WEZnVGNBRTZUZWtmOEVmUUFlOXQ4WVRYaWFnS3dDc0p1V1hMTVRVdEMxTE1UVDhUWVRVSlArZkFkb21vbW9EOEp1V29DZ1dvSTdpYUZrSnFKcWZaOGhyazRDU0U1UGsrQ2RrNVBnbkJPVDdKd1RnK3VXWmFpYUNiY3NnRkFzeTBMUGxtSnNXWW1vbTVaRm1XcGFpYmlhQWp5MTVaRmtXUW01WmxsK0pzSnFKdnkxRTBDVGhKejY1T1FsSjhIMlRrblpPVDc1OWs2SjN6NFBnVFFUY3N5MExJVGZsbVdmTFVzaXlMSVRZVGNUVDhzeXpMUXNpMExNRWNXWmE4dFN5RTFMVGliaWJGcVdZSS84c2hOQ3lFMUxRc3kxTFVUVUJUTExsb1dYTFVzaXlMVXRCTitKcUp2eTFFMDVaOFRjc3hOZVduL0xUbnh5ZEh3Zlo5bjF5ZGs0UHNuSEp5ZlI5RTRKd1RnbkI4azQ1ODhuQjljblI4YytEN1BqeFY0cTRyOFZzVmdUZ0U0L2l0RlNoWC94VjRyaXJ4VkZXS29xNHFmeFg4RTZ4VnhVQk9ZckN0d1R2d1RqL3hWOEU1L2lyQk9zVnVLd3FSWEZURlFWb3JDckZmL3hXaW9Ld3JDdGlvQ2N4VUZVVkFUb0U0RlVWeFdGUVZoVUJPNHJnblVWSUp5S2tWZ1RvRTRpcEZVVm9xNHFpc0tzRTY0cUNvQ2R4VUZVVnhYRlVFNzhWeFdGUVY0cWl1S2dxaXVLNENDSzJLb3FpckJPQVRzRTRGV0s0cXhWRlVWaFZGWUU0Z25Jcml1Q2NRVGlLNHJDb0NkQ3RpckJPUlVpcUsyLy9Qa1pMQVdzZ3p1QURRTk5rWmovZmpJZTlyOEsvRlhGVVZ3U0U1YWlhQUtnbWhhRnB4TlFrcDhuM3o1UHNKT0dzZmZMUXN5eUUxTEl0UzFFMUFmK0NQTE1UVVRmaWJGbUpvV1FteGFuenlkSHdUc25BU2tuQmFDYWxxV29tNVpjc3hOeWM4bkFTc25IRHQ1OUJyaEpna3BPaWNCS2c3RDdKeWZaOEU1UGsrQ2Q4RWVXWEUwTFFzaXlMUXRTeUxJc2kwTFVUWXN5MEUzTElUUXNoTml5TFVzaXk0STc4c2hOeTBMTVZjRTZpcGduQXJSVmduY0U0d1RzVklyQ3FDY0N0Qk9ZcndUZ0U3aXVLd3FDb0t3cmNFN0JPUVRxS2dxaXFGcEJFQzFnUFlEM0YwWDRXb0xURjBYeGVpNkZxQzBCYUF0UVdnWHhkd3RXRnFDMGhhQlcvRlFWUlVCT0JVRmNFNmlvQ2NBbkVWUlg0cllyeFdGVVZCVml1THNYZ3RBdUM2Rm9CREJhWXZpN0Y4WHhleGRGOFhoY0Z5SS8vZ3gvL0NKQmhneGhFd1kvK0VYd1lneDhJbURIOEdQaEU4R1BoRXdpZ3doRndOUU5RTmZoRStER0RBR0hDSUJyaEVoRUJoNFJRTUFZL2dZQkZCaGhFQXhDSURDRVVERURIQmlFVUlvUlFZK0RDQnA0TWNHRUlnR2dNY0dJR01HSUdJR2dSUVlneENLQmlCakJnREdFU0RBRFdCZ0VVREVJdURBRFdCcEJpRVVERUREZ1lnd0JnREVEUURVR0lHZ1JBWVFZQXhDS0JoQ0tFVGhFQmdCaUVVR0lSUU1RaVFpd05BWS8vUGtaS3dXTmdqb1pVQVFSRWFrRmZRQWU5dDhZTWZ3aTRHQmFGb0pzV3BhRmx5eUJIY3RDekUyNVppYUZvQW9jc3kxRTI0U2sraWRrNkxNVFlUWVRRc3l5TFV0Q3lMUVRVc3dGWUpNR3VUZytDZEh3RXJQb3RBRkFzdUp0eE5DejRtNG12QkhpYWZsb1daWjhZcHBCcXpUTkkwalROQk1wZzBqVFRaWkZxV2ZFM0FmL3hOZitXb21oWjhzdVdaWkNiOHRDMUxRdFMxNG0vTFF0Qk5oTk9mUjhoS0NjOG5ISjJFcUNVRTVDU0h4eWRrNlBnK0Q3UHMrU2RrNkxVVFFUY1RjVGN0U3o0bXdtaGE4VFhsbUp2eXk1WmlhRmwrV3BaRm9XWmE4VFFzaE5DejRtaGFsbUpzV2ZMUXN1V1JhY3RCTlJOQzFFMUxMbGx5MEUyUGdKV2ZSOGgySDJmSk9TZG54K2ZYUHMrVDVQZ05ibnp6NlBvK1Q3SndUayt6NFBvblJPZ2xKODRxQ3Z4WHhVaXJGWDRxNHFlQ2QxZjhJbkNJLzRSL0NQLy80Uk1JL0NNRVlJNFJBUjhJOElqQ0o0UkVJL2dHOEVTRWZDT0VSQ1A0Ui8rRWFFUkNQQ05DTkNJNEJ2UWpZUk1ISU5vYklPZmpaQnpEWkczeHRqYTQyZ2N3MlB3Y3ZHMk5uZzUrTmdiWTJ3Y240Mmh0RFlHd05yallHd05zYlg0MnZ4c2NiSTJnYzNCemc1UWNnMnVOdmphR3dOZ2JJMitEbDRPVWJJMlFjNDJSc2piQnkvL2c1ZUFib1I0UndqUURlQ1ArRWNJOEl3QnV3andqQkVCRUEvL1BrWktvWk1ncnFBRFh0OUVWOEZmUUFlOXNjRytFVGhFQkdDTUVTRVNFYmhFUWp3andqd2pCSENJd2lRRGNDTkNJL2hIRTAvTFFCU0xJVGYvbHFXb1N2azdMVDhCV0xNdFJOQWs1OEU3UG8rQ3lMUVRjc3l5TFVzaTBBZmkxTFVUVVRVdEJOUzA1YUZrV3BaSHp3a29TZ25COUh3ZlFTc1RZc2l6TFF0Uk5STmdGZi84TmNKV0VtQVdDZG4wVG8rVDRDVUh5R3R4Tml5TFQvbG1KcUpxSnFXZ21wWkZxSnNXZ213bXdtd212NVppYWliaWFjdEJOdi95eUxUaWFGa1daYWdLZ0NtSnFXUW1nbW9tM0UwTFRpYkFLZkUwTExpdUtncllxaXBCTzRKekZVRTVCT1JYQk9oVmlvS3dxUldCT1lKeUtrRTZCT0lyWXFDcUNjeFZ4VkZVVjhFNEZTQ2RjVmdBZ0N1S2tMVEJEQzZDSGkrTHd1UmZoYTR1QytGcEY4WFF0QVdnQjJ3dEFXb1hCY2hhQmZ3dFFXbkZTQ2R4VnhYRlVWaFVGWVY0cmduT0szd1RpS2lyLy8xZURDc2YvLzcvK3dPWWQvLy9laS9mNmxtaXFHWHB5T2xDU1JtK3lQM1V0RGhGSXpxQmh3Q0ZIQUdGSEFCWUdjQW5BQU1PQUFZY0FBdzRCWUtPQUlST0FOZ2ljQVFZY0FCRTRBQXpnRTRCKzF3bWNBd1ljQUsrc0RPQURnRkxDSndBbFdCbkFCd0FCbkFCd0RXcmFFVGdFRE9BRGdEQmlSa2dvSnBHYVArNjRSU01vUlNNR0JpUmtrd01TTWxxN0F4SXk0Ly9Qa1pKVVlFZ2llQkZ3M2ZrTDhGZ0FpZWQ4QVJPQUFpY0E4RE9BVGdBR0hBQVJPQUZ3TTRCT0FHQmh3QUREZ0FHSEFOUVVjQWdpY0FZUk9BZmd3NEFJa2JQTk5OcG8wVFNOQk5KZ1VzMGw3bG9tRXdtUlNPYVJwODB6UUZLNG52VElublRFR2d3R3dBd1ltT21reWFJbnBwSnBNSmcwazErS1VhYWFUQ2I0MlUwbUJzR2lhU2FOTk5wbzBPYUtaTkUwalRUU1k1b0dtYVpwSnJwaE05TUdrbURRVENaQnpwZzBPS1IrbUJ0ZE1Kb2JmVFNiVGZHMktTYUJwR2dhWm9taWFCb21uMDJtT21rd21qU05QcGptbWFLWk5BMHpTTkZOQ2VDbEprVDQwRFRUQ1k1b0prMGt5YUpwZE1wcE1kTWROODBUUjZaVFhUZk5KTm1pbXVtZW0rYUtaVEthVGFhVFJvcHMwa3dhWnBwazArYVNhNlpUS1lUZlRmVFBUSFRLYTVvbWdtRXlhSm85Tm1rYVJwL3BubW1hZjZhTk5NcGxNcGxNZE1wdjhUeE1KbE5wbE5KbjlNZE0xT002aFdhL0VqaVJpUmlPL3hJY1NQK0dnQ1pRMStHdkRSRFYvLzRhUC8vLzRJOEV3VHdUQkx3Uy80QUhnbkJIQkhnaXdSNEpnQWdTNEl3QVlQQThBRGcrQUFBQUZ3ZkI0TDRXQURDMkFHQUdGd3NGd3VEMkZnQWNBUEMrRi9COEw0WC9CN0I0TDRXd3VEK0FHRHdYQUNBQUMyRDJBRUZnZkN3QUFBQVhCOExoY0xlRHdYQ3dQWVBBK0FDQUNEK0FINFh3QS8vUGtaSk1WSWdiMmVqVkx4a0JNRWdUSWU4OTh2d3Y0WC9BQ0IvQzRXd3RnQmcvZ0E0UEE5Z0JlRmhMUlRYVFJvbWttUDB5SjZKK21QeTBOQTBPdmliTkRRbWZ6VE5OTWphRktOQVR4TWllbWlhUm9Ha21FMm1rd21UUlRITkJNR2lhQ1pUU1pUWm9taDBQYVY5ZlgyaG9YMTRrelNtT2FDWTVwSnI4MFUwYVBUZk5GTXBzMGpTTkpNbWlhU2FUS2I2YVRLWU5McGhNcGcwZWFKb0drSjhhQm9wcE1wcE1KZzAweHpUVGFiTkZOSnBOSnBOcG5wZzBEVDZiVFJvcHBvSk1XclNoLzY5ME5RNXBhVjVEMmxlL0xORDJob1F4REYvcnpSMS9yL2FXaGZhV2xlUXhmWG1oZWFldk5EUzB0TFEwcnlHb2NoL1gxNUQrdkx5KzBvYzByeS8xOURVT1h1dkljMG9hdjlvWGtOWDEvcjNYMThRQ0dIUUdRSEI4UGlBUEFhSGdQRHNCZ2NIK0hxdi8vK0RKMEdOdUVXNE1iUVkyd1pPNFJuLy8vNFIzNFIzUWp2Ly84R2J2Ly84R2JnWnV3WnZDTzRHYnNEMzcrRWQzQTU4NkRKNFJuOERuVG9SbjhHVHNHVDhHVG9SbjRIT25neWY0SE9uQkdlREowSXpnak9DTThEblR3ak9neWR3T2RQNFJuWU1uY0RidHdZMkEyN2NJdGdOczNDTGVER3dNYndZM0NMYUVXd1JiUWkzQTI3ZURHMEdONEcyYkJGdkEyemNJdGdZM0EyN1lHTjRHMmJBeHRBNTgvZ2M2ZURKd0hPbkF5ZkNNN0E1ODgvL1BrWkxNWW5nVFNBRkFVaEVZY0RmZ2d3OVY4RG56d09kT0JrOEl6dUVaNE1uQXlmZ3ljaHN5N0Yzb0UxM05sOXN5N215cnNMNnFxT1U1YW5DcWtIcU5ESTNLVlVURVU4R05VN1U2Z3h5SEtjaHlWVi9YYTJac3BmZHMzcnViSzJWc2pabXp0azlkalppL1RaVjJOblhZdTB2c20weWFCb0RaTkViQTJrMGFLWk5qbXdiSC9Odm0yYlJ0R3lCVkFyRDFHMGJRUFVldmc5aDYvK1BSelpOa0NyelpOZ2VzZWdlc2VybXlQUVBYemJIcE52bTBQUVBVUFNiSnM4MlRhSHFBdGowODJoNkRhTm44ZW8yRGJIckhwTmpqMW0xellIcU5vMmpZTm5td2JQTmdlazJqYTVzajBEMW0wYkpzODB4dEpsTWRNQ2VwczBVMG1lYWFhNmI1cC9tbW1VM3pSVGZORk4vcGdIUHpRTlBta2FhYVRYVEtiVFJvSmswelM2Yi9OQk5kTkpsTkdqMDJhSDZaNElnQUVFWUo0SStDTUVRSmNFVUVYQk9wSERYL3cxUTBRMVExY05XR3Z3MFEwL2hwL0FtSWFBMGNDWWhvdzB3MS93MGhvRFJocHcxdzFCcmdUTERYdzFCcmhyRFFHZ05RRXpBbU9HdUdpR2dOZmdUSERRR29DWncxdzBCckRXQk1JRXpEVkRURFVHZ05mQUZ3R2pCcmcxQTFZTmNHc0FYQWFRYUFCY0JxZzFnMVFhZ2FJTllhb0V5dzFCb3cxWWFBMWhvRFNCTXcxZ1RJQ1lRSmtHckRRR29OR0dtR3NOY05RYXdKa0d1Qk00YUlhLy9Qa1pLQVluZ1RzQVRRTlFrS01GZ0RpZmg3QVlhZ0prR3NDWitHa05XR2lHc05BYVlhT0dnQ1lnVEVOUWF3MFlhdzFRMVEwL2hxdzFCa0FmbWthQ2I2WlRDWTZiTkJOTHdtcUdBNWZ6U1RDYi9sZ3dYT21NbU1tVFE1cG1rbVV3bWt5bWZ6UlRhWkZKNmFOTTAwMk5ycHBNcGcwa3dLUW1FMm0weUtVYUthRTk1bzlNSmo5TjlOSmswVXltT2FTYUUvVGFiTk5ObW1tazJtVTJhSFRLWlRDYU5EamFUSm9HaW1reU52cGswVFJUSFRmNmJUUm9wZzAwMSttVTBhWE5CTWpZTkEwazJtalI1cGZwczBVMTAwbVV6MHltMDJtRFJUSFRhYVRScHBsTWMwa3oweVNBMDAwbURTVEtiTkkwMDJtelFUSFRhWVRmLy9OQTB6UVRCb2ROSmswVXlLU2FhWk5KTXBybWthUDVvR21LVW1FeW1VeWFDYlRITkJNSmxOODBEUk5CTW1rbS8wMG1Vd2FacHBycGxOcHZtaWFKbzgwK2FTYS8vVGFZLzZaYUgvL3dZNFJlRVg0UklNZndpQXhCaC9CaENKLytFU0REd1ljSW4rRVFJb01BaVFZQXc4SXNHSUdHRVRCajRNUDRNUWlBeGhFQXdBeEF4QmpCaUVVSWdNSU1jRENEQUdJTWNHTURFR0dCZ0VVRFR3TmZBeDRNQWl3aVFZZ3dCZ0VVSWdNSVJBaVFZaEZ3WUF3QmhBMUNLREVJb0dvR2dNUWk0TWVEQURHRVFJa0lnR01EQ0RBSW9NQWlRaUFZd1lZTVFOUWlnd0NKQmlERUdBUi8vUGtaSndWK2d6b1pVQVFSa1pzQ2ZRQWU5dGNRWWd4OEdFR0lNUWl3TUFZNE1BTkFNY0lvTVN5RTFFMS9MTVRVdEN6NU9ENVBrSkp6NVBrK3VBL0ZxV1JhaWI4VFVUVVRRdEMwNWFscVdZbTRtb21nSThUWXN4TkN6RTNMVXRRRkVzZ0ZNK3o2SjBmQjhueitUc05jbkI5QksrVGsrZzdDZGhKVDZMVGlhRnFXWUk3bHFXb0N2eTA1WmxueE55MC9MVXNoTkJOdndSNG1vQ2orV3Y1WmxrSnFXcGFsa0NPRTFFMUxRc2l5TElUVUJVTExscVdaWmxtSnNXaFpjc2kxLzRDaVdwYWxrSnFKdVd2TFhsa0pzSnB5eTRtd201WmxtSnVXWExVVFF0ZVdnbWdtd0NzSm9XZkUzTE1zaXlMUDhUVGxrSnVBb2xxSnJ5ekUxTFRpYkNibG9KdVdoWkZvV1lteFo4VGNYSXZ4ZUMwaStGckYwQjJpNEw4TFNMNHVCYUlEeUNIRjhYUmZGNkZxZ2l3dEl1WVdvWElyWXFBbmNWdnhWaXA4VklxQ3ZVeFBxdEZiRmYvNHEvOFYvOFYvaXJpcmlyOFZBVGp4WGlweFdnbllxK0t3cWZGVEZRVm9xK0tzVkJXOFZoVWlzS3VLMFZSWGl2RllFNEZUQk9oVkZjVlJWNHJpdUNkQ3VDZEN0d1RpQ2NDcUNjZ25ZcXhXRmNWSUp3S3NWeFdpc0s4VnhWZ25BcllxUldGZUswVjRxZ25RcmduWXJmQk9vcUFuQXE0SjBDY2lxS3ZpdUszQk9vSnlLc0U0RlVWb3Fpc0syS3dyQW5BcmdCQUZTSzQvL1BrWkowVmFnanlKZ0d0YmtPa0Zmd0FiaDRBcVJWaXVLNEowS2dyQ3JGVVZ4VmpPRWVEUWdqbGNUNFQ0MHh0amFOSTB1YUkyUWNpR05KSWw0a0padENHSWFTY2tJbTZHTDNUUTJ6UlRZMlV3bWpTTkUwZnhTMDJhWTJCc0pzMC8rbXpTRThUUXBIVEtaVGFhRzBhUXBBcFpwL21tbSthSFRmVENaR3dOZ1VrMEUwYVJwL2lsSmxOSmdUNU1ta0o5elFOQTBUUVRINlpHMm1rMG1rMG1rM3pRVEtZL0czelFUSFRhYlRCcEdnbVUwYUthVEpwSnBOSnRNcGhOallUZk5FMGVta3ltRTJtRXlhQ2JOQk5mbWthSnBkTkpucGcwazBtRFRUQ2JUYVpUQnA4MGsyYUNiVGZORTAweWFDYjZiVFpvcGxNbW1hS1pUS2FUSnBtaWFIVFhOSk5kTURiVGFiNlk2WjZaTk5NSmhNSmhOOU5Kcm1pbTAybTB5bVUzMDBhUFRTYTZZLy81cEpwTmROLzlOcHB4V3hVNEp4L3hXeFUveFU0cWNWL2lwaXVLd3F4V0ZiaW9LLzhWSXFpdkZUd1RrVmdUa1ZvcjRKeEZYeFg4VmNWeFVGUUU0RmFDY3dUdkJPSXF3VG9WdUt3cUN0RlVWWXF4WHhXRmVLMEU3RlFWWXJ3VG53VHNWNHJDcUNjZkZhQ2NSVkZRRTVnbkFyNEp5SzRyNEp6NEowS29xaXA0ckN2aXNLb0ozeFdCT01FN2l1S2dyaXVLZ3JBbkFxZ25BcnhYaXFDY2duWUp6RlFWUVRtQUVJVllyd1RvQUlZcndUaUtrVlFUa0U1Ly9Qa1pLNFhHZ3pzQURRTkFrSWNDZndBZTg5OEZYRlRGWVZ4WHhVRlFWa3p6UzVvaWxnNVRUVFkya3lhSnBKdE5HZ0o4YUthVFEyazJhQ2FOSTBlYVNZTkpNL3RLSEVpUXhmSkcwOU1tZ2FTWVRScHBnMFRSTk5NSmxNcHRNQ2ZwcE5wcm1pYUEyalFOTG1tYVJwcGswalJGTE5QOU5KaE1HbWFRcFpwSmhOQ2tHa21FMEorbXhTazBtMHgwMm1qUlRLYlRDWjQyRXdhUXBKcHB0TnBybWdhUnBtaW0wMEo0bXpTTk0wa3lta3lLV21FMG11YUtZR3dOam1nYWZUUE5FMFUwbVV3SjcrbWVtMDErSjhtaFNrMm1qUlRTYjZhVENiTkJNOU1wanBqcHBNcGswRTJtRTJtRTJtalNUZlRhWjZZTkZNY1QxTXBucHJwdE5taW0wd21FMTAwYVNhVFJvOU1HanpUVEhUYWFUZlRTYU5McG9GTUFBRllOQlFHd0F2d0FZTTROZ3Fxa2phQU4zZDNkM2V0RVJOSzVDWi8zQ3RmOEFhaUFjL3U3dmFJbi8rOFhQdi8vK0dES3Y4VzEvK0FDOEs0WXcrOTR4ZTk0MGpnY2VPQndPY1JheEd3SDRFdU5JakJmeGF6QjhIaGt3VmpJQUlJL3ZEa2pHL3dBY0pQZUY1ZTk4aE5nU1lMV01GdmhaNzNwWDA2YW9laHBtaDAxaE1KdE05SzNUS1k5RTEweCttZW12bElwWk05TVVUQ2JTaGJVcnRNK241b3BoTlp1WEsrMHdtZW11bU1DZW1rbXZjMFV3bS9sSkpsTGU1b0paSTBTeVc2UjBtRS8vUGtaTGNYbGdyekVDRnZyRW1NRWZnQWZoN2syYU9ScGJUWVVvOVNCTnNla0dZTlZLZ3FnNmhyVVhLNFE0MkRPd1BXYklMRXpCU3VtRWdrV0pQVThTNzJHNXdVdUdEd2d1RUthMVEwVXlrUzNCbjdGSk5nZzVxb0VncHNHYWJCdEdhYlp0N05yS0NOZ0xZZXMxaWRtYWJCdG0yYlpzQlJtMFBRYkY5bXdQU1BVQmJNd3pCNlFvallNNDJlUFR6Yk13elI2VGFOczFlQlZOdjgxeURVSjJRWWhKdEQwbTBQVmUreDZUMk04SHNiRndzaDZCNkQ3SHB1Z1QydVpoTzZIcVpobUU3SVNaaGhrRk5jZ2h0bXliQm5uc0QxSG80OVp0RzJiWnM1UFZCYzJFRWVwQ2FFSE5qajFFSkhxNXNtYWJadG13Yk5FRVBSK2JKc2U5ejJQWTJUMVNOMHJkTkpxNnlYSTA2Q092TkpqOU1HbWtrR21VajdwSTBUVG9OR2xFc05FbkNXMTB5bWk1RnRORktwdnBzMGt6MHVXM2FhVEYwMG1UU3pkTkp1MEtGWXoxS2phR0FoeW9RQ0ZHTS8vekZBUmdJVVovb1pwZEN0dGF5Nk01ZHJXMWpvU2o2RWtrMWI3SjdSN2FvUU5sUHJXQktMVFR6T3NHVDV5WXhMcnRIVHkyaVV4RWtFUzBISUJWRDA2NlZqR2ozMW9kUGtrU2pKdGJXczZPSWpLbWxYSFI5SzVNVHY1cGRab2xFMTBrazJsbHk3NFRGeDVLVFhlVEdMclM2RXhpdWN2SlNTRFVkWFptM05MbjFydFlCQ1VFb1JqNzdXT2hDUGMrZzUvL1BrWko4WFBnem9BQUJNVHJ6OEJmUXlZOU9OR3hKVUx1dGFhMVRFNUxIeFdFbytYZWNtTWEzcDBrcUJDUjZxT0ZhRlVHcE5KSUlqcVZpMHlsQnFKSWtpU0pJa21KajYwNUVrU1JKUGV0V0F5VmFjbW9kQlVWaEdmckFaUEYwQVVyZ1JMTmlxRFU0VkhvOGg2SFJPYkpKTmRxbFJCTUZUMHFkTkUwV1pobWF5MnRDdU9ZNm9pZVdpZWlhbkNuVlNiempkN1NHaHJMaTZlVVNlTGNaVFdxZE1MNVBNNTB1T0dKbXM5VnF0WVU2aHJncm00VjBmclV6VHZZc2llZ1IyRk9rcVV4U0tkVkNwbVJDU2tJQVVaNFZQaHFFS2dGRFUyVmhVaUloVWFJZzBSQWtUQllFallCVWJCTXVDSmdMQWtDVUJVaW5BQmdCRTMvOUVRcUZSTTBzMHF6a3RrOVpGcXFGQzZSVUxFMTFKVkRrZDhZMXZWRk94OW9VSXBaOFZucTVrbGt4QlRVVXpMakV3TUtxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxXCI7dmFyIEk9QT0+QSBpbnN0YW5jZW9mIERhdGUsWT1BPT5udWxsPT1BO2NvbnN0IEQ9QT0+XCJvYmplY3RcIj09dHlwZW9mIEE7dmFyIEY9QT0+IVkoQSkmJiFBcnJheS5pc0FycmF5KEEpJiZEKEEpJiYhSShBKSxUPUE9PlkoQSl8fCFEKEEpO2Z1bmN0aW9uIG0oQSxvKXtpZihUKEEpfHxUKG8pKXJldHVybiBBPT09bztpZihJKEEpJiZJKG8pKXJldHVybiBBLmdldFRpbWUoKT09PW8uZ2V0VGltZSgpO2NvbnN0IGU9T2JqZWN0LmtleXMoQSksZz1PYmplY3Qua2V5cyhvKTtpZihlLmxlbmd0aCE9PWcubGVuZ3RoKXJldHVybiExO2Zvcihjb25zdCB0IG9mIGUpe2NvbnN0IGU9QVt0XTtpZighZy5pbmNsdWRlcyh0KSlyZXR1cm4hMTtpZihcInJlZlwiIT09dCl7Y29uc3QgQT1vW3RdO2lmKEkoZSkmJkkoQSl8fEYoZSkmJkYoQSl8fEFycmF5LmlzQXJyYXkoZSkmJkFycmF5LmlzQXJyYXkoQSk/IW0oZSxBKTplIT09QSlyZXR1cm4hMX19cmV0dXJuITB9Y29uc3QgVj17ZmFjaW5nTW9kZTpcImVudmlyb25tZW50XCIsd2lkdGg6e21pbjo2NDAsaWRlYWw6NzIwLG1heDoxOTIwfSxoZWlnaHQ6e21pbjo2NDAsaWRlYWw6NzIwLG1heDoxMDgwfX0sUT17ZmluZGVyOiEwLHRvcmNoOiEwLHRyYWNrZXI6dm9pZCAwLG9uT2ZmOiExLHpvb206ITF9LFI9e3dpZHRoOlwiMTAwJVwiLGhlaWdodDpcIjEwMCVcIixwb3NpdGlvbjpcInJlbGF0aXZlXCIsZGlzcGxheTpcImZsZXhcIixhbGlnbkl0ZW1zOlwiY2VudGVyXCIsanVzdGlmeUNvbnRlbnQ6XCJjZW50ZXJcIixvdmVyZmxvdzpcImhpZGRlblwiLGFzcGVjdFJhdGlvOlwiMS8xXCJ9LGQ9e3dpZHRoOlwiMTAwJVwiLGhlaWdodDpcIjEwMCVcIixvYmplY3RGaXQ6XCJjb3ZlclwiLG92ZXJmbG93OlwiaGlkZGVuXCJ9O2Z1bmN0aW9uIE4oQSxvKXtmb3IoY29uc3QgZSBvZiBBKXtjb25zdFtBLC4uLmddPWUuY29ybmVyUG9pbnRzO28ubGluZVdpZHRoPTIsby5zdHJva2VTdHlsZT1cInllbGxvd1wiLG8uYmVnaW5QYXRoKCksby5tb3ZlVG8oQS54LEEueSk7Zm9yKGNvbnN0e3g6QSx5OmV9b2YgZylvLmxpbmVUbyhBLGUpO28ubGluZVRvKEEueCxBLnkpLG8uY2xvc2VQYXRoKCksby5zdHJva2UoKX19ZnVuY3Rpb24gZihBLG8pe2Zvcihjb25zdCBlIG9mIEEpe2NvbnN0e2JvdW5kaW5nQm94Ont4OkEseTpnLHdpZHRoOnQsaGVpZ2h0Oml9fT1lO28ubGluZVdpZHRoPTIsby5zdHJva2VTdHlsZT1cInllbGxvd1wiLG8uc3Ryb2tlUmVjdChBLGcsdCxpKX19ZnVuY3Rpb24gdShBLG8pe0EuZm9yRWFjaCgoQT0+e2NvbnN0e2JvdW5kaW5nQm94OmUscmF3VmFsdWU6Z309QSx0PWUueCtlLndpZHRoLzIsaT1lLnkrZS5oZWlnaHQvMix3PU1hdGgubWF4KDEyLDUwKmUud2lkdGgvby5jYW52YXMud2lkdGgpLG49dztsZXQgYTtvLmZvbnQ9YCR7d31weCBzYW5zLXNlcmlmYCxvLnRleHRBbGlnbj1cImxlZnRcIjt0cnl7YT1KU09OLnN0cmluZ2lmeShKU09OLnBhcnNlKGcpLG51bGwsMil9Y2F0Y2goQSl7YT1nfWNvbnN0IEI9YS5zcGxpdChcIlxcblwiKSxyPU1hdGgubWF4KC4uLkIubWFwKChBPT5vLm1lYXN1cmVUZXh0KEEpLndpZHRoKSkpLHM9Qi5sZW5ndGgqbixDPXQtci8yLTEwLEU9aS1zLzItMTAsYz1yKzIwLGg9cysxMDtvLmJlZ2luUGF0aCgpLG8ubW92ZVRvKEMrOCxFKSxvLmxpbmVUbyhDK2MtOCxFKSxvLnF1YWRyYXRpY0N1cnZlVG8oQytjLEUsQytjLEUrOCksby5saW5lVG8oQytjLEUraC04KSxvLnF1YWRyYXRpY0N1cnZlVG8oQytjLEUraCxDK2MtOCxFK2gpLG8ubGluZVRvKEMrOCxFK2gpLG8ucXVhZHJhdGljQ3VydmVUbyhDLEUraCxDLEUraC04KSxvLmxpbmVUbyhDLEUrOCksby5xdWFkcmF0aWNDdXJ2ZVRvKEMsRSxDKzgsRSksby5jbG9zZVBhdGgoKSxvLmZpbGxTdHlsZT1cInJnYmEoMjU1LCAyNTUsIDAsIDAuOSlcIixvLmZpbGwoKSxCLmZvckVhY2goKChBLGUpPT57Y29uc3QgZz1pK2Uqbi0oQi5sZW5ndGgtMSkqbi8yO2xldCB3PXQtci8yLGE9MDtjb25zdCBzPVsuLi5BLm1hdGNoQWxsKC9cIihbXlwiXSspXCI6L2cpXSxDPVsuLi5BLm1hdGNoQWxsKC86XFxzKihcIlteXCJdKlwifFxcZCt8dHJ1ZXxmYWxzZXxudWxsKS9nKV07cy5mb3JFYWNoKCgoZSx0KT0+e3ZhciBpLG47Y29uc3QgQj1lWzBdLnJlcGxhY2UoXCI6XCIsXCJcIikscj1BLnN1YnN0cmluZyhhLGUuaW5kZXgpO2lmKG8uZmlsbFN0eWxlPVwiYmxhY2tcIixvLmZpbGxUZXh0KHIsdyxnKSx3Kz1vLm1lYXN1cmVUZXh0KHIpLndpZHRoLG8uZmlsbFN0eWxlPVwiYmx1ZVwiLG8uZmlsbFRleHQoQix3LGcpLHcrPW8ubWVhc3VyZVRleHQoQikud2lkdGgsYT1lLmluZGV4K0IubGVuZ3RoLG8uZmlsbFN0eWxlPVwiYmxhY2tcIixvLmZpbGxUZXh0KFwiOiBcIix3LGcpLHcrPW8ubWVhc3VyZVRleHQoXCI6IFwiKS53aWR0aCx0PEMubGVuZ3RoKXtjb25zdCBlPUNbdF0sQj1BLnN1YnN0cmluZyhhLGUuaW5kZXgpO28uZmlsbFN0eWxlPVwiYmxhY2tcIixvLmZpbGxUZXh0KEIsdyxnKSx3Kz1vLm1lYXN1cmVUZXh0KEIpLndpZHRoO2NvbnN0IHI9bnVsbCE9PShuPW51bGw9PT0oaT1lWzBdLm1hdGNoKC86XFxzKiguKikvKSl8fHZvaWQgMD09PWk/dm9pZCAwOmlbMV0pJiZ2b2lkIDAhPT1uP246XCJcIjtvLmZpbGxTdHlsZT1cImdyZWVuXCIsby5maWxsVGV4dChyLHcsZyksdys9by5tZWFzdXJlVGV4dChyKS53aWR0aCxhPWUuaW5kZXgrZVswXS5sZW5ndGh9fSkpLG8uZmlsbFN0eWxlPVwiYmxhY2tcIjtjb25zdCBFPUEuc3Vic3RyaW5nKGEpO28uZmlsbFRleHQoRSx3LGcpfSkpfSkpfWZ1bmN0aW9uIHAoQSl7aWYobnVsbD09PUEpdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIHNob3VsZCBhbHdheXMgYmUgZGVmaW5lZCB3aGVuIGNvbXBvbmVudCBpcyBtb3VudGVkLlwiKTtjb25zdCBvPUEuZ2V0Q29udGV4dChcIjJkXCIpO2lmKG51bGw9PT1vKXRocm93IG5ldyBFcnJvcihcIkNhbnZhcyAyRCBjb250ZXh0IHNob3VsZCBiZSBub24tbnVsbFwiKTtvLmNsZWFyUmVjdCgwLDAsQS53aWR0aCxBLmhlaWdodCl9ZnVuY3Rpb24gayhlKXt2YXIgYTtjb25zdHtvblNjYW46Qixjb25zdHJhaW50czpyLGZvcm1hdHM6cz1bXCJxcl9jb2RlXCJdLHBhdXNlZDpDPSExLGNvbXBvbmVudHM6RSxjaGlsZHJlbjpjLHN0eWxlczpoLGNsYXNzTmFtZXM6cSxhbGxvd011bHRpcGxlOmwsc2NhbkRlbGF5Okksb25FcnJvcjpZLHNvdW5kOkR9PWUsRj1nKG51bGwpLFQ9ZyhudWxsKSxOPWcobnVsbCksZj13KCgoKT0+KHsuLi5WLC4uLnJ9KSksW3JdKSx1PXcoKCgpPT4oey4uLlEsLi4uRX0pKSxbRV0pLFtrLEtdPW8oITEpLFt5LExdPW8oITApLFtKLHhdPW8oZiksVT1mdW5jdGlvbigpe2NvbnN0IEE9ZyhQcm9taXNlLnJlc29sdmUoe3R5cGU6XCJzdG9wXCIsZGF0YTp7fX0pKSxlPWcobnVsbCksdz1nKG51bGwpLFtuLGFdPW8oe30pLFtCLHJdPW8oe30pLHM9dCgoYXN5bmMoQSxvKT0+e3ZhciBnLHQsaTtpZighd2luZG93LmlzU2VjdXJlQ29udGV4dCl0aHJvdyBuZXcgRXJyb3IoXCJjYW1lcmEgYWNjZXNzIGlzIG9ubHkgcGVybWl0dGVkIGluIHNlY3VyZSBjb250ZXh0LiBVc2UgSFRUUFMgb3IgbG9jYWxob3N0IHJhdGhlciB0aGFuIEhUVFAuXCIpO2lmKHZvaWQgMD09PShudWxsPT09KGc9bnVsbD09PW5hdmlnYXRvcnx8dm9pZCAwPT09bmF2aWdhdG9yP3ZvaWQgMDpuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKXx8dm9pZCAwPT09Zz92b2lkIDA6Zy5nZXRVc2VyTWVkaWEpKXRocm93IG5ldyBFcnJvcihcInRoaXMgYnJvd3NlciBoYXMgbm8gU3RyZWFtIEFQSSBzdXBwb3J0XCIpO2NvbnN0IG49YXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe2F1ZGlvOiExLHZpZGVvOm99KTt2b2lkIDAhPT1BLnNyY09iamVjdD9BLnNyY09iamVjdD1uOnZvaWQgMCE9PUEubW96U3JjT2JqZWN0P0EubW96U3JjT2JqZWN0PW46d2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkw/QS5zcmM9d2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobik6d2luZG93LndlYmtpdFVSTD9BLnNyYz13aW5kb3cud2Via2l0VVJMLmNyZWF0ZU9iamVjdFVSTChuKTpBLnNyYz1uLmlkLGF3YWl0IFByb21pc2UucmFjZShbQS5wbGF5KCksbmV3IFByb21pc2UoKEE9PnNldFRpbWVvdXQoQSwzZTMpKSkudGhlbigoKCk9Pnt0aHJvdyBuZXcgRXJyb3IoXCJMb2FkaW5nIGNhbWVyYSBzdHJlYW0gdGltZWQgb3V0IGFmdGVyIDMgc2Vjb25kcy5cIil9KSldKSxhd2FpdCBuZXcgUHJvbWlzZSgoQT0+c2V0VGltZW91dChBLDUwMCkpKTtjb25zdFtCXT1uLmdldFZpZGVvVHJhY2tzKCk7cmV0dXJuIHIoQi5nZXRTZXR0aW5ncygpKSxhKG51bGwhPT0oaT1udWxsPT09KHQ9bnVsbD09Qj92b2lkIDA6Qi5nZXRDYXBhYmlsaXRpZXMpfHx2b2lkIDA9PT10P3ZvaWQgMDp0LmNhbGwoQikpJiZ2b2lkIDAhPT1pP2k6e30pLGUuY3VycmVudD1uLHcuY3VycmVudD1CLHt0eXBlOlwic3RhcnRcIixkYXRhOnt2aWRlb0VsOkEsc3RyZWFtOm4sY29uc3RyYWludHM6b319fSksW10pLEM9dCgoYXN5bmMoQSxvKT0+e0Euc3JjPVwiXCIsQS5zcmNPYmplY3Q9bnVsbCxBLmxvYWQoKTtmb3IoY29uc3QgQSBvZiBvLmdldFRyYWNrcygpKW8ucmVtb3ZlVHJhY2soQSksQS5zdG9wKCk7cmV0dXJuIGUuY3VycmVudD1udWxsLHcuY3VycmVudD1udWxsLHIoe30pLHt0eXBlOlwic3RvcFwiLGRhdGE6e319fSksW10pLEU9dCgoYXN5bmMobyx7Y29uc3RyYWludHM6ZSxyZXN0YXJ0Omc9ITF9KT0+e2lmKEEuY3VycmVudD1BLmN1cnJlbnQudGhlbigoQT0+e2lmKFwic3RhcnRcIj09PUEudHlwZSl7Y29uc3R7ZGF0YTp7dmlkZW9FbDp0LHN0cmVhbTppLGNvbnN0cmFpbnRzOnd9fT1BO3JldHVybiBnfHxvIT09dHx8ZSE9PXc/Qyh0LGkpLnRoZW4oKCgpPT5zKG8sZSkpKTpBfXJldHVybiBzKG8sZSl9KSksXCJzdG9wXCI9PT0oYXdhaXQgQS5jdXJyZW50KS50eXBlKXRocm93IG5ldyBFcnJvcihcIlNvbWV0aGluZyB3ZW50IHdyb25nIHdpdGggdGhlIGNhbWVyYSB0YXNrIHF1ZXVlIChzdGFydCB0YXNrKS5cIil9KSxbcyxDXSksYz10KChhc3luYygpPT57aWYoQS5jdXJyZW50PUEuY3VycmVudC50aGVuKChBPT57aWYoXCJzdG9wXCI9PT1BLnR5cGUpcmV0dXJuIEE7Y29uc3R7ZGF0YTp7dmlkZW9FbDpvLHN0cmVhbTplfX09QTtyZXR1cm4gQyhvLGUpfSkpLFwic3RhcnRcIj09PShhd2FpdCBBLmN1cnJlbnQpLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiU29tZXRoaW5nIHdlbnQgd3Jvbmcgd2l0aCB0aGUgY2FtZXJhIHRhc2sgcXVldWUgKHN0b3AgdGFzaykuXCIpfSksW0NdKSxoPXQoKGFzeW5jIEE9Pntjb25zdCBvPXcuY3VycmVudDtpZighbyl0aHJvdyBuZXcgRXJyb3IoXCJObyBhY3RpdmUgdmlkZW8gdHJhY2sgZm91bmQuXCIpO3tBLmFkdmFuY2VkJiZBLmFkdmFuY2VkWzBdLnpvb20mJm8uZ2V0Q2FwYWJpbGl0aWVzKCkudG9yY2gmJmF3YWl0IG8uYXBwbHlDb25zdHJhaW50cyh7YWR2YW5jZWQ6W3t0b3JjaDohMX1dfSksYXdhaXQgby5hcHBseUNvbnN0cmFpbnRzKEEpO2NvbnN0IGU9by5nZXRDYXBhYmlsaXRpZXMoKSxnPW8uZ2V0U2V0dGluZ3MoKTthKGUpLHIoZyl9fSksW10pO3JldHVybiBpKCgoKT0+KCk9PnsoYXN5bmMoKT0+e2F3YWl0IGMoKX0pKCl9KSxbY10pLHtjYXBhYmlsaXRpZXM6bixzZXR0aW5nczpCLHN0YXJ0Q2FtZXJhOkUsc3RvcENhbWVyYTpjLHVwZGF0ZUNvbnN0cmFpbnRzOmh9fSgpLHtzdGFydFNjYW5uaW5nOlosc3RvcFNjYW5uaW5nOld9PWZ1bmN0aW9uKEEpe2NvbnN0e3ZpZGVvRWxlbWVudFJlZjpvLG9uU2NhbjplLG9uRm91bmQ6dyxyZXRyeURlbGF5OmE9MTAwLHNjYW5EZWxheTpCPTAsZm9ybWF0czpyPVtdLGFsbG93TXVsdGlwbGU6cz0hMSxzb3VuZDpDPSEwfT1BLEU9ZyhuZXcgbih7Zm9ybWF0czpyfSkpLGM9ZyhudWxsKSxoPWcobnVsbCk7aSgoKCk9PntFLmN1cnJlbnQ9bmV3IG4oe2Zvcm1hdHM6cn0pfSksW3JdKSxpKCgoKT0+e1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJkMmJihjLmN1cnJlbnQ9bmV3IEF1ZGlvKFwic3RyaW5nXCI9PXR5cGVvZiBDP0M6RykpfSksW0NdKTtjb25zdCBxPXQoKEE9PmFzeW5jIGc9PntpZihudWxsIT09by5jdXJyZW50JiZvLmN1cnJlbnQucmVhZHlTdGF0ZT4xKXtjb25zdHtsYXN0U2Nhbjp0LGNvbnRlbnRCZWZvcmU6aSxsYXN0U2NhbkhhZENvbnRlbnQ6bn09QTtpZihnLXQ8YSloLmN1cnJlbnQ9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShxKEEpKTtlbHNle2NvbnN0IHQ9YXdhaXQgRS5jdXJyZW50LmRldGVjdChvLmN1cnJlbnQpLGE9dC5zb21lKChBPT4haS5pbmNsdWRlcyhBLnJhd1ZhbHVlKSkpLHI9dC5sZW5ndGg+MDtsZXQgbD1BLmxhc3RPblNjYW47KGF8fHMmJnImJmctbD49QikmJihDJiZjLmN1cnJlbnQmJmMuY3VycmVudC5wYXVzZWQmJmMuY3VycmVudC5wbGF5KCkuY2F0Y2goKEE9PmNvbnNvbGUuZXJyb3IoXCJFcnJvciBwbGF5aW5nIHRoZSBzb3VuZFwiLEEpKSksbD1nLGUodCkpLHImJncodCksIXImJm4mJncodCk7Y29uc3QgTT17bGFzdFNjYW46ZyxsYXN0T25TY2FuOmwsbGFzdFNjYW5IYWRDb250ZW50OnIsY29udGVudEJlZm9yZTphP3QubWFwKChBPT5BLnJhd1ZhbHVlKSk6aX07aC5jdXJyZW50PXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocShNKSl9fX0pLFtvLmN1cnJlbnQsZSx3LGFdKTtyZXR1cm57c3RhcnRTY2FubmluZzp0KCgoKT0+e2NvbnN0IEE9cGVyZm9ybWFuY2Uubm93KCksbz17bGFzdFNjYW46QSxsYXN0T25TY2FuOkEsY29udGVudEJlZm9yZTpbXSxsYXN0U2NhbkhhZENvbnRlbnQ6ITF9O2guY3VycmVudD13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHEobykpfSksW3FdKSxzdG9wU2Nhbm5pbmc6dCgoKCk9PntudWxsIT09aC5jdXJyZW50JiYod2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGguY3VycmVudCksaC5jdXJyZW50PW51bGwpfSksW10pfX0oe3ZpZGVvRWxlbWVudFJlZjpGLG9uU2NhbjpCLG9uRm91bmQ6QT0+ZnVuY3Rpb24oQSxvLGUsZyl7Y29uc3QgdD1lO2lmKG51bGw9PXQpdGhyb3cgbmV3IEVycm9yKFwib25Gb3VuZCBoYW5kbGVyIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuIGNvbXBvbmVudCBpcyBtb3VudGVkLiBUaHVzIHRyYWNraW5nIGNhbnZhcyBpcyBhbHdheXMgZGVmaW5lZC5cIik7Y29uc3QgaT1vO2lmKG51bGw9PWkpdGhyb3cgbmV3IEVycm9yKFwib25Gb3VuZCBoYW5kbGVyIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuIGNvbXBvbmVudCBpcyBtb3VudGVkLiBUaHVzIHZpZGVvIGVsZW1lbnQgaXMgYWx3YXlzIGRlZmluZWQuXCIpO2lmKDA9PT1BLmxlbmd0aHx8dm9pZCAwPT09ZylwKHQpO2Vsc2V7Y29uc3Qgbz1pLm9mZnNldFdpZHRoLGU9aS5vZmZzZXRIZWlnaHQsdz1pLnZpZGVvV2lkdGgsbj1pLnZpZGVvSGVpZ2h0LGE9TWF0aC5tYXgoby93LGUvbiksQj13KmEscj1uKmEscz1CL3csQz1yL24sRT0oby1CKS8yLGM9KGUtcikvMixoPSh7eDpBLHk6b30pPT4oe3g6TWF0aC5mbG9vcihBKnMpLHk6TWF0aC5mbG9vcihvKkMpfSkscT0oe3g6QSx5Om99KT0+KHt4Ok1hdGguZmxvb3IoQStFKSx5Ok1hdGguZmxvb3IobytjKX0pLGw9QS5tYXAoKEE9Pntjb25zdHtib3VuZGluZ0JveDpvLGNvcm5lclBvaW50czplfT1BLHt4OmcseTp0fT1xKGgoe3g6by54LHk6by55fSkpLHt4OmkseTp3fT1oKHt4Om8ud2lkdGgseTpvLmhlaWdodH0pO3JldHVybnsuLi5BLGNvcm5lclBvaW50czplLm1hcCgoQT0+cShoKEEpKSkpLGJvdW5kaW5nQm94OkRPTVJlY3RSZWFkT25seS5mcm9tUmVjdCh7eDpnLHk6dCx3aWR0aDppLGhlaWdodDp3fSl9fSkpO3Qud2lkdGg9aS5vZmZzZXRXaWR0aCx0LmhlaWdodD1pLm9mZnNldEhlaWdodDtjb25zdCBNPXQuZ2V0Q29udGV4dChcIjJkXCIpO2lmKG51bGw9PT1NKXRocm93IG5ldyBFcnJvcihcIm9uRm91bmQgaGFuZGxlciBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlbiBjb21wb25lbnQgaXMgbW91bnRlZC4gVGh1cyB0cmFja2luZyBjYW52YXMgMkQgY29udGV4dCBpcyBhbHdheXMgZGVmaW5lZC5cIik7ZyhsLE0pfX0oQSxGLmN1cnJlbnQsTi5jdXJyZW50LHUudHJhY2tlciksZm9ybWF0czpzLHJldHJ5RGVsYXk6dm9pZCAwPT09dS50cmFja2VyPzUwMDoxMCxzY2FuRGVsYXk6SSxhbGxvd011bHRpcGxlOmwsc291bmQ6RH0pO2koKCgpPT4oSyghMCksKCk9PntLKCExKX0pKSxbXSksaSgoKCk9PntrJiYoVygpLFooKSl9KSxbbnVsbD09RT92b2lkIDA6RS50cmFja2VyXSksaSgoKCk9PntpZighbShmLEopKXtjb25zdCBBPWY7KG51bGw9PXI/dm9pZCAwOnIuZGV2aWNlSWQpJiZkZWxldGUgQS5mYWNpbmdNb2RlLHgoQSl9fSksW3JdKTtjb25zdCB2PXcoKCgpPT4oe2NvbnN0cmFpbnRzOkosc2hvdWxkU3RyZWFtOmsmJiFDfSkpLFtKLGssQ10pLGI9YXN5bmMoKT0+e2NvbnN0IEE9Ri5jdXJyZW50O2lmKG51bGw9PUEpdGhyb3cgbmV3IEVycm9yKFwiVmlkZW8gc2hvdWxkIGJlIGRlZmluZWQgd2hlbiBjb21wb25lbnQgaXMgbW91bnRlZC5cIik7Y29uc3Qgbz1ULmN1cnJlbnQ7aWYobnVsbD09byl0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgc2hvdWxkIGJlIGRlZmluZWQgd2hlbiBjb21wb25lbnQgaXMgbW91bnRlZC5cIik7Y29uc3QgZT1vLmdldENvbnRleHQoXCIyZFwiKTtpZihudWxsPT1lKXRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBzaG91bGQgYmUgZGVmaW5lZCB3aGVuIGNvbXBvbmVudCBpcyBtb3VudGVkLlwiKTtpZih2LnNob3VsZFN0cmVhbSl7YXdhaXQgVS5zdG9wQ2FtZXJhKCksTCghMSk7dHJ5e2F3YWl0IFUuc3RhcnRDYW1lcmEoQSx2KSxBP0woITApOmF3YWl0IFUuc3RvcENhbWVyYSgpfWNhdGNoKEEpe251bGw9PVl8fFkoQSksY29uc29sZS5lcnJvcihcImVycm9yXCIsQSl9fWVsc2Ugby53aWR0aD1BLnZpZGVvV2lkdGgsby5oZWlnaHQ9QS52aWRlb0hlaWdodCxlLmRyYXdJbWFnZShBLDAsMCxBLnZpZGVvV2lkdGgsQS52aWRlb0hlaWdodCksYXdhaXQgVS5zdG9wQ2FtZXJhKCksTCghMSl9O2koKCgpPT57KGFzeW5jKCk9Pnthd2FpdCBiKCl9KSgpfSksW3ZdKTtjb25zdCBPPXcoKCgpPT52LnNob3VsZFN0cmVhbSYmeSksW3Yuc2hvdWxkU3RyZWFtLHldKTtyZXR1cm4gaSgoKCk9PntpZihPKXtpZih2b2lkIDA9PT1ULmN1cnJlbnQpdGhyb3cgbmV3IEVycm9yKFwic2hvdWxkU2NhbiBlZmZlY3Qgc2hvdWxkIG9ubHkgYmUgdHJpZ2dlcmVkIHdoZW4gY29tcG9uZW50IGlzIG1vdW50ZWQuIFRodXMgcGF1c2UgZnJhbWUgY2FudmFzIGlzIGRlZmluZWRcIik7aWYocChULmN1cnJlbnQpLHZvaWQgMD09PU4uY3VycmVudCl0aHJvdyBuZXcgRXJyb3IoXCJzaG91bGRTY2FuIGVmZmVjdCBzaG91bGQgb25seSBiZSB0cmlnZ2VyZWQgd2hlbiBjb21wb25lbnQgaXMgbW91bnRlZC4gVGh1cyB0cmFja2luZyBjYW52YXMgaXMgZGVmaW5lZFwiKTtwKE4uY3VycmVudCk7Y29uc3QgQT1GLmN1cnJlbnQ7aWYobnVsbD09QSl0aHJvdyBuZXcgRXJyb3IoXCJzaG91bGRTY2FuIGVmZmVjdCBzaG91bGQgb25seSBiZSB0cmlnZ2VyZWQgd2hlbiBjb21wb25lbnQgaXMgbW91bnRlZC4gVGh1cyB2aWRlbyBlbGVtZW50IGlzIGRlZmluZWRcIik7WigpfX0pLFtPXSksQS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse3N0eWxlOnsuLi5SLC4uLm51bGw9PWg/dm9pZCAwOmguY29udGFpbmVyfSxjbGFzc05hbWU6bnVsbD09cT92b2lkIDA6cS5jb250YWluZXJ9LEEuY3JlYXRlRWxlbWVudChcInZpZGVvXCIse3JlZjpGLHN0eWxlOnsuLi5kLC4uLm51bGw9PWg/dm9pZCAwOmgudmlkZW8sdmlzaWJpbGl0eTpDP1wiaGlkZGVuXCI6XCJ2aXNpYmxlXCJ9LGNsYXNzTmFtZTpudWxsPT1xP3ZvaWQgMDpxLnZpZGVvLGF1dG9QbGF5OiEwLG11dGVkOiEwLHBsYXlzSW5saW5lOiEwfSksQS5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIse3JlZjpULHN0eWxlOntkaXNwbGF5OkM/XCJibG9ja1wiOlwibm9uZVwiLHBvc2l0aW9uOlwiYWJzb2x1dGVcIix3aWR0aDpcIjEwMCVcIixoZWlnaHQ6XCIxMDAlXCJ9fSksQS5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIse3JlZjpOLHN0eWxlOntwb3NpdGlvbjpcImFic29sdXRlXCIsd2lkdGg6XCIxMDAlXCIsaGVpZ2h0OlwiMTAwJVwifX0pLEEuY3JlYXRlRWxlbWVudChcImRpdlwiLHtzdHlsZTp7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHdpZHRoOlwiMTAwJVwiLGhlaWdodDpcIjEwMCVcIn19LHUuZmluZGVyJiZBLmNyZWF0ZUVsZW1lbnQoTSx7c2Nhbm5pbmc6eSxjYXBhYmlsaXRpZXM6VS5jYXBhYmlsaXRpZXMsb25PZmY6dS5vbk9mZix6b29tOnUuem9vbSYmVS5zZXR0aW5ncy56b29tP3t2YWx1ZTpVLnNldHRpbmdzLnpvb20sb25DaGFuZ2U6YXN5bmMgQT0+e2NvbnN0IG89ey4uLkosYWR2YW5jZWQ6W3t6b29tOkF9XX07YXdhaXQgVS51cGRhdGVDb25zdHJhaW50cyhvKX19OnZvaWQgMCx0b3JjaDp1LnRvcmNoP3tzdGF0dXM6bnVsbCE9PShhPVUuc2V0dGluZ3MudG9yY2gpJiZ2b2lkIDAhPT1hJiZhLHRvZ2dsZTphc3luYyBBPT57Y29uc3Qgbz17Li4uSixhZHZhbmNlZDpbe3RvcmNoOkF9XX07YXdhaXQgVS51cGRhdGVDb25zdHJhaW50cyhvKX19OnZvaWQgMCxzdGFydFNjYW5uaW5nOmFzeW5jKCk9PmF3YWl0IGIoKSxzdG9wU2Nhbm5pbmc6YXN5bmMoKT0+e2F3YWl0IFUuc3RvcENhbWVyYSgpLHAoTi5jdXJyZW50KSxMKCExKX19KSxjKSl9ZnVuY3Rpb24gSygpe2NvbnN0W0EsZV09byhbXSk7cmV0dXJuIGkoKCgpPT57KGFzeW5jKCk9PntlKGF3YWl0IGFzeW5jIGZ1bmN0aW9uKCl7cmV0dXJuKGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpKS5maWx0ZXIoKCh7a2luZDpBfSk9PlwidmlkZW9pbnB1dFwiPT09QSkpfSgpKX0pKCl9KSxbXSksQX1leHBvcnR7ayBhcyBTY2FubmVyLGYgYXMgYm91bmRpbmdCb3gsdSBhcyBjZW50ZXJUZXh0LE4gYXMgb3V0bGluZSxLIGFzIHVzZURldmljZXN9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@yudiel/react-qr-scanner/dist/index.esm.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/barcode-detector/dist/es/index.js":
/*!********************************************************!*\
  !*** ./node_modules/barcode-detector/dist/es/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BarcodeDetector: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__.BarcodeDetector),\n/* harmony export */   ZXING_CPP_COMMIT: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__.ZXING_CPP_COMMIT),\n/* harmony export */   ZXING_WASM_SHA256: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__.ZXING_WASM_SHA256),\n/* harmony export */   ZXING_WASM_VERSION: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__.ZXING_WASM_VERSION),\n/* harmony export */   prepareZXingModule: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__.prepareZXingModule),\n/* harmony export */   purgeZXingModule: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__.purgeZXingModule),\n/* harmony export */   setZXingModuleOverrides: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__.setZXingModuleOverrides)\n/* harmony export */ });\n/* harmony import */ var _polyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polyfill.js */ \"(app-pages-browser)/./node_modules/barcode-detector/dist/es/polyfill.js\");\n/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ponyfill.js */ \"(app-pages-browser)/./node_modules/barcode-detector/dist/es/ponyfill.js\");\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iYXJjb2RlLWRldGVjdG9yL2Rpc3QvZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXVCO0FBQ29MO0FBU3pNIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9iYXJjb2RlLWRldGVjdG9yL2Rpc3QvZXMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFwiLi9wb2x5ZmlsbC5qc1wiO1xuaW1wb3J0IHsgQmFyY29kZURldGVjdG9yIGFzIE0sIFpYSU5HX0NQUF9DT01NSVQgYXMgWCwgWlhJTkdfV0FTTV9TSEEyNTYgYXMgWiwgWlhJTkdfV0FTTV9WRVJTSU9OIGFzIF8sIHByZXBhcmVaWGluZ01vZHVsZSBhcyBkLCBwdXJnZVpYaW5nTW9kdWxlIGFzIGksIHNldFpYaW5nTW9kdWxlT3ZlcnJpZGVzIGFzIHAgfSBmcm9tIFwiLi9wb255ZmlsbC5qc1wiO1xuZXhwb3J0IHtcbiAgTSBhcyBCYXJjb2RlRGV0ZWN0b3IsXG4gIFggYXMgWlhJTkdfQ1BQX0NPTU1JVCxcbiAgWiBhcyBaWElOR19XQVNNX1NIQTI1NixcbiAgXyBhcyBaWElOR19XQVNNX1ZFUlNJT04sXG4gIGQgYXMgcHJlcGFyZVpYaW5nTW9kdWxlLFxuICBpIGFzIHB1cmdlWlhpbmdNb2R1bGUsXG4gIHAgYXMgc2V0WlhpbmdNb2R1bGVPdmVycmlkZXNcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/barcode-detector/dist/es/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/barcode-detector/dist/es/polyfill.js":
/*!***********************************************************!*\
  !*** ./node_modules/barcode-detector/dist/es/polyfill.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZXING_CPP_COMMIT: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.ZXING_CPP_COMMIT),\n/* harmony export */   ZXING_WASM_SHA256: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.ZXING_WASM_SHA256),\n/* harmony export */   ZXING_WASM_VERSION: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.ZXING_WASM_VERSION),\n/* harmony export */   prepareZXingModule: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.prepareZXingModule),\n/* harmony export */   purgeZXingModule: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.purgeZXingModule),\n/* harmony export */   setZXingModuleOverrides: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.setZXingModuleOverrides)\n/* harmony export */ });\n/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ponyfill.js */ \"(app-pages-browser)/./node_modules/barcode-detector/dist/es/ponyfill.js\");\n\n\nvar e;\n(e = globalThis.BarcodeDetector) != null || (globalThis.BarcodeDetector = _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.BarcodeDetector);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iYXJjb2RlLWRldGVjdG9yL2Rpc3QvZXMvcG9seWZpbGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFxRDtBQUNnSTtBQUNyTDtBQUNBLDBFQUEwRSx5REFBQztBQVF6RSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvYmFyY29kZS1kZXRlY3Rvci9kaXN0L2VzL3BvbHlmaWxsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhcmNvZGVEZXRlY3RvciBhcyByIH0gZnJvbSBcIi4vcG9ueWZpbGwuanNcIjtcbmltcG9ydCB7IFpYSU5HX0NQUF9DT01NSVQgYXMgZCwgWlhJTkdfV0FTTV9TSEEyNTYgYXMgaSwgWlhJTkdfV0FTTV9WRVJTSU9OIGFzIFgsIHByZXBhcmVaWGluZ01vZHVsZSBhcyBaLCBwdXJnZVpYaW5nTW9kdWxlIGFzIF8sIHNldFpYaW5nTW9kdWxlT3ZlcnJpZGVzIGFzIGcgfSBmcm9tIFwiLi9wb255ZmlsbC5qc1wiO1xudmFyIGU7XG4oZSA9IGdsb2JhbFRoaXMuQmFyY29kZURldGVjdG9yKSAhPSBudWxsIHx8IChnbG9iYWxUaGlzLkJhcmNvZGVEZXRlY3RvciA9IHIpO1xuZXhwb3J0IHtcbiAgZCBhcyBaWElOR19DUFBfQ09NTUlULFxuICBpIGFzIFpYSU5HX1dBU01fU0hBMjU2LFxuICBYIGFzIFpYSU5HX1dBU01fVkVSU0lPTixcbiAgWiBhcyBwcmVwYXJlWlhpbmdNb2R1bGUsXG4gIF8gYXMgcHVyZ2VaWGluZ01vZHVsZSxcbiAgZyBhcyBzZXRaWGluZ01vZHVsZU92ZXJyaWRlc1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/barcode-detector/dist/es/polyfill.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/barcode-detector/dist/es/ponyfill.js":
/*!***********************************************************!*\
  !*** ./node_modules/barcode-detector/dist/es/ponyfill.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BarcodeDetector: () => (/* binding */ Eo),\n/* harmony export */   ZXING_CPP_COMMIT: () => (/* binding */ bo),\n/* harmony export */   ZXING_WASM_SHA256: () => (/* binding */ Po),\n/* harmony export */   ZXING_WASM_VERSION: () => (/* binding */ $o),\n/* harmony export */   prepareZXingModule: () => (/* binding */ Be),\n/* harmony export */   purgeZXingModule: () => (/* binding */ Co),\n/* harmony export */   setZXingModuleOverrides: () => (/* binding */ To)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar Ae = (o) => {\n  throw TypeError(o);\n};\nvar Se = (o, f, c) => f.has(o) || Ae(\"Cannot \" + c);\nvar Ie = (o, f, c) => (Se(o, f, \"read from private field\"), c ? c.call(o) : f.get(o)), De = (o, f, c) => f.has(o) ? Ae(\"Cannot add the same private member more than once\") : f instanceof WeakSet ? f.add(o) : f.set(o, c), Me = (o, f, c, T) => (Se(o, f, \"write to private field\"), T ? T.call(o, c) : f.set(o, c), c);\nconst Dt = [\n  [\"Aztec\", \"M\"],\n  [\"Codabar\", \"L\"],\n  [\"Code39\", \"L\"],\n  [\"Code93\", \"L\"],\n  [\"Code128\", \"L\"],\n  [\"DataBar\", \"L\"],\n  [\"DataBarExpanded\", \"L\"],\n  [\"DataMatrix\", \"M\"],\n  [\"EAN-8\", \"L\"],\n  [\"EAN-13\", \"L\"],\n  [\"ITF\", \"L\"],\n  [\"MaxiCode\", \"M\"],\n  [\"PDF417\", \"M\"],\n  [\"QRCode\", \"M\"],\n  [\"UPC-A\", \"L\"],\n  [\"UPC-E\", \"L\"],\n  [\"MicroQRCode\", \"M\"],\n  [\"rMQRCode\", \"M\"],\n  [\"DXFilmEdge\", \"L\"],\n  [\"DataBarLimited\", \"L\"]\n], Mt = Dt.map(([o]) => o), La = Mt.filter(\n  (o, f) => Dt[f][1] === \"L\"\n), Ba = Mt.filter(\n  (o, f) => Dt[f][1] === \"M\"\n);\nfunction Yt(o) {\n  switch (o) {\n    case \"Linear-Codes\":\n      return La.reduce((f, c) => f | Yt(c), 0);\n    case \"Matrix-Codes\":\n      return Ba.reduce((f, c) => f | Yt(c), 0);\n    case \"Any\":\n      return (1 << Dt.length) - 1;\n    case \"None\":\n      return 0;\n    default:\n      return 1 << Mt.indexOf(o);\n  }\n}\nfunction Wa(o) {\n  if (o === 0)\n    return \"None\";\n  const f = 31 - Math.clz32(o);\n  return Mt[f];\n}\nfunction Ua(o) {\n  return o.reduce((f, c) => f | Yt(c), 0);\n}\nconst Va = [\n  \"LocalAverage\",\n  \"GlobalHistogram\",\n  \"FixedThreshold\",\n  \"BoolCast\"\n];\nfunction ka(o) {\n  return Va.indexOf(o);\n}\nconst Fe = [\n  \"Unknown\",\n  \"ASCII\",\n  \"ISO8859_1\",\n  \"ISO8859_2\",\n  \"ISO8859_3\",\n  \"ISO8859_4\",\n  \"ISO8859_5\",\n  \"ISO8859_6\",\n  \"ISO8859_7\",\n  \"ISO8859_8\",\n  \"ISO8859_9\",\n  \"ISO8859_10\",\n  \"ISO8859_11\",\n  \"ISO8859_13\",\n  \"ISO8859_14\",\n  \"ISO8859_15\",\n  \"ISO8859_16\",\n  \"Cp437\",\n  \"Cp1250\",\n  \"Cp1251\",\n  \"Cp1252\",\n  \"Cp1256\",\n  \"Shift_JIS\",\n  \"Big5\",\n  \"GB2312\",\n  \"GB18030\",\n  \"EUC_JP\",\n  \"EUC_KR\",\n  \"UTF16BE\",\n  /**\n   * UnicodeBig [[deprecated]]\n   */\n  \"UTF16BE\",\n  \"UTF8\",\n  \"UTF16LE\",\n  \"UTF32BE\",\n  \"UTF32LE\",\n  \"BINARY\"\n];\nfunction Ha(o) {\n  return o === \"UnicodeBig\" ? Fe.indexOf(\"UTF16BE\") : Fe.indexOf(o);\n}\nconst Na = [\n  \"Text\",\n  \"Binary\",\n  \"Mixed\",\n  \"GS1\",\n  \"ISO15434\",\n  \"UnknownECI\"\n];\nfunction za(o) {\n  return Na[o];\n}\nconst Ga = [\"Ignore\", \"Read\", \"Require\"];\nfunction Xa(o) {\n  return Ga.indexOf(o);\n}\nconst qa = [\"Plain\", \"ECI\", \"HRI\", \"Hex\", \"Escaped\"];\nfunction Ya(o) {\n  return qa.indexOf(o);\n}\nconst It = {\n  formats: [],\n  tryHarder: !0,\n  tryRotate: !0,\n  tryInvert: !0,\n  tryDownscale: !0,\n  tryDenoise: !1,\n  binarizer: \"LocalAverage\",\n  isPure: !1,\n  downscaleFactor: 3,\n  downscaleThreshold: 500,\n  minLineCount: 2,\n  maxNumberOfSymbols: 255,\n  tryCode39ExtendedMode: !0,\n  returnErrors: !1,\n  eanAddOnSymbol: \"Ignore\",\n  textMode: \"HRI\",\n  characterSet: \"Unknown\"\n};\nfunction je(o) {\n  return {\n    ...o,\n    formats: Ua(o.formats),\n    binarizer: ka(o.binarizer),\n    eanAddOnSymbol: Xa(o.eanAddOnSymbol),\n    textMode: Ya(o.textMode),\n    characterSet: Ha(o.characterSet)\n  };\n}\nfunction Za(o) {\n  return {\n    ...o,\n    format: Wa(o.format),\n    contentType: za(o.contentType),\n    eccLevel: o.ecLevel\n  };\n}\nconst $o = \"2.1.2\", bo = \"a1516b34167cff504bf3c83698ea841e13a8f7f1\", Qa = {\n  locateFile: (o, f) => {\n    const c = o.match(/_(.+?)\\.wasm$/);\n    return c ? `https://fastly.jsdelivr.net/npm/zxing-wasm@2.1.2/dist/${c[1]}/${o}` : f + o;\n  }\n}, St = /* @__PURE__ */ new WeakMap();\nfunction Ja(o, f) {\n  return Object.is(o, f) || Object.keys(o).length === Object.keys(f).length && Object.keys(o).every(\n    (c) => Object.prototype.hasOwnProperty.call(f, c) && o[c] === f[c]\n  );\n}\nfunction Le(o, {\n  overrides: f,\n  equalityFn: c = Ja,\n  fireImmediately: T = !1\n} = {}) {\n  var $;\n  const [x, D] = ($ = St.get(o)) != null ? $ : [Qa], R = f != null ? f : x;\n  let O;\n  if (T) {\n    if (D && (O = c(x, R)))\n      return D;\n    const M = o({\n      ...R\n    });\n    return St.set(o, [R, M]), M;\n  }\n  (O != null ? O : c(x, R)) || St.set(o, [R]);\n}\nfunction Ka(o) {\n  St.delete(o);\n}\nasync function to(o, f, c = It) {\n  const T = {\n    ...It,\n    ...c\n  }, $ = await Le(o, {\n    fireImmediately: !0\n  });\n  let x, D;\n  if (\"width\" in f && \"height\" in f && \"data\" in f) {\n    const {\n      data: O,\n      data: { byteLength: M },\n      width: F,\n      height: q\n    } = f;\n    D = $._malloc(M), $.HEAPU8.set(O, D), x = $.readBarcodesFromPixmap(\n      D,\n      F,\n      q,\n      je(T)\n    );\n  } else {\n    let O, M;\n    if (\"buffer\" in f)\n      [O, M] = [f.byteLength, f];\n    else if (\"byteLength\" in f)\n      [O, M] = [f.byteLength, new Uint8Array(f)];\n    else if (\"size\" in f)\n      [O, M] = [f.size, new Uint8Array(await f.arrayBuffer())];\n    else\n      throw new TypeError(\"Invalid input type\");\n    D = $._malloc(O), $.HEAPU8.set(M, D), x = $.readBarcodesFromImage(\n      D,\n      O,\n      je(T)\n    );\n  }\n  $._free(D);\n  const R = [];\n  for (let O = 0; O < x.size(); ++O)\n    R.push(\n      Za(x.get(O))\n    );\n  return R;\n}\n({\n  ...It,\n  formats: [...It.formats]\n});\nvar Qt = async function(o = {}) {\n  var f, c = o, T, $, x = new Promise((e, t) => {\n    T = e, $ = t;\n  }), D = typeof window == \"object\", R = typeof Bun < \"u\", O = typeof WorkerGlobalScope < \"u\";\n  typeof process == \"object\" && typeof process.versions == \"object\" && typeof process.versions.node == \"string\" && process.type != \"renderer\";\n  var M = \"./this.program\", F = \"\";\n  function q(e) {\n    return c.locateFile ? c.locateFile(e, F) : F + e;\n  }\n  var rt, Y;\n  (D || O || R) && (O ? F = self.location.href : typeof document < \"u\" && document.currentScript && (F = document.currentScript.src), F.startsWith(\"blob:\") ? F = \"\" : F = F.slice(0, F.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1), O && (Y = (e) => {\n    var t = new XMLHttpRequest();\n    return t.open(\"GET\", e, !1), t.responseType = \"arraybuffer\", t.send(null), new Uint8Array(t.response);\n  }), rt = async (e) => {\n    var t = await fetch(e, {\n      credentials: \"same-origin\"\n    });\n    if (t.ok)\n      return t.arrayBuffer();\n    throw new Error(t.status + \" : \" + t.url);\n  });\n  var st = console.log.bind(console), k = console.error.bind(console), Z, nt, Jt = !1, Q, B, ut, vt, at, P, Kt, te;\n  function ee() {\n    var e = nt.buffer;\n    Q = new Int8Array(e), ut = new Int16Array(e), c.HEAPU8 = B = new Uint8Array(e), vt = new Uint16Array(e), at = new Int32Array(e), P = new Uint32Array(e), Kt = new Float32Array(e), te = new Float64Array(e);\n  }\n  function qe() {\n    if (c.preRun)\n      for (typeof c.preRun == \"function\" && (c.preRun = [c.preRun]); c.preRun.length; )\n        sr(c.preRun.shift());\n    re(ae);\n  }\n  function Ye() {\n    E.ya();\n  }\n  function Ze() {\n    if (c.postRun)\n      for (typeof c.postRun == \"function\" && (c.postRun = [c.postRun]); c.postRun.length; )\n        ir(c.postRun.shift());\n    re(ne);\n  }\n  var J = 0, ct = null;\n  function Qe(e) {\n    var t;\n    J++, (t = c.monitorRunDependencies) === null || t === void 0 || t.call(c, J);\n  }\n  function Je(e) {\n    var t;\n    if (J--, (t = c.monitorRunDependencies) === null || t === void 0 || t.call(c, J), J == 0 && ct) {\n      var r = ct;\n      ct = null, r();\n    }\n  }\n  function Ft(e) {\n    var t;\n    (t = c.onAbort) === null || t === void 0 || t.call(c, e), e = \"Aborted(\" + e + \")\", k(e), Jt = !0, e += \". Build with -sASSERTIONS for more info.\";\n    var r = new WebAssembly.RuntimeError(e);\n    throw $(r), r;\n  }\n  var yt;\n  function Ke() {\n    return q(\"zxing_reader.wasm\");\n  }\n  function tr(e) {\n    if (e == yt && Z)\n      return new Uint8Array(Z);\n    if (Y)\n      return Y(e);\n    throw \"both async and sync fetching of the wasm failed\";\n  }\n  async function er(e) {\n    if (!Z)\n      try {\n        var t = await rt(e);\n        return new Uint8Array(t);\n      } catch {\n      }\n    return tr(e);\n  }\n  async function rr(e, t) {\n    try {\n      var r = await er(e), n = await WebAssembly.instantiate(r, t);\n      return n;\n    } catch (a) {\n      k(`failed to asynchronously prepare wasm: ${a}`), Ft(a);\n    }\n  }\n  async function nr(e, t, r) {\n    if (!e && typeof WebAssembly.instantiateStreaming == \"function\")\n      try {\n        var n = fetch(t, {\n          credentials: \"same-origin\"\n        }), a = await WebAssembly.instantiateStreaming(n, r);\n        return a;\n      } catch (i) {\n        k(`wasm streaming compile failed: ${i}`), k(\"falling back to ArrayBuffer instantiation\");\n      }\n    return rr(t, r);\n  }\n  function ar() {\n    return {\n      a: Hn\n    };\n  }\n  async function or() {\n    function e(i, u) {\n      return E = i.exports, nt = E.xa, ee(), pe = E.Ba, Je(), E;\n    }\n    Qe();\n    function t(i) {\n      return e(i.instance);\n    }\n    var r = ar();\n    if (c.instantiateWasm)\n      return new Promise((i, u) => {\n        c.instantiateWasm(r, (s, l) => {\n          i(e(s));\n        });\n      });\n    yt != null || (yt = Ke());\n    try {\n      var n = await nr(Z, yt, r), a = t(n);\n      return a;\n    } catch (i) {\n      return $(i), Promise.reject(i);\n    }\n  }\n  var re = (e) => {\n    for (; e.length > 0; )\n      e.shift()(c);\n  }, ne = [], ir = (e) => ne.push(e), ae = [], sr = (e) => ae.push(e), y = (e) => Xn(e), m = () => qn(), mt = [], gt = 0, ur = (e) => {\n    var t = new jt(e);\n    return t.get_caught() || (t.set_caught(!0), gt--), t.set_rethrown(!1), mt.push(t), Zn(e), zn(e);\n  }, H = 0, cr = () => {\n    v(0, 0);\n    var e = mt.pop();\n    Yn(e.excPtr), H = 0;\n  };\n  class jt {\n    constructor(t) {\n      this.excPtr = t, this.ptr = t - 24;\n    }\n    set_type(t) {\n      P[this.ptr + 4 >> 2] = t;\n    }\n    get_type() {\n      return P[this.ptr + 4 >> 2];\n    }\n    set_destructor(t) {\n      P[this.ptr + 8 >> 2] = t;\n    }\n    get_destructor() {\n      return P[this.ptr + 8 >> 2];\n    }\n    set_caught(t) {\n      t = t ? 1 : 0, Q[this.ptr + 12] = t;\n    }\n    get_caught() {\n      return Q[this.ptr + 12] != 0;\n    }\n    set_rethrown(t) {\n      t = t ? 1 : 0, Q[this.ptr + 13] = t;\n    }\n    get_rethrown() {\n      return Q[this.ptr + 13] != 0;\n    }\n    init(t, r) {\n      this.set_adjusted_ptr(0), this.set_type(t), this.set_destructor(r);\n    }\n    set_adjusted_ptr(t) {\n      P[this.ptr + 16 >> 2] = t;\n    }\n    get_adjusted_ptr() {\n      return P[this.ptr + 16 >> 2];\n    }\n  }\n  var wt = (e) => Gn(e), Rt = (e) => {\n    var t = H;\n    if (!t)\n      return wt(0), 0;\n    var r = new jt(t);\n    r.set_adjusted_ptr(t);\n    var n = r.get_type();\n    if (!n)\n      return wt(0), t;\n    for (var a of e) {\n      if (a === 0 || a === n)\n        break;\n      var i = r.ptr + 16;\n      if (Qn(a, n, i))\n        return wt(a), t;\n    }\n    return wt(n), t;\n  }, lr = () => Rt([]), fr = (e) => Rt([e]), dr = (e, t) => Rt([e, t]), hr = () => {\n    var e = mt.pop();\n    e || Ft(\"no exception to throw\");\n    var t = e.excPtr;\n    throw e.get_rethrown() || (mt.push(e), e.set_rethrown(!0), e.set_caught(!1), gt++), H = t, H;\n  }, pr = (e, t, r) => {\n    var n = new jt(e);\n    throw n.init(t, r), H = e, gt++, H;\n  }, vr = () => gt, yr = (e) => {\n    throw H || (H = e), H;\n  }, mr = () => Ft(\"\"), $t = {}, Lt = (e) => {\n    for (; e.length; ) {\n      var t = e.pop(), r = e.pop();\n      r(t);\n    }\n  };\n  function lt(e) {\n    return this.fromWireType(P[e >> 2]);\n  }\n  var ot = {}, K = {}, bt = {}, gr = c.InternalError = class extends Error {\n    constructor(e) {\n      super(e), this.name = \"InternalError\";\n    }\n  }, Ct = (e) => {\n    throw new gr(e);\n  }, tt = (e, t, r) => {\n    e.forEach((s) => bt[s] = t);\n    function n(s) {\n      var l = r(s);\n      l.length !== e.length && Ct(\"Mismatched type converter count\");\n      for (var d = 0; d < e.length; ++d)\n        V(e[d], l[d]);\n    }\n    var a = new Array(t.length), i = [], u = 0;\n    t.forEach((s, l) => {\n      K.hasOwnProperty(s) ? a[l] = K[s] : (i.push(s), ot.hasOwnProperty(s) || (ot[s] = []), ot[s].push(() => {\n        a[l] = K[s], ++u, u === i.length && n(a);\n      }));\n    }), i.length === 0 && n(a);\n  }, wr = (e) => {\n    var t = $t[e];\n    delete $t[e];\n    var r = t.rawConstructor, n = t.rawDestructor, a = t.fields, i = a.map((u) => u.getterReturnType).concat(a.map((u) => u.setterArgumentType));\n    tt([e], i, (u) => {\n      var s = {};\n      return a.forEach((l, d) => {\n        var h = l.fieldName, p = u[d], w = u[d].optional, b = l.getter, _ = l.getterContext, S = u[d + a.length], A = l.setter, I = l.setterContext;\n        s[h] = {\n          read: (X) => p.fromWireType(b(_, X)),\n          write: (X, L) => {\n            var W = [];\n            A(I, X, S.toWireType(W, L)), Lt(W);\n          },\n          optional: w\n        };\n      }), [{\n        name: t.name,\n        fromWireType: (l) => {\n          var d = {};\n          for (var h in s)\n            d[h] = s[h].read(l);\n          return n(l), d;\n        },\n        toWireType: (l, d) => {\n          for (var h in s)\n            if (!(h in d) && !s[h].optional)\n              throw new TypeError(`Missing field: \"${h}\"`);\n          var p = r();\n          for (h in s)\n            s[h].write(p, d[h]);\n          return l !== null && l.push(n, p), p;\n        },\n        argPackAdvance: N,\n        readValueFromPointer: lt,\n        destructorFunction: n\n      }];\n    });\n  }, $r = (e, t, r, n, a) => {\n  }, br = () => {\n    for (var e = new Array(256), t = 0; t < 256; ++t)\n      e[t] = String.fromCharCode(t);\n    oe = e;\n  }, oe, j = (e) => {\n    for (var t = \"\", r = e; B[r]; )\n      t += oe[B[r++]];\n    return t;\n  }, ft = c.BindingError = class extends Error {\n    constructor(e) {\n      super(e), this.name = \"BindingError\";\n    }\n  }, C = (e) => {\n    throw new ft(e);\n  };\n  function Cr(e, t) {\n    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var n = t.name;\n    if (e || C(`type \"${n}\" must have a positive integer typeid pointer`), K.hasOwnProperty(e)) {\n      if (r.ignoreDuplicateRegistrations)\n        return;\n      C(`Cannot register type '${n}' twice`);\n    }\n    if (K[e] = t, delete bt[e], ot.hasOwnProperty(e)) {\n      var a = ot[e];\n      delete ot[e], a.forEach((i) => i());\n    }\n  }\n  function V(e, t) {\n    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return Cr(e, t, r);\n  }\n  var N = 8, Tr = (e, t, r, n) => {\n    t = j(t), V(e, {\n      name: t,\n      fromWireType: function(a) {\n        return !!a;\n      },\n      toWireType: function(a, i) {\n        return i ? r : n;\n      },\n      argPackAdvance: N,\n      readValueFromPointer: function(a) {\n        return this.fromWireType(B[a]);\n      },\n      destructorFunction: null\n    });\n  }, Pr = (e) => ({\n    count: e.count,\n    deleteScheduled: e.deleteScheduled,\n    preservePointerOnDelete: e.preservePointerOnDelete,\n    ptr: e.ptr,\n    ptrType: e.ptrType,\n    smartPtr: e.smartPtr,\n    smartPtrType: e.smartPtrType\n  }), Bt = (e) => {\n    function t(r) {\n      return r.$$.ptrType.registeredClass.name;\n    }\n    C(t(e) + \" instance already deleted\");\n  }, Wt = !1, ie = (e) => {\n  }, Er = (e) => {\n    e.smartPtr ? e.smartPtrType.rawDestructor(e.smartPtr) : e.ptrType.registeredClass.rawDestructor(e.ptr);\n  }, se = (e) => {\n    e.count.value -= 1;\n    var t = e.count.value === 0;\n    t && Er(e);\n  }, dt = (e) => typeof FinalizationRegistry > \"u\" ? (dt = (t) => t, e) : (Wt = new FinalizationRegistry((t) => {\n    se(t.$$);\n  }), dt = (t) => {\n    var r = t.$$, n = !!r.smartPtr;\n    if (n) {\n      var a = {\n        $$: r\n      };\n      Wt.register(t, a, t);\n    }\n    return t;\n  }, ie = (t) => Wt.unregister(t), dt(e)), _r = () => {\n    let e = Tt.prototype;\n    Object.assign(e, {\n      isAliasOf(r) {\n        if (!(this instanceof Tt) || !(r instanceof Tt))\n          return !1;\n        var n = this.$$.ptrType.registeredClass, a = this.$$.ptr;\n        r.$$ = r.$$;\n        for (var i = r.$$.ptrType.registeredClass, u = r.$$.ptr; n.baseClass; )\n          a = n.upcast(a), n = n.baseClass;\n        for (; i.baseClass; )\n          u = i.upcast(u), i = i.baseClass;\n        return n === i && a === u;\n      },\n      clone() {\n        if (this.$$.ptr || Bt(this), this.$$.preservePointerOnDelete)\n          return this.$$.count.value += 1, this;\n        var r = dt(Object.create(Object.getPrototypeOf(this), {\n          $$: {\n            value: Pr(this.$$)\n          }\n        }));\n        return r.$$.count.value += 1, r.$$.deleteScheduled = !1, r;\n      },\n      delete() {\n        this.$$.ptr || Bt(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && C(\"Object already scheduled for deletion\"), ie(this), se(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0);\n      },\n      isDeleted() {\n        return !this.$$.ptr;\n      },\n      deleteLater() {\n        return this.$$.ptr || Bt(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && C(\"Object already scheduled for deletion\"), this.$$.deleteScheduled = !0, this;\n      }\n    });\n    const t = Symbol.dispose;\n    t && (e[t] = e.delete);\n  };\n  function Tt() {\n  }\n  var Ut = (e, t) => Object.defineProperty(t, \"name\", {\n    value: e\n  }), ue = {}, ce = (e, t, r) => {\n    if (e[t].overloadTable === void 0) {\n      var n = e[t];\n      e[t] = function() {\n        for (var a = arguments.length, i = new Array(a), u = 0; u < a; u++)\n          i[u] = arguments[u];\n        return e[t].overloadTable.hasOwnProperty(i.length) || C(`Function '${r}' called with an invalid number of arguments (${i.length}) - expects one of (${e[t].overloadTable})!`), e[t].overloadTable[i.length].apply(this, i);\n      }, e[t].overloadTable = [], e[t].overloadTable[n.argCount] = n;\n    }\n  }, le = (e, t, r) => {\n    c.hasOwnProperty(e) ? ((r === void 0 || c[e].overloadTable !== void 0 && c[e].overloadTable[r] !== void 0) && C(`Cannot register public name '${e}' twice`), ce(c, e, e), c[e].overloadTable.hasOwnProperty(r) && C(`Cannot register multiple overloads of a function with the same number of arguments (${r})!`), c[e].overloadTable[r] = t) : (c[e] = t, c[e].argCount = r);\n  }, Or = 48, xr = 57, Ar = (e) => {\n    e = e.replace(/[^a-zA-Z0-9_]/g, \"$\");\n    var t = e.charCodeAt(0);\n    return t >= Or && t <= xr ? `_${e}` : e;\n  };\n  function Sr(e, t, r, n, a, i, u, s) {\n    this.name = e, this.constructor = t, this.instancePrototype = r, this.rawDestructor = n, this.baseClass = a, this.getActualType = i, this.upcast = u, this.downcast = s, this.pureVirtualFunctions = [];\n  }\n  var Vt = (e, t, r) => {\n    for (; t !== r; )\n      t.upcast || C(`Expected null or instance of ${r.name}, got an instance of ${t.name}`), e = t.upcast(e), t = t.baseClass;\n    return e;\n  };\n  function Ir(e, t) {\n    if (t === null)\n      return this.isReference && C(`null is not a valid ${this.name}`), 0;\n    t.$$ || C(`Cannot pass \"${embindRepr(t)}\" as a ${this.name}`), t.$$.ptr || C(`Cannot pass deleted object as a pointer of type ${this.name}`);\n    var r = t.$$.ptrType.registeredClass, n = Vt(t.$$.ptr, r, this.registeredClass);\n    return n;\n  }\n  function Dr(e, t) {\n    var r;\n    if (t === null)\n      return this.isReference && C(`null is not a valid ${this.name}`), this.isSmartPointer ? (r = this.rawConstructor(), e !== null && e.push(this.rawDestructor, r), r) : 0;\n    (!t || !t.$$) && C(`Cannot pass \"${embindRepr(t)}\" as a ${this.name}`), t.$$.ptr || C(`Cannot pass deleted object as a pointer of type ${this.name}`), !this.isConst && t.$$.ptrType.isConst && C(`Cannot convert argument of type ${t.$$.smartPtrType ? t.$$.smartPtrType.name : t.$$.ptrType.name} to parameter type ${this.name}`);\n    var n = t.$$.ptrType.registeredClass;\n    if (r = Vt(t.$$.ptr, n, this.registeredClass), this.isSmartPointer)\n      switch (t.$$.smartPtr === void 0 && C(\"Passing raw pointer to smart pointer is illegal\"), this.sharingPolicy) {\n        case 0:\n          t.$$.smartPtrType === this ? r = t.$$.smartPtr : C(`Cannot convert argument of type ${t.$$.smartPtrType ? t.$$.smartPtrType.name : t.$$.ptrType.name} to parameter type ${this.name}`);\n          break;\n        case 1:\n          r = t.$$.smartPtr;\n          break;\n        case 2:\n          if (t.$$.smartPtrType === this)\n            r = t.$$.smartPtr;\n          else {\n            var a = t.clone();\n            r = this.rawShare(r, G.toHandle(() => a.delete())), e !== null && e.push(this.rawDestructor, r);\n          }\n          break;\n        default:\n          C(\"Unsupporting sharing policy\");\n      }\n    return r;\n  }\n  function Mr(e, t) {\n    if (t === null)\n      return this.isReference && C(`null is not a valid ${this.name}`), 0;\n    t.$$ || C(`Cannot pass \"${embindRepr(t)}\" as a ${this.name}`), t.$$.ptr || C(`Cannot pass deleted object as a pointer of type ${this.name}`), t.$$.ptrType.isConst && C(`Cannot convert argument of type ${t.$$.ptrType.name} to parameter type ${this.name}`);\n    var r = t.$$.ptrType.registeredClass, n = Vt(t.$$.ptr, r, this.registeredClass);\n    return n;\n  }\n  var fe = (e, t, r) => {\n    if (t === r)\n      return e;\n    if (r.baseClass === void 0)\n      return null;\n    var n = fe(e, t, r.baseClass);\n    return n === null ? null : r.downcast(n);\n  }, Fr = {}, jr = (e, t) => {\n    for (t === void 0 && C(\"ptr should not be undefined\"); e.baseClass; )\n      t = e.upcast(t), e = e.baseClass;\n    return t;\n  }, Rr = (e, t) => (t = jr(e, t), Fr[t]), Pt = (e, t) => {\n    (!t.ptrType || !t.ptr) && Ct(\"makeClassHandle requires ptr and ptrType\");\n    var r = !!t.smartPtrType, n = !!t.smartPtr;\n    return r !== n && Ct(\"Both smartPtrType and smartPtr must be specified\"), t.count = {\n      value: 1\n    }, dt(Object.create(e, {\n      $$: {\n        value: t,\n        writable: !0\n      }\n    }));\n  };\n  function Lr(e) {\n    var t = this.getPointee(e);\n    if (!t)\n      return this.destructor(e), null;\n    var r = Rr(this.registeredClass, t);\n    if (r !== void 0) {\n      if (r.$$.count.value === 0)\n        return r.$$.ptr = t, r.$$.smartPtr = e, r.clone();\n      var n = r.clone();\n      return this.destructor(e), n;\n    }\n    function a() {\n      return this.isSmartPointer ? Pt(this.registeredClass.instancePrototype, {\n        ptrType: this.pointeeType,\n        ptr: t,\n        smartPtrType: this,\n        smartPtr: e\n      }) : Pt(this.registeredClass.instancePrototype, {\n        ptrType: this,\n        ptr: e\n      });\n    }\n    var i = this.registeredClass.getActualType(t), u = ue[i];\n    if (!u)\n      return a.call(this);\n    var s;\n    this.isConst ? s = u.constPointerType : s = u.pointerType;\n    var l = fe(t, this.registeredClass, s.registeredClass);\n    return l === null ? a.call(this) : this.isSmartPointer ? Pt(s.registeredClass.instancePrototype, {\n      ptrType: s,\n      ptr: l,\n      smartPtrType: this,\n      smartPtr: e\n    }) : Pt(s.registeredClass.instancePrototype, {\n      ptrType: s,\n      ptr: l\n    });\n  }\n  var Br = () => {\n    Object.assign(Et.prototype, {\n      getPointee(e) {\n        return this.rawGetPointee && (e = this.rawGetPointee(e)), e;\n      },\n      destructor(e) {\n        var t;\n        (t = this.rawDestructor) === null || t === void 0 || t.call(this, e);\n      },\n      argPackAdvance: N,\n      readValueFromPointer: lt,\n      fromWireType: Lr\n    });\n  };\n  function Et(e, t, r, n, a, i, u, s, l, d, h) {\n    this.name = e, this.registeredClass = t, this.isReference = r, this.isConst = n, this.isSmartPointer = a, this.pointeeType = i, this.sharingPolicy = u, this.rawGetPointee = s, this.rawConstructor = l, this.rawShare = d, this.rawDestructor = h, !a && t.baseClass === void 0 ? n ? (this.toWireType = Ir, this.destructorFunction = null) : (this.toWireType = Mr, this.destructorFunction = null) : this.toWireType = Dr;\n  }\n  var de = (e, t, r) => {\n    c.hasOwnProperty(e) || Ct(\"Replacing nonexistent public symbol\"), c[e].overloadTable !== void 0 && r !== void 0 ? c[e].overloadTable[r] = t : (c[e] = t, c[e].argCount = r);\n  }, he = [], pe, g = (e) => {\n    var t = he[e];\n    return t || (he[e] = t = pe.get(e)), t;\n  }, Wr = function(e, t) {\n    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n    if (e.includes(\"j\"))\n      return dynCallLegacy(e, t, r);\n    var n = g(t), a = n(...r);\n    return a;\n  }, Ur = function(e, t) {\n    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n    return function() {\n      for (var n = arguments.length, a = new Array(n), i = 0; i < n; i++)\n        a[i] = arguments[i];\n      return Wr(e, t, a, r);\n    };\n  }, U = function(e, t) {\n    e = j(e);\n    function r() {\n      if (e.includes(\"j\"))\n        return Ur(e, t);\n      var a = g(t);\n      return a;\n    }\n    var n = r();\n    return typeof n != \"function\" && C(`unknown function pointer with signature ${e}: ${t}`), n;\n  };\n  class Vr extends Error {\n  }\n  var ve = (e) => {\n    var t = Nn(e), r = j(t);\n    return et(t), r;\n  }, _t = (e, t) => {\n    var r = [], n = {};\n    function a(i) {\n      if (!n[i] && !K[i]) {\n        if (bt[i]) {\n          bt[i].forEach(a);\n          return;\n        }\n        r.push(i), n[i] = !0;\n      }\n    }\n    throw t.forEach(a), new Vr(`${e}: ` + r.map(ve).join([\", \"]));\n  }, kr = (e, t, r, n, a, i, u, s, l, d, h, p, w) => {\n    h = j(h), i = U(a, i), s && (s = U(u, s)), d && (d = U(l, d)), w = U(p, w);\n    var b = Ar(h);\n    le(b, function() {\n      _t(`Cannot construct ${h} due to unbound types`, [n]);\n    }), tt([e, t, r], n ? [n] : [], (_) => {\n      _ = _[0];\n      var S, A;\n      n ? (S = _.registeredClass, A = S.instancePrototype) : A = Tt.prototype;\n      var I = Ut(h, function() {\n        if (Object.getPrototypeOf(this) !== X)\n          throw new ft(`Use 'new' to construct ${h}`);\n        if (L.constructor_body === void 0)\n          throw new ft(`${h} has no accessible constructor`);\n        for (var Oe = arguments.length, xt = new Array(Oe), At = 0; At < Oe; At++)\n          xt[At] = arguments[At];\n        var xe = L.constructor_body[xt.length];\n        if (xe === void 0)\n          throw new ft(`Tried to invoke ctor of ${h} with invalid number of parameters (${xt.length}) - expected (${Object.keys(L.constructor_body).toString()}) parameters instead!`);\n        return xe.apply(this, xt);\n      }), X = Object.create(A, {\n        constructor: {\n          value: I\n        }\n      });\n      I.prototype = X;\n      var L = new Sr(h, I, X, w, S, i, s, d);\n      if (L.baseClass) {\n        var W, Ot;\n        (Ot = (W = L.baseClass).__derivedClasses) !== null && Ot !== void 0 || (W.__derivedClasses = []), L.baseClass.__derivedClasses.push(L);\n      }\n      var Ra = new Et(h, L, !0, !1, !1), Ee = new Et(h + \"*\", L, !1, !1, !1), _e = new Et(h + \" const*\", L, !1, !0, !1);\n      return ue[e] = {\n        pointerType: Ee,\n        constPointerType: _e\n      }, de(b, I), [Ra, Ee, _e];\n    });\n  }, kt = (e, t) => {\n    for (var r = [], n = 0; n < e; n++)\n      r.push(P[t + n * 4 >> 2]);\n    return r;\n  };\n  function Hr(e) {\n    for (var t = 1; t < e.length; ++t)\n      if (e[t] !== null && e[t].destructorFunction === void 0)\n        return !0;\n    return !1;\n  }\n  function Ht(e, t, r, n, a, i) {\n    var u = t.length;\n    u < 2 && C(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n    var s = t[1] !== null && r !== null, l = Hr(t), d = t[0].name !== \"void\", h = u - 2, p = new Array(h), w = [], b = [], _ = function() {\n      b.length = 0;\n      var S;\n      w.length = s ? 2 : 1, w[0] = a, s && (S = t[1].toWireType(b, this), w[1] = S);\n      for (var A = 0; A < h; ++A)\n        p[A] = t[A + 2].toWireType(b, A < 0 || arguments.length <= A ? void 0 : arguments[A]), w.push(p[A]);\n      var I = n(...w);\n      function X(L) {\n        if (l)\n          Lt(b);\n        else\n          for (var W = s ? 1 : 2; W < t.length; W++) {\n            var Ot = W === 1 ? S : p[W - 2];\n            t[W].destructorFunction !== null && t[W].destructorFunction(Ot);\n          }\n        if (d)\n          return t[0].fromWireType(L);\n      }\n      return X(I);\n    };\n    return Ut(e, _);\n  }\n  var Nr = (e, t, r, n, a, i) => {\n    var u = kt(t, r);\n    a = U(n, a), tt([], [e], (s) => {\n      s = s[0];\n      var l = `constructor ${s.name}`;\n      if (s.registeredClass.constructor_body === void 0 && (s.registeredClass.constructor_body = []), s.registeredClass.constructor_body[t - 1] !== void 0)\n        throw new ft(`Cannot register multiple constructors with identical number of parameters (${t - 1}) for class '${s.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);\n      return s.registeredClass.constructor_body[t - 1] = () => {\n        _t(`Cannot construct ${s.name} due to unbound types`, u);\n      }, tt([], u, (d) => (d.splice(1, 0, null), s.registeredClass.constructor_body[t - 1] = Ht(l, d, null, a, i), [])), [];\n    });\n  }, ye = (e) => {\n    e = e.trim();\n    const t = e.indexOf(\"(\");\n    return t === -1 ? e : e.slice(0, t);\n  }, zr = (e, t, r, n, a, i, u, s, l, d) => {\n    var h = kt(r, n);\n    t = j(t), t = ye(t), i = U(a, i), tt([], [e], (p) => {\n      p = p[0];\n      var w = `${p.name}.${t}`;\n      t.startsWith(\"@@\") && (t = Symbol[t.substring(2)]), s && p.registeredClass.pureVirtualFunctions.push(t);\n      function b() {\n        _t(`Cannot call ${w} due to unbound types`, h);\n      }\n      var _ = p.registeredClass.instancePrototype, S = _[t];\n      return S === void 0 || S.overloadTable === void 0 && S.className !== p.name && S.argCount === r - 2 ? (b.argCount = r - 2, b.className = p.name, _[t] = b) : (ce(_, t, w), _[t].overloadTable[r - 2] = b), tt([], h, (A) => {\n        var I = Ht(w, A, p, i, u);\n        return _[t].overloadTable === void 0 ? (I.argCount = r - 2, _[t] = I) : _[t].overloadTable[r - 2] = I, [];\n      }), [];\n    });\n  }, Nt = [], z = [], zt = (e) => {\n    e > 9 && --z[e + 1] === 0 && (z[e] = void 0, Nt.push(e));\n  }, Gr = () => z.length / 2 - 5 - Nt.length, Xr = () => {\n    z.push(0, 1, void 0, 1, null, 1, !0, 1, !1, 1), c.count_emval_handles = Gr;\n  }, G = {\n    toValue: (e) => (e || C(`Cannot use deleted val. handle = ${e}`), z[e]),\n    toHandle: (e) => {\n      switch (e) {\n        case void 0:\n          return 2;\n        case null:\n          return 4;\n        case !0:\n          return 6;\n        case !1:\n          return 8;\n        default: {\n          const t = Nt.pop() || z.length;\n          return z[t] = e, z[t + 1] = 1, t;\n        }\n      }\n    }\n  }, me = {\n    name: \"emscripten::val\",\n    fromWireType: (e) => {\n      var t = G.toValue(e);\n      return zt(e), t;\n    },\n    toWireType: (e, t) => G.toHandle(t),\n    argPackAdvance: N,\n    readValueFromPointer: lt,\n    destructorFunction: null\n  }, qr = (e) => V(e, me), Yr = (e, t) => {\n    switch (t) {\n      case 4:\n        return function(r) {\n          return this.fromWireType(Kt[r >> 2]);\n        };\n      case 8:\n        return function(r) {\n          return this.fromWireType(te[r >> 3]);\n        };\n      default:\n        throw new TypeError(`invalid float width (${t}): ${e}`);\n    }\n  }, Zr = (e, t, r) => {\n    t = j(t), V(e, {\n      name: t,\n      fromWireType: (n) => n,\n      toWireType: (n, a) => a,\n      argPackAdvance: N,\n      readValueFromPointer: Yr(t, r),\n      destructorFunction: null\n    });\n  }, Qr = (e, t, r, n, a, i, u, s) => {\n    var l = kt(t, r);\n    e = j(e), e = ye(e), a = U(n, a), le(e, function() {\n      _t(`Cannot call ${e} due to unbound types`, l);\n    }, t - 1), tt([], l, (d) => {\n      var h = [d[0], null].concat(d.slice(1));\n      return de(e, Ht(e, h, null, a, i), t - 1), [];\n    });\n  }, Jr = (e, t, r) => {\n    switch (t) {\n      case 1:\n        return r ? (n) => Q[n] : (n) => B[n];\n      case 2:\n        return r ? (n) => ut[n >> 1] : (n) => vt[n >> 1];\n      case 4:\n        return r ? (n) => at[n >> 2] : (n) => P[n >> 2];\n      default:\n        throw new TypeError(`invalid integer width (${t}): ${e}`);\n    }\n  }, Kr = (e, t, r, n, a) => {\n    t = j(t);\n    var i = (h) => h;\n    if (n === 0) {\n      var u = 32 - 8 * r;\n      i = (h) => h << u >>> u;\n    }\n    var s = t.includes(\"unsigned\"), l = (h, p) => {\n    }, d;\n    s ? d = function(h, p) {\n      return l(p, this.name), p >>> 0;\n    } : d = function(h, p) {\n      return l(p, this.name), p;\n    }, V(e, {\n      name: t,\n      fromWireType: i,\n      toWireType: d,\n      argPackAdvance: N,\n      readValueFromPointer: Jr(t, r, n !== 0),\n      destructorFunction: null\n    });\n  }, tn = (e, t, r) => {\n    var n = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], a = n[t];\n    function i(u) {\n      var s = P[u >> 2], l = P[u + 4 >> 2];\n      return new a(Q.buffer, l, s);\n    }\n    r = j(r), V(e, {\n      name: r,\n      fromWireType: i,\n      argPackAdvance: N,\n      readValueFromPointer: i\n    }, {\n      ignoreDuplicateRegistrations: !0\n    });\n  }, en = Object.assign({\n    optional: !0\n  }, me), rn = (e, t) => {\n    V(e, en);\n  }, nn = (e, t, r, n) => {\n    if (!(n > 0)) return 0;\n    for (var a = r, i = r + n - 1, u = 0; u < e.length; ++u) {\n      var s = e.charCodeAt(u);\n      if (s >= 55296 && s <= 57343) {\n        var l = e.charCodeAt(++u);\n        s = 65536 + ((s & 1023) << 10) | l & 1023;\n      }\n      if (s <= 127) {\n        if (r >= i) break;\n        t[r++] = s;\n      } else if (s <= 2047) {\n        if (r + 1 >= i) break;\n        t[r++] = 192 | s >> 6, t[r++] = 128 | s & 63;\n      } else if (s <= 65535) {\n        if (r + 2 >= i) break;\n        t[r++] = 224 | s >> 12, t[r++] = 128 | s >> 6 & 63, t[r++] = 128 | s & 63;\n      } else {\n        if (r + 3 >= i) break;\n        t[r++] = 240 | s >> 18, t[r++] = 128 | s >> 12 & 63, t[r++] = 128 | s >> 6 & 63, t[r++] = 128 | s & 63;\n      }\n    }\n    return t[r] = 0, r - a;\n  }, it = (e, t, r) => nn(e, B, t, r), ge = (e) => {\n    for (var t = 0, r = 0; r < e.length; ++r) {\n      var n = e.charCodeAt(r);\n      n <= 127 ? t++ : n <= 2047 ? t += 2 : n >= 55296 && n <= 57343 ? (t += 4, ++r) : t += 3;\n    }\n    return t;\n  }, we = typeof TextDecoder < \"u\" ? new TextDecoder() : void 0, $e = function(e) {\n    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;\n    for (var n = t + r, a = t; e[a] && !(a >= n); ) ++a;\n    if (a - t > 16 && e.buffer && we)\n      return we.decode(e.subarray(t, a));\n    for (var i = \"\"; t < a; ) {\n      var u = e[t++];\n      if (!(u & 128)) {\n        i += String.fromCharCode(u);\n        continue;\n      }\n      var s = e[t++] & 63;\n      if ((u & 224) == 192) {\n        i += String.fromCharCode((u & 31) << 6 | s);\n        continue;\n      }\n      var l = e[t++] & 63;\n      if ((u & 240) == 224 ? u = (u & 15) << 12 | s << 6 | l : u = (u & 7) << 18 | s << 12 | l << 6 | e[t++] & 63, u < 65536)\n        i += String.fromCharCode(u);\n      else {\n        var d = u - 65536;\n        i += String.fromCharCode(55296 | d >> 10, 56320 | d & 1023);\n      }\n    }\n    return i;\n  }, an = (e, t) => e ? $e(B, e, t) : \"\", on = (e, t) => {\n    t = j(t), V(e, {\n      name: t,\n      fromWireType(r) {\n        for (var n = P[r >> 2], a = r + 4, i, s, u = a, s = 0; s <= n; ++s) {\n          var l = a + s;\n          if (s == n || B[l] == 0) {\n            var d = l - u, h = an(u, d);\n            i === void 0 ? i = h : (i += \"\\0\", i += h), u = l + 1;\n          }\n        }\n        return et(r), i;\n      },\n      toWireType(r, n) {\n        n instanceof ArrayBuffer && (n = new Uint8Array(n));\n        var a, i = typeof n == \"string\";\n        i || ArrayBuffer.isView(n) && n.BYTES_PER_ELEMENT == 1 || C(\"Cannot pass non-string to std::string\"), i ? a = ge(n) : a = n.length;\n        var u = Pe(4 + a + 1), s = u + 4;\n        return P[u >> 2] = a, i ? it(n, s, a + 1) : B.set(n, s), r !== null && r.push(et, u), u;\n      },\n      argPackAdvance: N,\n      readValueFromPointer: lt,\n      destructorFunction(r) {\n        et(r);\n      }\n    });\n  }, be = typeof TextDecoder < \"u\" ? new TextDecoder(\"utf-16le\") : void 0, sn = (e, t) => {\n    for (var r = e, n = r >> 1, a = n + t / 2; !(n >= a) && vt[n]; ) ++n;\n    if (r = n << 1, r - e > 32 && be) return be.decode(B.subarray(e, r));\n    for (var i = \"\", u = 0; !(u >= t / 2); ++u) {\n      var s = ut[e + u * 2 >> 1];\n      if (s == 0) break;\n      i += String.fromCharCode(s);\n    }\n    return i;\n  }, un = (e, t, r) => {\n    if (r != null || (r = 2147483647), r < 2) return 0;\n    r -= 2;\n    for (var n = t, a = r < e.length * 2 ? r / 2 : e.length, i = 0; i < a; ++i) {\n      var u = e.charCodeAt(i);\n      ut[t >> 1] = u, t += 2;\n    }\n    return ut[t >> 1] = 0, t - n;\n  }, cn = (e) => e.length * 2, ln = (e, t) => {\n    for (var r = 0, n = \"\"; !(r >= t / 4); ) {\n      var a = at[e + r * 4 >> 2];\n      if (a == 0) break;\n      if (++r, a >= 65536) {\n        var i = a - 65536;\n        n += String.fromCharCode(55296 | i >> 10, 56320 | i & 1023);\n      } else\n        n += String.fromCharCode(a);\n    }\n    return n;\n  }, fn = (e, t, r) => {\n    if (r != null || (r = 2147483647), r < 4) return 0;\n    for (var n = t, a = n + r - 4, i = 0; i < e.length; ++i) {\n      var u = e.charCodeAt(i);\n      if (u >= 55296 && u <= 57343) {\n        var s = e.charCodeAt(++i);\n        u = 65536 + ((u & 1023) << 10) | s & 1023;\n      }\n      if (at[t >> 2] = u, t += 4, t + 4 > a) break;\n    }\n    return at[t >> 2] = 0, t - n;\n  }, dn = (e) => {\n    for (var t = 0, r = 0; r < e.length; ++r) {\n      var n = e.charCodeAt(r);\n      n >= 55296 && n <= 57343 && ++r, t += 4;\n    }\n    return t;\n  }, hn = (e, t, r) => {\n    r = j(r);\n    var n, a, i, u;\n    t === 2 ? (n = sn, a = un, u = cn, i = (s) => vt[s >> 1]) : t === 4 && (n = ln, a = fn, u = dn, i = (s) => P[s >> 2]), V(e, {\n      name: r,\n      fromWireType: (s) => {\n        for (var l = P[s >> 2], d, h = s + 4, p = 0; p <= l; ++p) {\n          var w = s + 4 + p * t;\n          if (p == l || i(w) == 0) {\n            var b = w - h, _ = n(h, b);\n            d === void 0 ? d = _ : (d += \"\\0\", d += _), h = w + t;\n          }\n        }\n        return et(s), d;\n      },\n      toWireType: (s, l) => {\n        typeof l != \"string\" && C(`Cannot pass non-string to C++ string type ${r}`);\n        var d = u(l), h = Pe(4 + d + t);\n        return P[h >> 2] = d / t, a(l, h + 4, d + t), s !== null && s.push(et, h), h;\n      },\n      argPackAdvance: N,\n      readValueFromPointer: lt,\n      destructorFunction(s) {\n        et(s);\n      }\n    });\n  }, pn = (e, t, r, n, a, i) => {\n    $t[e] = {\n      name: j(t),\n      rawConstructor: U(r, n),\n      rawDestructor: U(a, i),\n      fields: []\n    };\n  }, vn = (e, t, r, n, a, i, u, s, l, d) => {\n    $t[e].fields.push({\n      fieldName: j(t),\n      getterReturnType: r,\n      getter: U(n, a),\n      getterContext: i,\n      setterArgumentType: u,\n      setter: U(s, l),\n      setterContext: d\n    });\n  }, yn = (e, t) => {\n    t = j(t), V(e, {\n      isVoid: !0,\n      name: t,\n      argPackAdvance: 0,\n      fromWireType: () => {\n      },\n      toWireType: (r, n) => {\n      }\n    });\n  }, Gt = [], mn = (e, t, r, n) => (e = Gt[e], t = G.toValue(t), e(null, t, r, n)), gn = {}, wn = (e) => {\n    var t = gn[e];\n    return t === void 0 ? j(e) : t;\n  }, Ce = () => {\n    if (typeof globalThis == \"object\")\n      return globalThis;\n    function e(t) {\n      t.$$$embind_global$$$ = t;\n      var r = typeof $$$embind_global$$$ == \"object\" && t.$$$embind_global$$$ == t;\n      return r || delete t.$$$embind_global$$$, r;\n    }\n    if (typeof $$$embind_global$$$ == \"object\" || (typeof global == \"object\" && e(global) ? $$$embind_global$$$ = global : typeof self == \"object\" && e(self) && ($$$embind_global$$$ = self), typeof $$$embind_global$$$ == \"object\"))\n      return $$$embind_global$$$;\n    throw Error(\"unable to get global object.\");\n  }, $n = (e) => e === 0 ? G.toHandle(Ce()) : (e = wn(e), G.toHandle(Ce()[e])), bn = (e) => {\n    var t = Gt.length;\n    return Gt.push(e), t;\n  }, Te = (e, t) => {\n    var r = K[e];\n    return r === void 0 && C(`${t} has unknown type ${ve(e)}`), r;\n  }, Cn = (e, t) => {\n    for (var r = new Array(e), n = 0; n < e; ++n)\n      r[n] = Te(P[t + n * 4 >> 2], `parameter ${n}`);\n    return r;\n  }, Tn = (e, t, r) => {\n    var n = [], a = e.toWireType(n, r);\n    return n.length && (P[t >> 2] = G.toHandle(n)), a;\n  }, Pn = Reflect.construct, En = (e, t, r) => {\n    var n = Cn(e, t), a = n.shift();\n    e--;\n    var i = new Array(e), u = (l, d, h, p) => {\n      for (var w = 0, b = 0; b < e; ++b)\n        i[b] = n[b].readValueFromPointer(p + w), w += n[b].argPackAdvance;\n      var _ = r === 1 ? Pn(d, i) : d.apply(l, i);\n      return Tn(a, h, _);\n    }, s = `methodCaller<(${n.map((l) => l.name).join(\", \")}) => ${a.name}>`;\n    return bn(Ut(s, u));\n  }, _n = (e) => {\n    e > 9 && (z[e + 1] += 1);\n  }, On = (e) => {\n    var t = G.toValue(e);\n    Lt(t), zt(e);\n  }, xn = (e, t) => {\n    e = Te(e, \"_emval_take_value\");\n    var r = e.readValueFromPointer(t);\n    return G.toHandle(r);\n  }, An = (e, t, r, n) => {\n    var a = (/* @__PURE__ */ new Date()).getFullYear(), i = new Date(a, 0, 1), u = new Date(a, 6, 1), s = i.getTimezoneOffset(), l = u.getTimezoneOffset(), d = Math.max(s, l);\n    P[e >> 2] = d * 60, at[t >> 2] = +(s != l);\n    var h = (b) => {\n      var _ = b >= 0 ? \"-\" : \"+\", S = Math.abs(b), A = String(Math.floor(S / 60)).padStart(2, \"0\"), I = String(S % 60).padStart(2, \"0\");\n      return `UTC${_}${A}${I}`;\n    }, p = h(s), w = h(l);\n    l < s ? (it(p, r, 17), it(w, n, 17)) : (it(p, n, 17), it(w, r, 17));\n  }, Sn = () => 2147483648, In = (e, t) => Math.ceil(e / t) * t, Dn = (e) => {\n    var t = nt.buffer, r = (e - t.byteLength + 65535) / 65536 | 0;\n    try {\n      return nt.grow(r), ee(), 1;\n    } catch {\n    }\n  }, Mn = (e) => {\n    var t = B.length;\n    e >>>= 0;\n    var r = Sn();\n    if (e > r)\n      return !1;\n    for (var n = 1; n <= 4; n *= 2) {\n      var a = t * (1 + 0.2 / n);\n      a = Math.min(a, e + 100663296);\n      var i = Math.min(r, In(Math.max(e, a), 65536)), u = Dn(i);\n      if (u)\n        return !0;\n    }\n    return !1;\n  }, Xt = {}, Fn = () => M || \"./this.program\", ht = () => {\n    if (!ht.strings) {\n      var e = (typeof navigator == \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\", t = {\n        USER: \"web_user\",\n        LOGNAME: \"web_user\",\n        PATH: \"/\",\n        PWD: \"/\",\n        HOME: \"/home/web_user\",\n        LANG: e,\n        _: Fn()\n      };\n      for (var r in Xt)\n        Xt[r] === void 0 ? delete t[r] : t[r] = Xt[r];\n      var n = [];\n      for (var r in t)\n        n.push(`${r}=${t[r]}`);\n      ht.strings = n;\n    }\n    return ht.strings;\n  }, jn = (e, t) => {\n    var r = 0, n = 0;\n    for (var a of ht()) {\n      var i = t + r;\n      P[e + n >> 2] = i, r += it(a, i, 1 / 0) + 1, n += 4;\n    }\n    return 0;\n  }, Rn = (e, t) => {\n    var r = ht();\n    P[e >> 2] = r.length;\n    var n = 0;\n    for (var a of r)\n      n += ge(a) + 1;\n    return P[t >> 2] = n, 0;\n  }, Ln = (e) => 52;\n  function Bn(e, t, r, n, a) {\n    return 70;\n  }\n  var Wn = [null, [], []], Un = (e, t) => {\n    var r = Wn[e];\n    t === 0 || t === 10 ? ((e === 1 ? st : k)($e(r)), r.length = 0) : r.push(t);\n  }, Vn = (e, t, r, n) => {\n    for (var a = 0, i = 0; i < r; i++) {\n      var u = P[t >> 2], s = P[t + 4 >> 2];\n      t += 8;\n      for (var l = 0; l < s; l++)\n        Un(e, B[u + l]);\n      a += s;\n    }\n    return P[n >> 2] = a, 0;\n  }, kn = (e) => e;\n  br(), _r(), Br(), Xr(), c.noExitRuntime && c.noExitRuntime, c.print && (st = c.print), c.printErr && (k = c.printErr), c.wasmBinary && (Z = c.wasmBinary), c.arguments && c.arguments, c.thisProgram && (M = c.thisProgram);\n  var Hn = {\n    s: ur,\n    w: cr,\n    a: lr,\n    j: fr,\n    m: dr,\n    N: hr,\n    p: pr,\n    da: vr,\n    d: yr,\n    _: mr,\n    sa: wr,\n    Z: $r,\n    na: Tr,\n    qa: kr,\n    pa: Nr,\n    F: zr,\n    la: qr,\n    R: Zr,\n    S: Qr,\n    y: Kr,\n    t: tn,\n    ra: rn,\n    ma: on,\n    O: hn,\n    K: pn,\n    ta: vn,\n    oa: yn,\n    V: mn,\n    ua: zt,\n    wa: $n,\n    $: En,\n    T: _n,\n    va: On,\n    ka: xn,\n    aa: An,\n    ea: Mn,\n    ba: jn,\n    ca: Rn,\n    fa: Ln,\n    X: Bn,\n    Q: Vn,\n    I: ba,\n    C: Ta,\n    U: oa,\n    P: Sa,\n    q: ma,\n    b: ea,\n    D: $a,\n    ia: Ea,\n    c: na,\n    ha: _a,\n    h: aa,\n    i: la,\n    r: da,\n    M: wa,\n    v: pa,\n    E: ya,\n    J: ga,\n    A: Pa,\n    H: Ia,\n    W: Fa,\n    k: sa,\n    f: ia,\n    e: ra,\n    g: ta,\n    L: Aa,\n    l: ca,\n    ja: Ca,\n    o: ha,\n    x: fa,\n    u: va,\n    ga: xa,\n    B: Oa,\n    n: ua,\n    G: Da,\n    Y: Ma,\n    z: kn\n  }, E = await or();\n  E.ya;\n  var Nn = E.za, et = c._free = E.Aa, Pe = c._malloc = E.Ca, zn = E.Da, v = E.Ea, Gn = E.Fa, Xn = E.Ga, qn = E.Ha, Yn = E.Ia, Zn = E.Ja, Qn = E.Ka;\n  c.dynCall_viijii = E.La;\n  var Jn = c.dynCall_vij = E.Ma;\n  c.dynCall_jiji = E.Na;\n  var Kn = c.dynCall_jiiii = E.Oa;\n  c.dynCall_iiiiij = E.Pa, c.dynCall_iiiiijj = E.Qa, c.dynCall_iiiiiijj = E.Ra;\n  function ta(e, t, r, n) {\n    var a = m();\n    try {\n      g(e)(t, r, n);\n    } catch (i) {\n      if (y(a), i !== i + 0) throw i;\n      v(1, 0);\n    }\n  }\n  function ea(e, t) {\n    var r = m();\n    try {\n      return g(e)(t);\n    } catch (n) {\n      if (y(r), n !== n + 0) throw n;\n      v(1, 0);\n    }\n  }\n  function ra(e, t, r) {\n    var n = m();\n    try {\n      g(e)(t, r);\n    } catch (a) {\n      if (y(n), a !== a + 0) throw a;\n      v(1, 0);\n    }\n  }\n  function na(e, t, r) {\n    var n = m();\n    try {\n      return g(e)(t, r);\n    } catch (a) {\n      if (y(n), a !== a + 0) throw a;\n      v(1, 0);\n    }\n  }\n  function aa(e, t, r, n) {\n    var a = m();\n    try {\n      return g(e)(t, r, n);\n    } catch (i) {\n      if (y(a), i !== i + 0) throw i;\n      v(1, 0);\n    }\n  }\n  function oa(e, t, r, n, a) {\n    var i = m();\n    try {\n      return g(e)(t, r, n, a);\n    } catch (u) {\n      if (y(i), u !== u + 0) throw u;\n      v(1, 0);\n    }\n  }\n  function ia(e, t) {\n    var r = m();\n    try {\n      g(e)(t);\n    } catch (n) {\n      if (y(r), n !== n + 0) throw n;\n      v(1, 0);\n    }\n  }\n  function sa(e) {\n    var t = m();\n    try {\n      g(e)();\n    } catch (r) {\n      if (y(t), r !== r + 0) throw r;\n      v(1, 0);\n    }\n  }\n  function ua(e, t, r, n, a, i, u, s, l, d, h) {\n    var p = m();\n    try {\n      g(e)(t, r, n, a, i, u, s, l, d, h);\n    } catch (w) {\n      if (y(p), w !== w + 0) throw w;\n      v(1, 0);\n    }\n  }\n  function ca(e, t, r, n, a) {\n    var i = m();\n    try {\n      g(e)(t, r, n, a);\n    } catch (u) {\n      if (y(i), u !== u + 0) throw u;\n      v(1, 0);\n    }\n  }\n  function la(e, t, r, n, a) {\n    var i = m();\n    try {\n      return g(e)(t, r, n, a);\n    } catch (u) {\n      if (y(i), u !== u + 0) throw u;\n      v(1, 0);\n    }\n  }\n  function fa(e, t, r, n, a, i, u) {\n    var s = m();\n    try {\n      g(e)(t, r, n, a, i, u);\n    } catch (l) {\n      if (y(s), l !== l + 0) throw l;\n      v(1, 0);\n    }\n  }\n  function da(e, t, r, n, a, i) {\n    var u = m();\n    try {\n      return g(e)(t, r, n, a, i);\n    } catch (s) {\n      if (y(u), s !== s + 0) throw s;\n      v(1, 0);\n    }\n  }\n  function ha(e, t, r, n, a, i) {\n    var u = m();\n    try {\n      g(e)(t, r, n, a, i);\n    } catch (s) {\n      if (y(u), s !== s + 0) throw s;\n      v(1, 0);\n    }\n  }\n  function pa(e, t, r, n, a, i, u) {\n    var s = m();\n    try {\n      return g(e)(t, r, n, a, i, u);\n    } catch (l) {\n      if (y(s), l !== l + 0) throw l;\n      v(1, 0);\n    }\n  }\n  function va(e, t, r, n, a, i, u, s) {\n    var l = m();\n    try {\n      g(e)(t, r, n, a, i, u, s);\n    } catch (d) {\n      if (y(l), d !== d + 0) throw d;\n      v(1, 0);\n    }\n  }\n  function ya(e, t, r, n, a, i, u, s) {\n    var l = m();\n    try {\n      return g(e)(t, r, n, a, i, u, s);\n    } catch (d) {\n      if (y(l), d !== d + 0) throw d;\n      v(1, 0);\n    }\n  }\n  function ma(e) {\n    var t = m();\n    try {\n      return g(e)();\n    } catch (r) {\n      if (y(t), r !== r + 0) throw r;\n      v(1, 0);\n    }\n  }\n  function ga(e, t, r, n, a, i, u, s, l) {\n    var d = m();\n    try {\n      return g(e)(t, r, n, a, i, u, s, l);\n    } catch (h) {\n      if (y(d), h !== h + 0) throw h;\n      v(1, 0);\n    }\n  }\n  function wa(e, t, r, n, a, i, u) {\n    var s = m();\n    try {\n      return g(e)(t, r, n, a, i, u);\n    } catch (l) {\n      if (y(s), l !== l + 0) throw l;\n      v(1, 0);\n    }\n  }\n  function $a(e, t, r, n) {\n    var a = m();\n    try {\n      return g(e)(t, r, n);\n    } catch (i) {\n      if (y(a), i !== i + 0) throw i;\n      v(1, 0);\n    }\n  }\n  function ba(e, t, r, n) {\n    var a = m();\n    try {\n      return g(e)(t, r, n);\n    } catch (i) {\n      if (y(a), i !== i + 0) throw i;\n      v(1, 0);\n    }\n  }\n  function Ca(e, t, r, n, a, i, u, s) {\n    var l = m();\n    try {\n      g(e)(t, r, n, a, i, u, s);\n    } catch (d) {\n      if (y(l), d !== d + 0) throw d;\n      v(1, 0);\n    }\n  }\n  function Ta(e, t, r, n, a, i) {\n    var u = m();\n    try {\n      return g(e)(t, r, n, a, i);\n    } catch (s) {\n      if (y(u), s !== s + 0) throw s;\n      v(1, 0);\n    }\n  }\n  function Pa(e, t, r, n, a, i, u, s, l, d) {\n    var h = m();\n    try {\n      return g(e)(t, r, n, a, i, u, s, l, d);\n    } catch (p) {\n      if (y(h), p !== p + 0) throw p;\n      v(1, 0);\n    }\n  }\n  function Ea(e, t, r) {\n    var n = m();\n    try {\n      return g(e)(t, r);\n    } catch (a) {\n      if (y(n), a !== a + 0) throw a;\n      v(1, 0);\n    }\n  }\n  function _a(e, t, r, n, a) {\n    var i = m();\n    try {\n      return g(e)(t, r, n, a);\n    } catch (u) {\n      if (y(i), u !== u + 0) throw u;\n      v(1, 0);\n    }\n  }\n  function Oa(e, t, r, n, a, i, u, s, l, d) {\n    var h = m();\n    try {\n      g(e)(t, r, n, a, i, u, s, l, d);\n    } catch (p) {\n      if (y(h), p !== p + 0) throw p;\n      v(1, 0);\n    }\n  }\n  function xa(e, t, r, n, a, i, u, s, l) {\n    var d = m();\n    try {\n      g(e)(t, r, n, a, i, u, s, l);\n    } catch (h) {\n      if (y(d), h !== h + 0) throw h;\n      v(1, 0);\n    }\n  }\n  function Aa(e, t, r, n, a, i, u) {\n    var s = m();\n    try {\n      g(e)(t, r, n, a, i, u);\n    } catch (l) {\n      if (y(s), l !== l + 0) throw l;\n      v(1, 0);\n    }\n  }\n  function Sa(e, t, r, n) {\n    var a = m();\n    try {\n      return g(e)(t, r, n);\n    } catch (i) {\n      if (y(a), i !== i + 0) throw i;\n      v(1, 0);\n    }\n  }\n  function Ia(e, t, r, n, a, i, u, s, l, d, h, p) {\n    var w = m();\n    try {\n      return g(e)(t, r, n, a, i, u, s, l, d, h, p);\n    } catch (b) {\n      if (y(w), b !== b + 0) throw b;\n      v(1, 0);\n    }\n  }\n  function Da(e, t, r, n, a, i, u, s, l, d, h, p, w, b, _, S) {\n    var A = m();\n    try {\n      g(e)(t, r, n, a, i, u, s, l, d, h, p, w, b, _, S);\n    } catch (I) {\n      if (y(A), I !== I + 0) throw I;\n      v(1, 0);\n    }\n  }\n  function Ma(e, t, r, n) {\n    var a = m();\n    try {\n      Jn(e, t, r, n);\n    } catch (i) {\n      if (y(a), i !== i + 0) throw i;\n      v(1, 0);\n    }\n  }\n  function Fa(e, t, r, n, a) {\n    var i = m();\n    try {\n      return Kn(e, t, r, n, a);\n    } catch (u) {\n      if (y(i), u !== u + 0) throw u;\n      v(1, 0);\n    }\n  }\n  function qt() {\n    if (J > 0) {\n      ct = qt;\n      return;\n    }\n    if (qe(), J > 0) {\n      ct = qt;\n      return;\n    }\n    function e() {\n      var t;\n      c.calledRun = !0, !Jt && (Ye(), T(c), (t = c.onRuntimeInitialized) === null || t === void 0 || t.call(c), Ze());\n    }\n    c.setStatus ? (c.setStatus(\"Running...\"), setTimeout(() => {\n      setTimeout(() => c.setStatus(\"\"), 1), e();\n    }, 1)) : e();\n  }\n  function ja() {\n    if (c.preInit)\n      for (typeof c.preInit == \"function\" && (c.preInit = [c.preInit]); c.preInit.length > 0; )\n        c.preInit.shift()();\n  }\n  return ja(), qt(), f = x, f;\n};\nfunction Be(o) {\n  return Le(Qt, o);\n}\nfunction Co() {\n  return Ka(Qt);\n}\nfunction To(o) {\n  Be({\n    overrides: o,\n    equalityFn: Object.is,\n    fireImmediately: !1\n  });\n}\nasync function eo(o, f) {\n  return to(Qt, o, f);\n}\nconst Po = \"3c07027dbfd6da47330ac18e74e6924019d9ac9a4c1e161b800666f9e3c925ca\", We = [\n  [\"aztec\", \"Aztec\"],\n  [\"code_128\", \"Code128\"],\n  [\"code_39\", \"Code39\"],\n  [\"code_93\", \"Code93\"],\n  [\"codabar\", \"Codabar\"],\n  [\"databar\", \"DataBar\"],\n  [\"databar_expanded\", \"DataBarExpanded\"],\n  [\"databar_limited\", \"DataBarLimited\"],\n  [\"data_matrix\", \"DataMatrix\"],\n  [\"dx_film_edge\", \"DXFilmEdge\"],\n  [\"ean_13\", \"EAN-13\"],\n  [\"ean_8\", \"EAN-8\"],\n  [\"itf\", \"ITF\"],\n  [\"maxi_code\", \"MaxiCode\"],\n  [\"micro_qr_code\", \"MicroQRCode\"],\n  [\"pdf417\", \"PDF417\"],\n  [\"qr_code\", \"QRCode\"],\n  [\"rm_qr_code\", \"rMQRCode\"],\n  [\"upc_a\", \"UPC-A\"],\n  [\"upc_e\", \"UPC-E\"],\n  [\"linear_codes\", \"Linear-Codes\"],\n  [\"matrix_codes\", \"Matrix-Codes\"],\n  [\"any\", \"Any\"]\n], ro = [...We, [\"unknown\"]].map((o) => o[0]), Zt = new Map(\n  We\n);\nfunction no(o) {\n  for (const [f, c] of Zt)\n    if (o === c)\n      return f;\n  return \"unknown\";\n}\nfunction ao(o) {\n  if (Ue(o))\n    return {\n      width: o.naturalWidth,\n      height: o.naturalHeight\n    };\n  if (Ve(o))\n    return {\n      width: o.width.baseVal.value,\n      height: o.height.baseVal.value\n    };\n  if (ke(o))\n    return {\n      width: o.videoWidth,\n      height: o.videoHeight\n    };\n  if (Ne(o))\n    return {\n      width: o.width,\n      height: o.height\n    };\n  if (Ge(o))\n    return {\n      width: o.displayWidth,\n      height: o.displayHeight\n    };\n  if (He(o))\n    return {\n      width: o.width,\n      height: o.height\n    };\n  if (ze(o))\n    return {\n      width: o.width,\n      height: o.height\n    };\n  throw new TypeError(\n    \"The provided value is not of type '(Blob or HTMLCanvasElement or HTMLImageElement or HTMLVideoElement or ImageBitmap or ImageData or OffscreenCanvas or SVGImageElement or VideoFrame)'.\"\n  );\n}\nfunction Ue(o) {\n  var f, c;\n  try {\n    return o instanceof ((c = (f = o == null ? void 0 : o.ownerDocument) == null ? void 0 : f.defaultView) == null ? void 0 : c.HTMLImageElement);\n  } catch {\n    return !1;\n  }\n}\nfunction Ve(o) {\n  var f, c;\n  try {\n    return o instanceof ((c = (f = o == null ? void 0 : o.ownerDocument) == null ? void 0 : f.defaultView) == null ? void 0 : c.SVGImageElement);\n  } catch {\n    return !1;\n  }\n}\nfunction ke(o) {\n  var f, c;\n  try {\n    return o instanceof ((c = (f = o == null ? void 0 : o.ownerDocument) == null ? void 0 : f.defaultView) == null ? void 0 : c.HTMLVideoElement);\n  } catch {\n    return !1;\n  }\n}\nfunction He(o) {\n  var f, c;\n  try {\n    return o instanceof ((c = (f = o == null ? void 0 : o.ownerDocument) == null ? void 0 : f.defaultView) == null ? void 0 : c.HTMLCanvasElement);\n  } catch {\n    return !1;\n  }\n}\nfunction Ne(o) {\n  try {\n    return o instanceof ImageBitmap || Object.prototype.toString.call(o) === \"[object ImageBitmap]\";\n  } catch {\n    return !1;\n  }\n}\nfunction ze(o) {\n  try {\n    return o instanceof OffscreenCanvas || Object.prototype.toString.call(o) === \"[object OffscreenCanvas]\";\n  } catch {\n    return !1;\n  }\n}\nfunction Ge(o) {\n  try {\n    return o instanceof VideoFrame || Object.prototype.toString.call(o) === \"[object VideoFrame]\";\n  } catch {\n    return !1;\n  }\n}\nfunction oo(o) {\n  try {\n    return o instanceof Blob || Object.prototype.toString.call(o) === \"[object Blob]\";\n  } catch {\n    return !1;\n  }\n}\nfunction io(o) {\n  try {\n    return o instanceof ImageData || Object.prototype.toString.call(o) === \"[object ImageData]\";\n  } catch {\n    return !1;\n  }\n}\nfunction so(o, f) {\n  try {\n    const c = new OffscreenCanvas(o, f);\n    if (c.getContext(\"2d\") instanceof OffscreenCanvasRenderingContext2D)\n      return c;\n    throw void 0;\n  } catch {\n    const c = document.createElement(\"canvas\");\n    return c.width = o, c.height = f, c;\n  }\n}\nasync function Xe(o) {\n  if (Ue(o) && !await fo(o))\n    throw new DOMException(\n      \"Failed to load or decode HTMLImageElement.\",\n      \"InvalidStateError\"\n    );\n  if (Ve(o) && !await ho(o))\n    throw new DOMException(\n      \"Failed to load or decode SVGImageElement.\",\n      \"InvalidStateError\"\n    );\n  if (Ge(o) && po(o))\n    throw new DOMException(\"VideoFrame is closed.\", \"InvalidStateError\");\n  if (ke(o) && (o.readyState === 0 || o.readyState === 1))\n    throw new DOMException(\"Invalid element or state.\", \"InvalidStateError\");\n  if (Ne(o) && yo(o))\n    throw new DOMException(\n      \"The image source is detached.\",\n      \"InvalidStateError\"\n    );\n  const { width: f, height: c } = ao(o);\n  if (f === 0 || c === 0)\n    return null;\n  const $ = so(f, c).getContext(\"2d\");\n  $.drawImage(o, 0, 0);\n  try {\n    return $.getImageData(0, 0, f, c);\n  } catch {\n    throw new DOMException(\"Source would taint origin.\", \"SecurityError\");\n  }\n}\nasync function uo(o) {\n  let f;\n  try {\n    f = await createImageBitmap(o);\n  } catch {\n    try {\n      if (globalThis.Image) {\n        f = new Image();\n        let $ = \"\";\n        try {\n          $ = URL.createObjectURL(o), f.src = $, await f.decode();\n        } finally {\n          URL.revokeObjectURL($);\n        }\n      } else\n        return o;\n    } catch {\n      throw new DOMException(\n        \"Failed to load or decode Blob.\",\n        \"InvalidStateError\"\n      );\n    }\n  }\n  return await Xe(f);\n}\nfunction co(o) {\n  const { width: f, height: c } = o;\n  if (f === 0 || c === 0)\n    return null;\n  const T = o.getContext(\"2d\");\n  try {\n    return T.getImageData(0, 0, f, c);\n  } catch {\n    throw new DOMException(\"Source would taint origin.\", \"SecurityError\");\n  }\n}\nasync function lo(o) {\n  if (oo(o))\n    return await uo(o);\n  if (io(o)) {\n    if (vo(o))\n      throw new DOMException(\n        \"The image data has been detached.\",\n        \"InvalidStateError\"\n      );\n    return o;\n  }\n  return He(o) || ze(o) ? co(o) : await Xe(o);\n}\nasync function fo(o) {\n  try {\n    return await o.decode(), !0;\n  } catch {\n    return !1;\n  }\n}\nasync function ho(o) {\n  var f;\n  try {\n    return await ((f = o.decode) == null ? void 0 : f.call(o)), !0;\n  } catch {\n    return !1;\n  }\n}\nfunction po(o) {\n  return o.format === null;\n}\nfunction vo(o) {\n  return o.data.buffer.byteLength === 0;\n}\nfunction yo(o) {\n  return o.width === 0 && o.height === 0;\n}\nfunction Re(o, f) {\n  return mo(o) ? new DOMException(`${f}: ${o.message}`, o.name) : go(o) ? new o.constructor(`${f}: ${o.message}`) : new Error(`${f}: ${o}`);\n}\nfunction mo(o) {\n  return o instanceof DOMException || Object.prototype.toString.call(o) === \"[object DOMException]\";\n}\nfunction go(o) {\n  return o instanceof Error || Object.prototype.toString.call(o) === \"[object Error]\";\n}\nvar pt;\nclass Eo {\n  constructor(f = {}) {\n    De(this, pt);\n    var c;\n    try {\n      const T = (c = f == null ? void 0 : f.formats) == null ? void 0 : c.filter(\n        ($) => $ !== \"unknown\"\n      );\n      if ((T == null ? void 0 : T.length) === 0)\n        throw new TypeError(\"Hint option provided, but is empty.\");\n      for (const $ of T != null ? T : [])\n        if (!Zt.has($))\n          throw new TypeError(\n            `Failed to read the 'formats' property from 'BarcodeDetectorOptions': The provided value '${$}' is not a valid enum value of type BarcodeFormat.`\n          );\n      Me(this, pt, T != null ? T : []), Be({ fireImmediately: !0 }).catch(() => {\n      });\n    } catch (T) {\n      throw Re(\n        T,\n        \"Failed to construct 'BarcodeDetector'\"\n      );\n    }\n  }\n  static async getSupportedFormats() {\n    return ro.filter((f) => f !== \"unknown\");\n  }\n  async detect(f) {\n    try {\n      const c = await lo(f);\n      if (c === null)\n        return [];\n      let T;\n      const $ = {\n        tryCode39ExtendedMode: !1,\n        textMode: \"Plain\",\n        formats: Ie(this, pt).map((x) => Zt.get(x))\n      };\n      try {\n        T = await eo(c, $);\n      } catch (x) {\n        throw console.error(x), new DOMException(\n          \"Barcode detection service unavailable.\",\n          \"NotSupportedError\"\n        );\n      }\n      return T.map((x) => {\n        const {\n          topLeft: { x: D, y: R },\n          topRight: { x: O, y: M },\n          bottomLeft: { x: F, y: q },\n          bottomRight: { x: rt, y: Y }\n        } = x.position, st = Math.min(D, O, F, rt), k = Math.min(R, M, q, Y), Z = Math.max(D, O, F, rt), nt = Math.max(R, M, q, Y);\n        return {\n          boundingBox: new DOMRectReadOnly(\n            st,\n            k,\n            Z - st,\n            nt - k\n          ),\n          rawValue: x.text,\n          format: no(x.format),\n          cornerPoints: [\n            {\n              x: D,\n              y: R\n            },\n            {\n              x: O,\n              y: M\n            },\n            {\n              x: rt,\n              y: Y\n            },\n            {\n              x: F,\n              y: q\n            }\n          ]\n        };\n      });\n    } catch (c) {\n      throw Re(\n        c,\n        \"Failed to execute 'detect' on 'BarcodeDetector'\"\n      );\n    }\n  }\n}\npt = new WeakMap();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iYXJjb2RlLWRldGVjdG9yL2Rpc3QvZXMvcG9ueWZpbGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsS0FBSyxHQUFHLEVBQUU7QUFDbEY7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsT0FBTyx1QkFBdUIsT0FBTyxnQ0FBZ0MsT0FBTyw4QkFBOEIsT0FBTztBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGlCQUFpQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGtCQUFrQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixrREFBa0QsRUFBRTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUiw0Q0FBNEMsRUFBRTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRyw0QkFBNEI7QUFDL0IsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLHNCQUFzQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0JBQXNCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNCQUFzQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEVBQUUsSUFBSSxVQUFVLDBDQUEwQyxFQUFFLElBQUksVUFBVSxrQkFBa0IsRUFBRSxJQUFJLEVBQUU7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csRUFBRTtBQUMxRztBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEUsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDLHNCQUFzQixZQUFZO0FBQ2xDLHdCQUF3QixZQUFZO0FBQ3BDLHlCQUF5QjtBQUN6QixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTRSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvYmFyY29kZS1kZXRlY3Rvci9kaXN0L2VzL3BvbnlmaWxsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBBZSA9IChvKSA9PiB7XG4gIHRocm93IFR5cGVFcnJvcihvKTtcbn07XG52YXIgU2UgPSAobywgZiwgYykgPT4gZi5oYXMobykgfHwgQWUoXCJDYW5ub3QgXCIgKyBjKTtcbnZhciBJZSA9IChvLCBmLCBjKSA9PiAoU2UobywgZiwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKSwgYyA/IGMuY2FsbChvKSA6IGYuZ2V0KG8pKSwgRGUgPSAobywgZiwgYykgPT4gZi5oYXMobykgPyBBZShcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIikgOiBmIGluc3RhbmNlb2YgV2Vha1NldCA/IGYuYWRkKG8pIDogZi5zZXQobywgYyksIE1lID0gKG8sIGYsIGMsIFQpID0+IChTZShvLCBmLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIiksIFQgPyBULmNhbGwobywgYykgOiBmLnNldChvLCBjKSwgYyk7XG5jb25zdCBEdCA9IFtcbiAgW1wiQXp0ZWNcIiwgXCJNXCJdLFxuICBbXCJDb2RhYmFyXCIsIFwiTFwiXSxcbiAgW1wiQ29kZTM5XCIsIFwiTFwiXSxcbiAgW1wiQ29kZTkzXCIsIFwiTFwiXSxcbiAgW1wiQ29kZTEyOFwiLCBcIkxcIl0sXG4gIFtcIkRhdGFCYXJcIiwgXCJMXCJdLFxuICBbXCJEYXRhQmFyRXhwYW5kZWRcIiwgXCJMXCJdLFxuICBbXCJEYXRhTWF0cml4XCIsIFwiTVwiXSxcbiAgW1wiRUFOLThcIiwgXCJMXCJdLFxuICBbXCJFQU4tMTNcIiwgXCJMXCJdLFxuICBbXCJJVEZcIiwgXCJMXCJdLFxuICBbXCJNYXhpQ29kZVwiLCBcIk1cIl0sXG4gIFtcIlBERjQxN1wiLCBcIk1cIl0sXG4gIFtcIlFSQ29kZVwiLCBcIk1cIl0sXG4gIFtcIlVQQy1BXCIsIFwiTFwiXSxcbiAgW1wiVVBDLUVcIiwgXCJMXCJdLFxuICBbXCJNaWNyb1FSQ29kZVwiLCBcIk1cIl0sXG4gIFtcInJNUVJDb2RlXCIsIFwiTVwiXSxcbiAgW1wiRFhGaWxtRWRnZVwiLCBcIkxcIl0sXG4gIFtcIkRhdGFCYXJMaW1pdGVkXCIsIFwiTFwiXVxuXSwgTXQgPSBEdC5tYXAoKFtvXSkgPT4gbyksIExhID0gTXQuZmlsdGVyKFxuICAobywgZikgPT4gRHRbZl1bMV0gPT09IFwiTFwiXG4pLCBCYSA9IE10LmZpbHRlcihcbiAgKG8sIGYpID0+IER0W2ZdWzFdID09PSBcIk1cIlxuKTtcbmZ1bmN0aW9uIFl0KG8pIHtcbiAgc3dpdGNoIChvKSB7XG4gICAgY2FzZSBcIkxpbmVhci1Db2Rlc1wiOlxuICAgICAgcmV0dXJuIExhLnJlZHVjZSgoZiwgYykgPT4gZiB8IFl0KGMpLCAwKTtcbiAgICBjYXNlIFwiTWF0cml4LUNvZGVzXCI6XG4gICAgICByZXR1cm4gQmEucmVkdWNlKChmLCBjKSA9PiBmIHwgWXQoYyksIDApO1xuICAgIGNhc2UgXCJBbnlcIjpcbiAgICAgIHJldHVybiAoMSA8PCBEdC5sZW5ndGgpIC0gMTtcbiAgICBjYXNlIFwiTm9uZVwiOlxuICAgICAgcmV0dXJuIDA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAxIDw8IE10LmluZGV4T2Yobyk7XG4gIH1cbn1cbmZ1bmN0aW9uIFdhKG8pIHtcbiAgaWYgKG8gPT09IDApXG4gICAgcmV0dXJuIFwiTm9uZVwiO1xuICBjb25zdCBmID0gMzEgLSBNYXRoLmNsejMyKG8pO1xuICByZXR1cm4gTXRbZl07XG59XG5mdW5jdGlvbiBVYShvKSB7XG4gIHJldHVybiBvLnJlZHVjZSgoZiwgYykgPT4gZiB8IFl0KGMpLCAwKTtcbn1cbmNvbnN0IFZhID0gW1xuICBcIkxvY2FsQXZlcmFnZVwiLFxuICBcIkdsb2JhbEhpc3RvZ3JhbVwiLFxuICBcIkZpeGVkVGhyZXNob2xkXCIsXG4gIFwiQm9vbENhc3RcIlxuXTtcbmZ1bmN0aW9uIGthKG8pIHtcbiAgcmV0dXJuIFZhLmluZGV4T2Yobyk7XG59XG5jb25zdCBGZSA9IFtcbiAgXCJVbmtub3duXCIsXG4gIFwiQVNDSUlcIixcbiAgXCJJU084ODU5XzFcIixcbiAgXCJJU084ODU5XzJcIixcbiAgXCJJU084ODU5XzNcIixcbiAgXCJJU084ODU5XzRcIixcbiAgXCJJU084ODU5XzVcIixcbiAgXCJJU084ODU5XzZcIixcbiAgXCJJU084ODU5XzdcIixcbiAgXCJJU084ODU5XzhcIixcbiAgXCJJU084ODU5XzlcIixcbiAgXCJJU084ODU5XzEwXCIsXG4gIFwiSVNPODg1OV8xMVwiLFxuICBcIklTTzg4NTlfMTNcIixcbiAgXCJJU084ODU5XzE0XCIsXG4gIFwiSVNPODg1OV8xNVwiLFxuICBcIklTTzg4NTlfMTZcIixcbiAgXCJDcDQzN1wiLFxuICBcIkNwMTI1MFwiLFxuICBcIkNwMTI1MVwiLFxuICBcIkNwMTI1MlwiLFxuICBcIkNwMTI1NlwiLFxuICBcIlNoaWZ0X0pJU1wiLFxuICBcIkJpZzVcIixcbiAgXCJHQjIzMTJcIixcbiAgXCJHQjE4MDMwXCIsXG4gIFwiRVVDX0pQXCIsXG4gIFwiRVVDX0tSXCIsXG4gIFwiVVRGMTZCRVwiLFxuICAvKipcbiAgICogVW5pY29kZUJpZyBbW2RlcHJlY2F0ZWRdXVxuICAgKi9cbiAgXCJVVEYxNkJFXCIsXG4gIFwiVVRGOFwiLFxuICBcIlVURjE2TEVcIixcbiAgXCJVVEYzMkJFXCIsXG4gIFwiVVRGMzJMRVwiLFxuICBcIkJJTkFSWVwiXG5dO1xuZnVuY3Rpb24gSGEobykge1xuICByZXR1cm4gbyA9PT0gXCJVbmljb2RlQmlnXCIgPyBGZS5pbmRleE9mKFwiVVRGMTZCRVwiKSA6IEZlLmluZGV4T2Yobyk7XG59XG5jb25zdCBOYSA9IFtcbiAgXCJUZXh0XCIsXG4gIFwiQmluYXJ5XCIsXG4gIFwiTWl4ZWRcIixcbiAgXCJHUzFcIixcbiAgXCJJU08xNTQzNFwiLFxuICBcIlVua25vd25FQ0lcIlxuXTtcbmZ1bmN0aW9uIHphKG8pIHtcbiAgcmV0dXJuIE5hW29dO1xufVxuY29uc3QgR2EgPSBbXCJJZ25vcmVcIiwgXCJSZWFkXCIsIFwiUmVxdWlyZVwiXTtcbmZ1bmN0aW9uIFhhKG8pIHtcbiAgcmV0dXJuIEdhLmluZGV4T2Yobyk7XG59XG5jb25zdCBxYSA9IFtcIlBsYWluXCIsIFwiRUNJXCIsIFwiSFJJXCIsIFwiSGV4XCIsIFwiRXNjYXBlZFwiXTtcbmZ1bmN0aW9uIFlhKG8pIHtcbiAgcmV0dXJuIHFhLmluZGV4T2Yobyk7XG59XG5jb25zdCBJdCA9IHtcbiAgZm9ybWF0czogW10sXG4gIHRyeUhhcmRlcjogITAsXG4gIHRyeVJvdGF0ZTogITAsXG4gIHRyeUludmVydDogITAsXG4gIHRyeURvd25zY2FsZTogITAsXG4gIHRyeURlbm9pc2U6ICExLFxuICBiaW5hcml6ZXI6IFwiTG9jYWxBdmVyYWdlXCIsXG4gIGlzUHVyZTogITEsXG4gIGRvd25zY2FsZUZhY3RvcjogMyxcbiAgZG93bnNjYWxlVGhyZXNob2xkOiA1MDAsXG4gIG1pbkxpbmVDb3VudDogMixcbiAgbWF4TnVtYmVyT2ZTeW1ib2xzOiAyNTUsXG4gIHRyeUNvZGUzOUV4dGVuZGVkTW9kZTogITAsXG4gIHJldHVybkVycm9yczogITEsXG4gIGVhbkFkZE9uU3ltYm9sOiBcIklnbm9yZVwiLFxuICB0ZXh0TW9kZTogXCJIUklcIixcbiAgY2hhcmFjdGVyU2V0OiBcIlVua25vd25cIlxufTtcbmZ1bmN0aW9uIGplKG8pIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5vLFxuICAgIGZvcm1hdHM6IFVhKG8uZm9ybWF0cyksXG4gICAgYmluYXJpemVyOiBrYShvLmJpbmFyaXplciksXG4gICAgZWFuQWRkT25TeW1ib2w6IFhhKG8uZWFuQWRkT25TeW1ib2wpLFxuICAgIHRleHRNb2RlOiBZYShvLnRleHRNb2RlKSxcbiAgICBjaGFyYWN0ZXJTZXQ6IEhhKG8uY2hhcmFjdGVyU2V0KVxuICB9O1xufVxuZnVuY3Rpb24gWmEobykge1xuICByZXR1cm4ge1xuICAgIC4uLm8sXG4gICAgZm9ybWF0OiBXYShvLmZvcm1hdCksXG4gICAgY29udGVudFR5cGU6IHphKG8uY29udGVudFR5cGUpLFxuICAgIGVjY0xldmVsOiBvLmVjTGV2ZWxcbiAgfTtcbn1cbmNvbnN0ICRvID0gXCIyLjEuMlwiLCBibyA9IFwiYTE1MTZiMzQxNjdjZmY1MDRiZjNjODM2OThlYTg0MWUxM2E4ZjdmMVwiLCBRYSA9IHtcbiAgbG9jYXRlRmlsZTogKG8sIGYpID0+IHtcbiAgICBjb25zdCBjID0gby5tYXRjaCgvXyguKz8pXFwud2FzbSQvKTtcbiAgICByZXR1cm4gYyA/IGBodHRwczovL2Zhc3RseS5qc2RlbGl2ci5uZXQvbnBtL3p4aW5nLXdhc21AMi4xLjIvZGlzdC8ke2NbMV19LyR7b31gIDogZiArIG87XG4gIH1cbn0sIFN0ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBKYShvLCBmKSB7XG4gIHJldHVybiBPYmplY3QuaXMobywgZikgfHwgT2JqZWN0LmtleXMobykubGVuZ3RoID09PSBPYmplY3Qua2V5cyhmKS5sZW5ndGggJiYgT2JqZWN0LmtleXMobykuZXZlcnkoXG4gICAgKGMpID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmLCBjKSAmJiBvW2NdID09PSBmW2NdXG4gICk7XG59XG5mdW5jdGlvbiBMZShvLCB7XG4gIG92ZXJyaWRlczogZixcbiAgZXF1YWxpdHlGbjogYyA9IEphLFxuICBmaXJlSW1tZWRpYXRlbHk6IFQgPSAhMVxufSA9IHt9KSB7XG4gIHZhciAkO1xuICBjb25zdCBbeCwgRF0gPSAoJCA9IFN0LmdldChvKSkgIT0gbnVsbCA/ICQgOiBbUWFdLCBSID0gZiAhPSBudWxsID8gZiA6IHg7XG4gIGxldCBPO1xuICBpZiAoVCkge1xuICAgIGlmIChEICYmIChPID0gYyh4LCBSKSkpXG4gICAgICByZXR1cm4gRDtcbiAgICBjb25zdCBNID0gbyh7XG4gICAgICAuLi5SXG4gICAgfSk7XG4gICAgcmV0dXJuIFN0LnNldChvLCBbUiwgTV0pLCBNO1xuICB9XG4gIChPICE9IG51bGwgPyBPIDogYyh4LCBSKSkgfHwgU3Quc2V0KG8sIFtSXSk7XG59XG5mdW5jdGlvbiBLYShvKSB7XG4gIFN0LmRlbGV0ZShvKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHRvKG8sIGYsIGMgPSBJdCkge1xuICBjb25zdCBUID0ge1xuICAgIC4uLkl0LFxuICAgIC4uLmNcbiAgfSwgJCA9IGF3YWl0IExlKG8sIHtcbiAgICBmaXJlSW1tZWRpYXRlbHk6ICEwXG4gIH0pO1xuICBsZXQgeCwgRDtcbiAgaWYgKFwid2lkdGhcIiBpbiBmICYmIFwiaGVpZ2h0XCIgaW4gZiAmJiBcImRhdGFcIiBpbiBmKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YTogTyxcbiAgICAgIGRhdGE6IHsgYnl0ZUxlbmd0aDogTSB9LFxuICAgICAgd2lkdGg6IEYsXG4gICAgICBoZWlnaHQ6IHFcbiAgICB9ID0gZjtcbiAgICBEID0gJC5fbWFsbG9jKE0pLCAkLkhFQVBVOC5zZXQoTywgRCksIHggPSAkLnJlYWRCYXJjb2Rlc0Zyb21QaXhtYXAoXG4gICAgICBELFxuICAgICAgRixcbiAgICAgIHEsXG4gICAgICBqZShUKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IE8sIE07XG4gICAgaWYgKFwiYnVmZmVyXCIgaW4gZilcbiAgICAgIFtPLCBNXSA9IFtmLmJ5dGVMZW5ndGgsIGZdO1xuICAgIGVsc2UgaWYgKFwiYnl0ZUxlbmd0aFwiIGluIGYpXG4gICAgICBbTywgTV0gPSBbZi5ieXRlTGVuZ3RoLCBuZXcgVWludDhBcnJheShmKV07XG4gICAgZWxzZSBpZiAoXCJzaXplXCIgaW4gZilcbiAgICAgIFtPLCBNXSA9IFtmLnNpemUsIG5ldyBVaW50OEFycmF5KGF3YWl0IGYuYXJyYXlCdWZmZXIoKSldO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGVcIik7XG4gICAgRCA9ICQuX21hbGxvYyhPKSwgJC5IRUFQVTguc2V0KE0sIEQpLCB4ID0gJC5yZWFkQmFyY29kZXNGcm9tSW1hZ2UoXG4gICAgICBELFxuICAgICAgTyxcbiAgICAgIGplKFQpXG4gICAgKTtcbiAgfVxuICAkLl9mcmVlKEQpO1xuICBjb25zdCBSID0gW107XG4gIGZvciAobGV0IE8gPSAwOyBPIDwgeC5zaXplKCk7ICsrTylcbiAgICBSLnB1c2goXG4gICAgICBaYSh4LmdldChPKSlcbiAgICApO1xuICByZXR1cm4gUjtcbn1cbih7XG4gIC4uLkl0LFxuICBmb3JtYXRzOiBbLi4uSXQuZm9ybWF0c11cbn0pO1xudmFyIFF0ID0gYXN5bmMgZnVuY3Rpb24obyA9IHt9KSB7XG4gIHZhciBmLCBjID0gbywgVCwgJCwgeCA9IG5ldyBQcm9taXNlKChlLCB0KSA9PiB7XG4gICAgVCA9IGUsICQgPSB0O1xuICB9KSwgRCA9IHR5cGVvZiB3aW5kb3cgPT0gXCJvYmplY3RcIiwgUiA9IHR5cGVvZiBCdW4gPCBcInVcIiwgTyA9IHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA8IFwidVwiO1xuICB0eXBlb2YgcHJvY2VzcyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSA9PSBcInN0cmluZ1wiICYmIHByb2Nlc3MudHlwZSAhPSBcInJlbmRlcmVyXCI7XG4gIHZhciBNID0gXCIuL3RoaXMucHJvZ3JhbVwiLCBGID0gXCJcIjtcbiAgZnVuY3Rpb24gcShlKSB7XG4gICAgcmV0dXJuIGMubG9jYXRlRmlsZSA/IGMubG9jYXRlRmlsZShlLCBGKSA6IEYgKyBlO1xuICB9XG4gIHZhciBydCwgWTtcbiAgKEQgfHwgTyB8fCBSKSAmJiAoTyA/IEYgPSBzZWxmLmxvY2F0aW9uLmhyZWYgOiB0eXBlb2YgZG9jdW1lbnQgPCBcInVcIiAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0ICYmIChGID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLCBGLnN0YXJ0c1dpdGgoXCJibG9iOlwiKSA/IEYgPSBcIlwiIDogRiA9IEYuc2xpY2UoMCwgRi5yZXBsYWNlKC9bPyNdLiovLCBcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikgKyAxKSwgTyAmJiAoWSA9IChlKSA9PiB7XG4gICAgdmFyIHQgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXR1cm4gdC5vcGVuKFwiR0VUXCIsIGUsICExKSwgdC5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCIsIHQuc2VuZChudWxsKSwgbmV3IFVpbnQ4QXJyYXkodC5yZXNwb25zZSk7XG4gIH0pLCBydCA9IGFzeW5jIChlKSA9PiB7XG4gICAgdmFyIHQgPSBhd2FpdCBmZXRjaChlLCB7XG4gICAgICBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiXG4gICAgfSk7XG4gICAgaWYgKHQub2spXG4gICAgICByZXR1cm4gdC5hcnJheUJ1ZmZlcigpO1xuICAgIHRocm93IG5ldyBFcnJvcih0LnN0YXR1cyArIFwiIDogXCIgKyB0LnVybCk7XG4gIH0pO1xuICB2YXIgc3QgPSBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLCBrID0gY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpLCBaLCBudCwgSnQgPSAhMSwgUSwgQiwgdXQsIHZ0LCBhdCwgUCwgS3QsIHRlO1xuICBmdW5jdGlvbiBlZSgpIHtcbiAgICB2YXIgZSA9IG50LmJ1ZmZlcjtcbiAgICBRID0gbmV3IEludDhBcnJheShlKSwgdXQgPSBuZXcgSW50MTZBcnJheShlKSwgYy5IRUFQVTggPSBCID0gbmV3IFVpbnQ4QXJyYXkoZSksIHZ0ID0gbmV3IFVpbnQxNkFycmF5KGUpLCBhdCA9IG5ldyBJbnQzMkFycmF5KGUpLCBQID0gbmV3IFVpbnQzMkFycmF5KGUpLCBLdCA9IG5ldyBGbG9hdDMyQXJyYXkoZSksIHRlID0gbmV3IEZsb2F0NjRBcnJheShlKTtcbiAgfVxuICBmdW5jdGlvbiBxZSgpIHtcbiAgICBpZiAoYy5wcmVSdW4pXG4gICAgICBmb3IgKHR5cGVvZiBjLnByZVJ1biA9PSBcImZ1bmN0aW9uXCIgJiYgKGMucHJlUnVuID0gW2MucHJlUnVuXSk7IGMucHJlUnVuLmxlbmd0aDsgKVxuICAgICAgICBzcihjLnByZVJ1bi5zaGlmdCgpKTtcbiAgICByZShhZSk7XG4gIH1cbiAgZnVuY3Rpb24gWWUoKSB7XG4gICAgRS55YSgpO1xuICB9XG4gIGZ1bmN0aW9uIFplKCkge1xuICAgIGlmIChjLnBvc3RSdW4pXG4gICAgICBmb3IgKHR5cGVvZiBjLnBvc3RSdW4gPT0gXCJmdW5jdGlvblwiICYmIChjLnBvc3RSdW4gPSBbYy5wb3N0UnVuXSk7IGMucG9zdFJ1bi5sZW5ndGg7IClcbiAgICAgICAgaXIoYy5wb3N0UnVuLnNoaWZ0KCkpO1xuICAgIHJlKG5lKTtcbiAgfVxuICB2YXIgSiA9IDAsIGN0ID0gbnVsbDtcbiAgZnVuY3Rpb24gUWUoZSkge1xuICAgIHZhciB0O1xuICAgIEorKywgKHQgPSBjLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMpID09PSBudWxsIHx8IHQgPT09IHZvaWQgMCB8fCB0LmNhbGwoYywgSik7XG4gIH1cbiAgZnVuY3Rpb24gSmUoZSkge1xuICAgIHZhciB0O1xuICAgIGlmIChKLS0sICh0ID0gYy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKSA9PT0gbnVsbCB8fCB0ID09PSB2b2lkIDAgfHwgdC5jYWxsKGMsIEopLCBKID09IDAgJiYgY3QpIHtcbiAgICAgIHZhciByID0gY3Q7XG4gICAgICBjdCA9IG51bGwsIHIoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gRnQoZSkge1xuICAgIHZhciB0O1xuICAgICh0ID0gYy5vbkFib3J0KSA9PT0gbnVsbCB8fCB0ID09PSB2b2lkIDAgfHwgdC5jYWxsKGMsIGUpLCBlID0gXCJBYm9ydGVkKFwiICsgZSArIFwiKVwiLCBrKGUpLCBKdCA9ICEwLCBlICs9IFwiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLlwiO1xuICAgIHZhciByID0gbmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcihlKTtcbiAgICB0aHJvdyAkKHIpLCByO1xuICB9XG4gIHZhciB5dDtcbiAgZnVuY3Rpb24gS2UoKSB7XG4gICAgcmV0dXJuIHEoXCJ6eGluZ19yZWFkZXIud2FzbVwiKTtcbiAgfVxuICBmdW5jdGlvbiB0cihlKSB7XG4gICAgaWYgKGUgPT0geXQgJiYgWilcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShaKTtcbiAgICBpZiAoWSlcbiAgICAgIHJldHVybiBZKGUpO1xuICAgIHRocm93IFwiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIjtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBlcihlKSB7XG4gICAgaWYgKCFaKVxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHQgPSBhd2FpdCBydChlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHQpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgcmV0dXJuIHRyKGUpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJyKGUsIHQpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHIgPSBhd2FpdCBlcihlKSwgbiA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHIsIHQpO1xuICAgICAgcmV0dXJuIG47XG4gICAgfSBjYXRjaCAoYSkge1xuICAgICAgayhgZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJHthfWApLCBGdChhKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbnIoZSwgdCwgcikge1xuICAgIGlmICghZSAmJiB0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG4gPSBmZXRjaCh0LCB7XG4gICAgICAgICAgY3JlZGVudGlhbHM6IFwic2FtZS1vcmlnaW5cIlxuICAgICAgICB9KSwgYSA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKG4sIHIpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgICAgayhgd2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6ICR7aX1gKSwgayhcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpO1xuICAgICAgfVxuICAgIHJldHVybiBycih0LCByKTtcbiAgfVxuICBmdW5jdGlvbiBhcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYTogSG5cbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG9yKCkge1xuICAgIGZ1bmN0aW9uIGUoaSwgdSkge1xuICAgICAgcmV0dXJuIEUgPSBpLmV4cG9ydHMsIG50ID0gRS54YSwgZWUoKSwgcGUgPSBFLkJhLCBKZSgpLCBFO1xuICAgIH1cbiAgICBRZSgpO1xuICAgIGZ1bmN0aW9uIHQoaSkge1xuICAgICAgcmV0dXJuIGUoaS5pbnN0YW5jZSk7XG4gICAgfVxuICAgIHZhciByID0gYXIoKTtcbiAgICBpZiAoYy5pbnN0YW50aWF0ZVdhc20pXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKGksIHUpID0+IHtcbiAgICAgICAgYy5pbnN0YW50aWF0ZVdhc20ociwgKHMsIGwpID0+IHtcbiAgICAgICAgICBpKGUocykpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIHl0ICE9IG51bGwgfHwgKHl0ID0gS2UoKSk7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBuID0gYXdhaXQgbnIoWiwgeXQsIHIpLCBhID0gdChuKTtcbiAgICAgIHJldHVybiBhO1xuICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgIHJldHVybiAkKGkpLCBQcm9taXNlLnJlamVjdChpKTtcbiAgICB9XG4gIH1cbiAgdmFyIHJlID0gKGUpID0+IHtcbiAgICBmb3IgKDsgZS5sZW5ndGggPiAwOyApXG4gICAgICBlLnNoaWZ0KCkoYyk7XG4gIH0sIG5lID0gW10sIGlyID0gKGUpID0+IG5lLnB1c2goZSksIGFlID0gW10sIHNyID0gKGUpID0+IGFlLnB1c2goZSksIHkgPSAoZSkgPT4gWG4oZSksIG0gPSAoKSA9PiBxbigpLCBtdCA9IFtdLCBndCA9IDAsIHVyID0gKGUpID0+IHtcbiAgICB2YXIgdCA9IG5ldyBqdChlKTtcbiAgICByZXR1cm4gdC5nZXRfY2F1Z2h0KCkgfHwgKHQuc2V0X2NhdWdodCghMCksIGd0LS0pLCB0LnNldF9yZXRocm93bighMSksIG10LnB1c2godCksIFpuKGUpLCB6bihlKTtcbiAgfSwgSCA9IDAsIGNyID0gKCkgPT4ge1xuICAgIHYoMCwgMCk7XG4gICAgdmFyIGUgPSBtdC5wb3AoKTtcbiAgICBZbihlLmV4Y1B0ciksIEggPSAwO1xuICB9O1xuICBjbGFzcyBqdCB7XG4gICAgY29uc3RydWN0b3IodCkge1xuICAgICAgdGhpcy5leGNQdHIgPSB0LCB0aGlzLnB0ciA9IHQgLSAyNDtcbiAgICB9XG4gICAgc2V0X3R5cGUodCkge1xuICAgICAgUFt0aGlzLnB0ciArIDQgPj4gMl0gPSB0O1xuICAgIH1cbiAgICBnZXRfdHlwZSgpIHtcbiAgICAgIHJldHVybiBQW3RoaXMucHRyICsgNCA+PiAyXTtcbiAgICB9XG4gICAgc2V0X2Rlc3RydWN0b3IodCkge1xuICAgICAgUFt0aGlzLnB0ciArIDggPj4gMl0gPSB0O1xuICAgIH1cbiAgICBnZXRfZGVzdHJ1Y3RvcigpIHtcbiAgICAgIHJldHVybiBQW3RoaXMucHRyICsgOCA+PiAyXTtcbiAgICB9XG4gICAgc2V0X2NhdWdodCh0KSB7XG4gICAgICB0ID0gdCA/IDEgOiAwLCBRW3RoaXMucHRyICsgMTJdID0gdDtcbiAgICB9XG4gICAgZ2V0X2NhdWdodCgpIHtcbiAgICAgIHJldHVybiBRW3RoaXMucHRyICsgMTJdICE9IDA7XG4gICAgfVxuICAgIHNldF9yZXRocm93bih0KSB7XG4gICAgICB0ID0gdCA/IDEgOiAwLCBRW3RoaXMucHRyICsgMTNdID0gdDtcbiAgICB9XG4gICAgZ2V0X3JldGhyb3duKCkge1xuICAgICAgcmV0dXJuIFFbdGhpcy5wdHIgKyAxM10gIT0gMDtcbiAgICB9XG4gICAgaW5pdCh0LCByKSB7XG4gICAgICB0aGlzLnNldF9hZGp1c3RlZF9wdHIoMCksIHRoaXMuc2V0X3R5cGUodCksIHRoaXMuc2V0X2Rlc3RydWN0b3Iocik7XG4gICAgfVxuICAgIHNldF9hZGp1c3RlZF9wdHIodCkge1xuICAgICAgUFt0aGlzLnB0ciArIDE2ID4+IDJdID0gdDtcbiAgICB9XG4gICAgZ2V0X2FkanVzdGVkX3B0cigpIHtcbiAgICAgIHJldHVybiBQW3RoaXMucHRyICsgMTYgPj4gMl07XG4gICAgfVxuICB9XG4gIHZhciB3dCA9IChlKSA9PiBHbihlKSwgUnQgPSAoZSkgPT4ge1xuICAgIHZhciB0ID0gSDtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm4gd3QoMCksIDA7XG4gICAgdmFyIHIgPSBuZXcganQodCk7XG4gICAgci5zZXRfYWRqdXN0ZWRfcHRyKHQpO1xuICAgIHZhciBuID0gci5nZXRfdHlwZSgpO1xuICAgIGlmICghbilcbiAgICAgIHJldHVybiB3dCgwKSwgdDtcbiAgICBmb3IgKHZhciBhIG9mIGUpIHtcbiAgICAgIGlmIChhID09PSAwIHx8IGEgPT09IG4pXG4gICAgICAgIGJyZWFrO1xuICAgICAgdmFyIGkgPSByLnB0ciArIDE2O1xuICAgICAgaWYgKFFuKGEsIG4sIGkpKVxuICAgICAgICByZXR1cm4gd3QoYSksIHQ7XG4gICAgfVxuICAgIHJldHVybiB3dChuKSwgdDtcbiAgfSwgbHIgPSAoKSA9PiBSdChbXSksIGZyID0gKGUpID0+IFJ0KFtlXSksIGRyID0gKGUsIHQpID0+IFJ0KFtlLCB0XSksIGhyID0gKCkgPT4ge1xuICAgIHZhciBlID0gbXQucG9wKCk7XG4gICAgZSB8fCBGdChcIm5vIGV4Y2VwdGlvbiB0byB0aHJvd1wiKTtcbiAgICB2YXIgdCA9IGUuZXhjUHRyO1xuICAgIHRocm93IGUuZ2V0X3JldGhyb3duKCkgfHwgKG10LnB1c2goZSksIGUuc2V0X3JldGhyb3duKCEwKSwgZS5zZXRfY2F1Z2h0KCExKSwgZ3QrKyksIEggPSB0LCBIO1xuICB9LCBwciA9IChlLCB0LCByKSA9PiB7XG4gICAgdmFyIG4gPSBuZXcganQoZSk7XG4gICAgdGhyb3cgbi5pbml0KHQsIHIpLCBIID0gZSwgZ3QrKywgSDtcbiAgfSwgdnIgPSAoKSA9PiBndCwgeXIgPSAoZSkgPT4ge1xuICAgIHRocm93IEggfHwgKEggPSBlKSwgSDtcbiAgfSwgbXIgPSAoKSA9PiBGdChcIlwiKSwgJHQgPSB7fSwgTHQgPSAoZSkgPT4ge1xuICAgIGZvciAoOyBlLmxlbmd0aDsgKSB7XG4gICAgICB2YXIgdCA9IGUucG9wKCksIHIgPSBlLnBvcCgpO1xuICAgICAgcih0KTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGx0KGUpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoUFtlID4+IDJdKTtcbiAgfVxuICB2YXIgb3QgPSB7fSwgSyA9IHt9LCBidCA9IHt9LCBnciA9IGMuSW50ZXJuYWxFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGUpIHtcbiAgICAgIHN1cGVyKGUpLCB0aGlzLm5hbWUgPSBcIkludGVybmFsRXJyb3JcIjtcbiAgICB9XG4gIH0sIEN0ID0gKGUpID0+IHtcbiAgICB0aHJvdyBuZXcgZ3IoZSk7XG4gIH0sIHR0ID0gKGUsIHQsIHIpID0+IHtcbiAgICBlLmZvckVhY2goKHMpID0+IGJ0W3NdID0gdCk7XG4gICAgZnVuY3Rpb24gbihzKSB7XG4gICAgICB2YXIgbCA9IHIocyk7XG4gICAgICBsLmxlbmd0aCAhPT0gZS5sZW5ndGggJiYgQ3QoXCJNaXNtYXRjaGVkIHR5cGUgY29udmVydGVyIGNvdW50XCIpO1xuICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBlLmxlbmd0aDsgKytkKVxuICAgICAgICBWKGVbZF0sIGxbZF0pO1xuICAgIH1cbiAgICB2YXIgYSA9IG5ldyBBcnJheSh0Lmxlbmd0aCksIGkgPSBbXSwgdSA9IDA7XG4gICAgdC5mb3JFYWNoKChzLCBsKSA9PiB7XG4gICAgICBLLmhhc093blByb3BlcnR5KHMpID8gYVtsXSA9IEtbc10gOiAoaS5wdXNoKHMpLCBvdC5oYXNPd25Qcm9wZXJ0eShzKSB8fCAob3Rbc10gPSBbXSksIG90W3NdLnB1c2goKCkgPT4ge1xuICAgICAgICBhW2xdID0gS1tzXSwgKyt1LCB1ID09PSBpLmxlbmd0aCAmJiBuKGEpO1xuICAgICAgfSkpO1xuICAgIH0pLCBpLmxlbmd0aCA9PT0gMCAmJiBuKGEpO1xuICB9LCB3ciA9IChlKSA9PiB7XG4gICAgdmFyIHQgPSAkdFtlXTtcbiAgICBkZWxldGUgJHRbZV07XG4gICAgdmFyIHIgPSB0LnJhd0NvbnN0cnVjdG9yLCBuID0gdC5yYXdEZXN0cnVjdG9yLCBhID0gdC5maWVsZHMsIGkgPSBhLm1hcCgodSkgPT4gdS5nZXR0ZXJSZXR1cm5UeXBlKS5jb25jYXQoYS5tYXAoKHUpID0+IHUuc2V0dGVyQXJndW1lbnRUeXBlKSk7XG4gICAgdHQoW2VdLCBpLCAodSkgPT4ge1xuICAgICAgdmFyIHMgPSB7fTtcbiAgICAgIHJldHVybiBhLmZvckVhY2goKGwsIGQpID0+IHtcbiAgICAgICAgdmFyIGggPSBsLmZpZWxkTmFtZSwgcCA9IHVbZF0sIHcgPSB1W2RdLm9wdGlvbmFsLCBiID0gbC5nZXR0ZXIsIF8gPSBsLmdldHRlckNvbnRleHQsIFMgPSB1W2QgKyBhLmxlbmd0aF0sIEEgPSBsLnNldHRlciwgSSA9IGwuc2V0dGVyQ29udGV4dDtcbiAgICAgICAgc1toXSA9IHtcbiAgICAgICAgICByZWFkOiAoWCkgPT4gcC5mcm9tV2lyZVR5cGUoYihfLCBYKSksXG4gICAgICAgICAgd3JpdGU6IChYLCBMKSA9PiB7XG4gICAgICAgICAgICB2YXIgVyA9IFtdO1xuICAgICAgICAgICAgQShJLCBYLCBTLnRvV2lyZVR5cGUoVywgTCkpLCBMdChXKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9wdGlvbmFsOiB3XG4gICAgICAgIH07XG4gICAgICB9KSwgW3tcbiAgICAgICAgbmFtZTogdC5uYW1lLFxuICAgICAgICBmcm9tV2lyZVR5cGU6IChsKSA9PiB7XG4gICAgICAgICAgdmFyIGQgPSB7fTtcbiAgICAgICAgICBmb3IgKHZhciBoIGluIHMpXG4gICAgICAgICAgICBkW2hdID0gc1toXS5yZWFkKGwpO1xuICAgICAgICAgIHJldHVybiBuKGwpLCBkO1xuICAgICAgICB9LFxuICAgICAgICB0b1dpcmVUeXBlOiAobCwgZCkgPT4ge1xuICAgICAgICAgIGZvciAodmFyIGggaW4gcylcbiAgICAgICAgICAgIGlmICghKGggaW4gZCkgJiYgIXNbaF0ub3B0aW9uYWwpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE1pc3NpbmcgZmllbGQ6IFwiJHtofVwiYCk7XG4gICAgICAgICAgdmFyIHAgPSByKCk7XG4gICAgICAgICAgZm9yIChoIGluIHMpXG4gICAgICAgICAgICBzW2hdLndyaXRlKHAsIGRbaF0pO1xuICAgICAgICAgIHJldHVybiBsICE9PSBudWxsICYmIGwucHVzaChuLCBwKSwgcDtcbiAgICAgICAgfSxcbiAgICAgICAgYXJnUGFja0FkdmFuY2U6IE4sXG4gICAgICAgIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiBsdCxcbiAgICAgICAgZGVzdHJ1Y3RvckZ1bmN0aW9uOiBuXG4gICAgICB9XTtcbiAgICB9KTtcbiAgfSwgJHIgPSAoZSwgdCwgciwgbiwgYSkgPT4ge1xuICB9LCBiciA9ICgpID0+IHtcbiAgICBmb3IgKHZhciBlID0gbmV3IEFycmF5KDI1NiksIHQgPSAwOyB0IDwgMjU2OyArK3QpXG4gICAgICBlW3RdID0gU3RyaW5nLmZyb21DaGFyQ29kZSh0KTtcbiAgICBvZSA9IGU7XG4gIH0sIG9lLCBqID0gKGUpID0+IHtcbiAgICBmb3IgKHZhciB0ID0gXCJcIiwgciA9IGU7IEJbcl07IClcbiAgICAgIHQgKz0gb2VbQltyKytdXTtcbiAgICByZXR1cm4gdDtcbiAgfSwgZnQgPSBjLkJpbmRpbmdFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGUpIHtcbiAgICAgIHN1cGVyKGUpLCB0aGlzLm5hbWUgPSBcIkJpbmRpbmdFcnJvclwiO1xuICAgIH1cbiAgfSwgQyA9IChlKSA9PiB7XG4gICAgdGhyb3cgbmV3IGZ0KGUpO1xuICB9O1xuICBmdW5jdGlvbiBDcihlLCB0KSB7XG4gICAgbGV0IHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBuID0gdC5uYW1lO1xuICAgIGlmIChlIHx8IEMoYHR5cGUgXCIke259XCIgbXVzdCBoYXZlIGEgcG9zaXRpdmUgaW50ZWdlciB0eXBlaWQgcG9pbnRlcmApLCBLLmhhc093blByb3BlcnR5KGUpKSB7XG4gICAgICBpZiAoci5pZ25vcmVEdXBsaWNhdGVSZWdpc3RyYXRpb25zKVxuICAgICAgICByZXR1cm47XG4gICAgICBDKGBDYW5ub3QgcmVnaXN0ZXIgdHlwZSAnJHtufScgdHdpY2VgKTtcbiAgICB9XG4gICAgaWYgKEtbZV0gPSB0LCBkZWxldGUgYnRbZV0sIG90Lmhhc093blByb3BlcnR5KGUpKSB7XG4gICAgICB2YXIgYSA9IG90W2VdO1xuICAgICAgZGVsZXRlIG90W2VdLCBhLmZvckVhY2goKGkpID0+IGkoKSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIFYoZSwgdCkge1xuICAgIGxldCByID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gQ3IoZSwgdCwgcik7XG4gIH1cbiAgdmFyIE4gPSA4LCBUciA9IChlLCB0LCByLCBuKSA9PiB7XG4gICAgdCA9IGoodCksIFYoZSwge1xuICAgICAgbmFtZTogdCxcbiAgICAgIGZyb21XaXJlVHlwZTogZnVuY3Rpb24oYSkge1xuICAgICAgICByZXR1cm4gISFhO1xuICAgICAgfSxcbiAgICAgIHRvV2lyZVR5cGU6IGZ1bmN0aW9uKGEsIGkpIHtcbiAgICAgICAgcmV0dXJuIGkgPyByIDogbjtcbiAgICAgIH0sXG4gICAgICBhcmdQYWNrQWR2YW5jZTogTixcbiAgICAgIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiBmdW5jdGlvbihhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21XaXJlVHlwZShCW2FdKTtcbiAgICAgIH0sXG4gICAgICBkZXN0cnVjdG9yRnVuY3Rpb246IG51bGxcbiAgICB9KTtcbiAgfSwgUHIgPSAoZSkgPT4gKHtcbiAgICBjb3VudDogZS5jb3VudCxcbiAgICBkZWxldGVTY2hlZHVsZWQ6IGUuZGVsZXRlU2NoZWR1bGVkLFxuICAgIHByZXNlcnZlUG9pbnRlck9uRGVsZXRlOiBlLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlLFxuICAgIHB0cjogZS5wdHIsXG4gICAgcHRyVHlwZTogZS5wdHJUeXBlLFxuICAgIHNtYXJ0UHRyOiBlLnNtYXJ0UHRyLFxuICAgIHNtYXJ0UHRyVHlwZTogZS5zbWFydFB0clR5cGVcbiAgfSksIEJ0ID0gKGUpID0+IHtcbiAgICBmdW5jdGlvbiB0KHIpIHtcbiAgICAgIHJldHVybiByLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzLm5hbWU7XG4gICAgfVxuICAgIEModChlKSArIFwiIGluc3RhbmNlIGFscmVhZHkgZGVsZXRlZFwiKTtcbiAgfSwgV3QgPSAhMSwgaWUgPSAoZSkgPT4ge1xuICB9LCBFciA9IChlKSA9PiB7XG4gICAgZS5zbWFydFB0ciA/IGUuc21hcnRQdHJUeXBlLnJhd0Rlc3RydWN0b3IoZS5zbWFydFB0cikgOiBlLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzLnJhd0Rlc3RydWN0b3IoZS5wdHIpO1xuICB9LCBzZSA9IChlKSA9PiB7XG4gICAgZS5jb3VudC52YWx1ZSAtPSAxO1xuICAgIHZhciB0ID0gZS5jb3VudC52YWx1ZSA9PT0gMDtcbiAgICB0ICYmIEVyKGUpO1xuICB9LCBkdCA9IChlKSA9PiB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPiBcInVcIiA/IChkdCA9ICh0KSA9PiB0LCBlKSA6IChXdCA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgodCkgPT4ge1xuICAgIHNlKHQuJCQpO1xuICB9KSwgZHQgPSAodCkgPT4ge1xuICAgIHZhciByID0gdC4kJCwgbiA9ICEhci5zbWFydFB0cjtcbiAgICBpZiAobikge1xuICAgICAgdmFyIGEgPSB7XG4gICAgICAgICQkOiByXG4gICAgICB9O1xuICAgICAgV3QucmVnaXN0ZXIodCwgYSwgdCk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9LCBpZSA9ICh0KSA9PiBXdC51bnJlZ2lzdGVyKHQpLCBkdChlKSksIF9yID0gKCkgPT4ge1xuICAgIGxldCBlID0gVHQucHJvdG90eXBlO1xuICAgIE9iamVjdC5hc3NpZ24oZSwge1xuICAgICAgaXNBbGlhc09mKHIpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFR0KSB8fCAhKHIgaW5zdGFuY2VvZiBUdCkpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB2YXIgbiA9IHRoaXMuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3MsIGEgPSB0aGlzLiQkLnB0cjtcbiAgICAgICAgci4kJCA9IHIuJCQ7XG4gICAgICAgIGZvciAodmFyIGkgPSByLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzLCB1ID0gci4kJC5wdHI7IG4uYmFzZUNsYXNzOyApXG4gICAgICAgICAgYSA9IG4udXBjYXN0KGEpLCBuID0gbi5iYXNlQ2xhc3M7XG4gICAgICAgIGZvciAoOyBpLmJhc2VDbGFzczsgKVxuICAgICAgICAgIHUgPSBpLnVwY2FzdCh1KSwgaSA9IGkuYmFzZUNsYXNzO1xuICAgICAgICByZXR1cm4gbiA9PT0gaSAmJiBhID09PSB1O1xuICAgICAgfSxcbiAgICAgIGNsb25lKCkge1xuICAgICAgICBpZiAodGhpcy4kJC5wdHIgfHwgQnQodGhpcyksIHRoaXMuJCQucHJlc2VydmVQb2ludGVyT25EZWxldGUpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuJCQuY291bnQudmFsdWUgKz0gMSwgdGhpcztcbiAgICAgICAgdmFyIHIgPSBkdChPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge1xuICAgICAgICAgICQkOiB7XG4gICAgICAgICAgICB2YWx1ZTogUHIodGhpcy4kJClcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHIuJCQuY291bnQudmFsdWUgKz0gMSwgci4kJC5kZWxldGVTY2hlZHVsZWQgPSAhMSwgcjtcbiAgICAgIH0sXG4gICAgICBkZWxldGUoKSB7XG4gICAgICAgIHRoaXMuJCQucHRyIHx8IEJ0KHRoaXMpLCB0aGlzLiQkLmRlbGV0ZVNjaGVkdWxlZCAmJiAhdGhpcy4kJC5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSAmJiBDKFwiT2JqZWN0IGFscmVhZHkgc2NoZWR1bGVkIGZvciBkZWxldGlvblwiKSwgaWUodGhpcyksIHNlKHRoaXMuJCQpLCB0aGlzLiQkLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlIHx8ICh0aGlzLiQkLnNtYXJ0UHRyID0gdm9pZCAwLCB0aGlzLiQkLnB0ciA9IHZvaWQgMCk7XG4gICAgICB9LFxuICAgICAgaXNEZWxldGVkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuJCQucHRyO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZUxhdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kJC5wdHIgfHwgQnQodGhpcyksIHRoaXMuJCQuZGVsZXRlU2NoZWR1bGVkICYmICF0aGlzLiQkLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlICYmIEMoXCJPYmplY3QgYWxyZWFkeSBzY2hlZHVsZWQgZm9yIGRlbGV0aW9uXCIpLCB0aGlzLiQkLmRlbGV0ZVNjaGVkdWxlZCA9ICEwLCB0aGlzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHQgPSBTeW1ib2wuZGlzcG9zZTtcbiAgICB0ICYmIChlW3RdID0gZS5kZWxldGUpO1xuICB9O1xuICBmdW5jdGlvbiBUdCgpIHtcbiAgfVxuICB2YXIgVXQgPSAoZSwgdCkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwibmFtZVwiLCB7XG4gICAgdmFsdWU6IGVcbiAgfSksIHVlID0ge30sIGNlID0gKGUsIHQsIHIpID0+IHtcbiAgICBpZiAoZVt0XS5vdmVybG9hZFRhYmxlID09PSB2b2lkIDApIHtcbiAgICAgIHZhciBuID0gZVt0XTtcbiAgICAgIGVbdF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50cy5sZW5ndGgsIGkgPSBuZXcgQXJyYXkoYSksIHUgPSAwOyB1IDwgYTsgdSsrKVxuICAgICAgICAgIGlbdV0gPSBhcmd1bWVudHNbdV07XG4gICAgICAgIHJldHVybiBlW3RdLm92ZXJsb2FkVGFibGUuaGFzT3duUHJvcGVydHkoaS5sZW5ndGgpIHx8IEMoYEZ1bmN0aW9uICcke3J9JyBjYWxsZWQgd2l0aCBhbiBpbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgKCR7aS5sZW5ndGh9KSAtIGV4cGVjdHMgb25lIG9mICgke2VbdF0ub3ZlcmxvYWRUYWJsZX0pIWApLCBlW3RdLm92ZXJsb2FkVGFibGVbaS5sZW5ndGhdLmFwcGx5KHRoaXMsIGkpO1xuICAgICAgfSwgZVt0XS5vdmVybG9hZFRhYmxlID0gW10sIGVbdF0ub3ZlcmxvYWRUYWJsZVtuLmFyZ0NvdW50XSA9IG47XG4gICAgfVxuICB9LCBsZSA9IChlLCB0LCByKSA9PiB7XG4gICAgYy5oYXNPd25Qcm9wZXJ0eShlKSA/ICgociA9PT0gdm9pZCAwIHx8IGNbZV0ub3ZlcmxvYWRUYWJsZSAhPT0gdm9pZCAwICYmIGNbZV0ub3ZlcmxvYWRUYWJsZVtyXSAhPT0gdm9pZCAwKSAmJiBDKGBDYW5ub3QgcmVnaXN0ZXIgcHVibGljIG5hbWUgJyR7ZX0nIHR3aWNlYCksIGNlKGMsIGUsIGUpLCBjW2VdLm92ZXJsb2FkVGFibGUuaGFzT3duUHJvcGVydHkocikgJiYgQyhgQ2Fubm90IHJlZ2lzdGVyIG11bHRpcGxlIG92ZXJsb2FkcyBvZiBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyAoJHtyfSkhYCksIGNbZV0ub3ZlcmxvYWRUYWJsZVtyXSA9IHQpIDogKGNbZV0gPSB0LCBjW2VdLmFyZ0NvdW50ID0gcik7XG4gIH0sIE9yID0gNDgsIHhyID0gNTcsIEFyID0gKGUpID0+IHtcbiAgICBlID0gZS5yZXBsYWNlKC9bXmEtekEtWjAtOV9dL2csIFwiJFwiKTtcbiAgICB2YXIgdCA9IGUuY2hhckNvZGVBdCgwKTtcbiAgICByZXR1cm4gdCA+PSBPciAmJiB0IDw9IHhyID8gYF8ke2V9YCA6IGU7XG4gIH07XG4gIGZ1bmN0aW9uIFNyKGUsIHQsIHIsIG4sIGEsIGksIHUsIHMpIHtcbiAgICB0aGlzLm5hbWUgPSBlLCB0aGlzLmNvbnN0cnVjdG9yID0gdCwgdGhpcy5pbnN0YW5jZVByb3RvdHlwZSA9IHIsIHRoaXMucmF3RGVzdHJ1Y3RvciA9IG4sIHRoaXMuYmFzZUNsYXNzID0gYSwgdGhpcy5nZXRBY3R1YWxUeXBlID0gaSwgdGhpcy51cGNhc3QgPSB1LCB0aGlzLmRvd25jYXN0ID0gcywgdGhpcy5wdXJlVmlydHVhbEZ1bmN0aW9ucyA9IFtdO1xuICB9XG4gIHZhciBWdCA9IChlLCB0LCByKSA9PiB7XG4gICAgZm9yICg7IHQgIT09IHI7IClcbiAgICAgIHQudXBjYXN0IHx8IEMoYEV4cGVjdGVkIG51bGwgb3IgaW5zdGFuY2Ugb2YgJHtyLm5hbWV9LCBnb3QgYW4gaW5zdGFuY2Ugb2YgJHt0Lm5hbWV9YCksIGUgPSB0LnVwY2FzdChlKSwgdCA9IHQuYmFzZUNsYXNzO1xuICAgIHJldHVybiBlO1xuICB9O1xuICBmdW5jdGlvbiBJcihlLCB0KSB7XG4gICAgaWYgKHQgPT09IG51bGwpXG4gICAgICByZXR1cm4gdGhpcy5pc1JlZmVyZW5jZSAmJiBDKGBudWxsIGlzIG5vdCBhIHZhbGlkICR7dGhpcy5uYW1lfWApLCAwO1xuICAgIHQuJCQgfHwgQyhgQ2Fubm90IHBhc3MgXCIke2VtYmluZFJlcHIodCl9XCIgYXMgYSAke3RoaXMubmFtZX1gKSwgdC4kJC5wdHIgfHwgQyhgQ2Fubm90IHBhc3MgZGVsZXRlZCBvYmplY3QgYXMgYSBwb2ludGVyIG9mIHR5cGUgJHt0aGlzLm5hbWV9YCk7XG4gICAgdmFyIHIgPSB0LiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzLCBuID0gVnQodC4kJC5wdHIsIHIsIHRoaXMucmVnaXN0ZXJlZENsYXNzKTtcbiAgICByZXR1cm4gbjtcbiAgfVxuICBmdW5jdGlvbiBEcihlLCB0KSB7XG4gICAgdmFyIHI7XG4gICAgaWYgKHQgPT09IG51bGwpXG4gICAgICByZXR1cm4gdGhpcy5pc1JlZmVyZW5jZSAmJiBDKGBudWxsIGlzIG5vdCBhIHZhbGlkICR7dGhpcy5uYW1lfWApLCB0aGlzLmlzU21hcnRQb2ludGVyID8gKHIgPSB0aGlzLnJhd0NvbnN0cnVjdG9yKCksIGUgIT09IG51bGwgJiYgZS5wdXNoKHRoaXMucmF3RGVzdHJ1Y3RvciwgciksIHIpIDogMDtcbiAgICAoIXQgfHwgIXQuJCQpICYmIEMoYENhbm5vdCBwYXNzIFwiJHtlbWJpbmRSZXByKHQpfVwiIGFzIGEgJHt0aGlzLm5hbWV9YCksIHQuJCQucHRyIHx8IEMoYENhbm5vdCBwYXNzIGRlbGV0ZWQgb2JqZWN0IGFzIGEgcG9pbnRlciBvZiB0eXBlICR7dGhpcy5uYW1lfWApLCAhdGhpcy5pc0NvbnN0ICYmIHQuJCQucHRyVHlwZS5pc0NvbnN0ICYmIEMoYENhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgJHt0LiQkLnNtYXJ0UHRyVHlwZSA/IHQuJCQuc21hcnRQdHJUeXBlLm5hbWUgOiB0LiQkLnB0clR5cGUubmFtZX0gdG8gcGFyYW1ldGVyIHR5cGUgJHt0aGlzLm5hbWV9YCk7XG4gICAgdmFyIG4gPSB0LiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzO1xuICAgIGlmIChyID0gVnQodC4kJC5wdHIsIG4sIHRoaXMucmVnaXN0ZXJlZENsYXNzKSwgdGhpcy5pc1NtYXJ0UG9pbnRlcilcbiAgICAgIHN3aXRjaCAodC4kJC5zbWFydFB0ciA9PT0gdm9pZCAwICYmIEMoXCJQYXNzaW5nIHJhdyBwb2ludGVyIHRvIHNtYXJ0IHBvaW50ZXIgaXMgaWxsZWdhbFwiKSwgdGhpcy5zaGFyaW5nUG9saWN5KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICB0LiQkLnNtYXJ0UHRyVHlwZSA9PT0gdGhpcyA/IHIgPSB0LiQkLnNtYXJ0UHRyIDogQyhgQ2Fubm90IGNvbnZlcnQgYXJndW1lbnQgb2YgdHlwZSAke3QuJCQuc21hcnRQdHJUeXBlID8gdC4kJC5zbWFydFB0clR5cGUubmFtZSA6IHQuJCQucHRyVHlwZS5uYW1lfSB0byBwYXJhbWV0ZXIgdHlwZSAke3RoaXMubmFtZX1gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHIgPSB0LiQkLnNtYXJ0UHRyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaWYgKHQuJCQuc21hcnRQdHJUeXBlID09PSB0aGlzKVxuICAgICAgICAgICAgciA9IHQuJCQuc21hcnRQdHI7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYSA9IHQuY2xvbmUoKTtcbiAgICAgICAgICAgIHIgPSB0aGlzLnJhd1NoYXJlKHIsIEcudG9IYW5kbGUoKCkgPT4gYS5kZWxldGUoKSkpLCBlICE9PSBudWxsICYmIGUucHVzaCh0aGlzLnJhd0Rlc3RydWN0b3IsIHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBDKFwiVW5zdXBwb3J0aW5nIHNoYXJpbmcgcG9saWN5XCIpO1xuICAgICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIGZ1bmN0aW9uIE1yKGUsIHQpIHtcbiAgICBpZiAodCA9PT0gbnVsbClcbiAgICAgIHJldHVybiB0aGlzLmlzUmVmZXJlbmNlICYmIEMoYG51bGwgaXMgbm90IGEgdmFsaWQgJHt0aGlzLm5hbWV9YCksIDA7XG4gICAgdC4kJCB8fCBDKGBDYW5ub3QgcGFzcyBcIiR7ZW1iaW5kUmVwcih0KX1cIiBhcyBhICR7dGhpcy5uYW1lfWApLCB0LiQkLnB0ciB8fCBDKGBDYW5ub3QgcGFzcyBkZWxldGVkIG9iamVjdCBhcyBhIHBvaW50ZXIgb2YgdHlwZSAke3RoaXMubmFtZX1gKSwgdC4kJC5wdHJUeXBlLmlzQ29uc3QgJiYgQyhgQ2Fubm90IGNvbnZlcnQgYXJndW1lbnQgb2YgdHlwZSAke3QuJCQucHRyVHlwZS5uYW1lfSB0byBwYXJhbWV0ZXIgdHlwZSAke3RoaXMubmFtZX1gKTtcbiAgICB2YXIgciA9IHQuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3MsIG4gPSBWdCh0LiQkLnB0ciwgciwgdGhpcy5yZWdpc3RlcmVkQ2xhc3MpO1xuICAgIHJldHVybiBuO1xuICB9XG4gIHZhciBmZSA9IChlLCB0LCByKSA9PiB7XG4gICAgaWYgKHQgPT09IHIpXG4gICAgICByZXR1cm4gZTtcbiAgICBpZiAoci5iYXNlQ2xhc3MgPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciBuID0gZmUoZSwgdCwgci5iYXNlQ2xhc3MpO1xuICAgIHJldHVybiBuID09PSBudWxsID8gbnVsbCA6IHIuZG93bmNhc3Qobik7XG4gIH0sIEZyID0ge30sIGpyID0gKGUsIHQpID0+IHtcbiAgICBmb3IgKHQgPT09IHZvaWQgMCAmJiBDKFwicHRyIHNob3VsZCBub3QgYmUgdW5kZWZpbmVkXCIpOyBlLmJhc2VDbGFzczsgKVxuICAgICAgdCA9IGUudXBjYXN0KHQpLCBlID0gZS5iYXNlQ2xhc3M7XG4gICAgcmV0dXJuIHQ7XG4gIH0sIFJyID0gKGUsIHQpID0+ICh0ID0ganIoZSwgdCksIEZyW3RdKSwgUHQgPSAoZSwgdCkgPT4ge1xuICAgICghdC5wdHJUeXBlIHx8ICF0LnB0cikgJiYgQ3QoXCJtYWtlQ2xhc3NIYW5kbGUgcmVxdWlyZXMgcHRyIGFuZCBwdHJUeXBlXCIpO1xuICAgIHZhciByID0gISF0LnNtYXJ0UHRyVHlwZSwgbiA9ICEhdC5zbWFydFB0cjtcbiAgICByZXR1cm4gciAhPT0gbiAmJiBDdChcIkJvdGggc21hcnRQdHJUeXBlIGFuZCBzbWFydFB0ciBtdXN0IGJlIHNwZWNpZmllZFwiKSwgdC5jb3VudCA9IHtcbiAgICAgIHZhbHVlOiAxXG4gICAgfSwgZHQoT2JqZWN0LmNyZWF0ZShlLCB7XG4gICAgICAkJDoge1xuICAgICAgICB2YWx1ZTogdCxcbiAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICB9XG4gICAgfSkpO1xuICB9O1xuICBmdW5jdGlvbiBMcihlKSB7XG4gICAgdmFyIHQgPSB0aGlzLmdldFBvaW50ZWUoZSk7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuIHRoaXMuZGVzdHJ1Y3RvcihlKSwgbnVsbDtcbiAgICB2YXIgciA9IFJyKHRoaXMucmVnaXN0ZXJlZENsYXNzLCB0KTtcbiAgICBpZiAociAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoci4kJC5jb3VudC52YWx1ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHIuJCQucHRyID0gdCwgci4kJC5zbWFydFB0ciA9IGUsIHIuY2xvbmUoKTtcbiAgICAgIHZhciBuID0gci5jbG9uZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVzdHJ1Y3RvcihlKSwgbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzU21hcnRQb2ludGVyID8gUHQodGhpcy5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGUsIHtcbiAgICAgICAgcHRyVHlwZTogdGhpcy5wb2ludGVlVHlwZSxcbiAgICAgICAgcHRyOiB0LFxuICAgICAgICBzbWFydFB0clR5cGU6IHRoaXMsXG4gICAgICAgIHNtYXJ0UHRyOiBlXG4gICAgICB9KSA6IFB0KHRoaXMucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlLCB7XG4gICAgICAgIHB0clR5cGU6IHRoaXMsXG4gICAgICAgIHB0cjogZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5yZWdpc3RlcmVkQ2xhc3MuZ2V0QWN0dWFsVHlwZSh0KSwgdSA9IHVlW2ldO1xuICAgIGlmICghdSlcbiAgICAgIHJldHVybiBhLmNhbGwodGhpcyk7XG4gICAgdmFyIHM7XG4gICAgdGhpcy5pc0NvbnN0ID8gcyA9IHUuY29uc3RQb2ludGVyVHlwZSA6IHMgPSB1LnBvaW50ZXJUeXBlO1xuICAgIHZhciBsID0gZmUodCwgdGhpcy5yZWdpc3RlcmVkQ2xhc3MsIHMucmVnaXN0ZXJlZENsYXNzKTtcbiAgICByZXR1cm4gbCA9PT0gbnVsbCA/IGEuY2FsbCh0aGlzKSA6IHRoaXMuaXNTbWFydFBvaW50ZXIgPyBQdChzLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSwge1xuICAgICAgcHRyVHlwZTogcyxcbiAgICAgIHB0cjogbCxcbiAgICAgIHNtYXJ0UHRyVHlwZTogdGhpcyxcbiAgICAgIHNtYXJ0UHRyOiBlXG4gICAgfSkgOiBQdChzLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSwge1xuICAgICAgcHRyVHlwZTogcyxcbiAgICAgIHB0cjogbFxuICAgIH0pO1xuICB9XG4gIHZhciBCciA9ICgpID0+IHtcbiAgICBPYmplY3QuYXNzaWduKEV0LnByb3RvdHlwZSwge1xuICAgICAgZ2V0UG9pbnRlZShlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhd0dldFBvaW50ZWUgJiYgKGUgPSB0aGlzLnJhd0dldFBvaW50ZWUoZSkpLCBlO1xuICAgICAgfSxcbiAgICAgIGRlc3RydWN0b3IoZSkge1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgKHQgPSB0aGlzLnJhd0Rlc3RydWN0b3IpID09PSBudWxsIHx8IHQgPT09IHZvaWQgMCB8fCB0LmNhbGwodGhpcywgZSk7XG4gICAgICB9LFxuICAgICAgYXJnUGFja0FkdmFuY2U6IE4sXG4gICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogbHQsXG4gICAgICBmcm9tV2lyZVR5cGU6IExyXG4gICAgfSk7XG4gIH07XG4gIGZ1bmN0aW9uIEV0KGUsIHQsIHIsIG4sIGEsIGksIHUsIHMsIGwsIGQsIGgpIHtcbiAgICB0aGlzLm5hbWUgPSBlLCB0aGlzLnJlZ2lzdGVyZWRDbGFzcyA9IHQsIHRoaXMuaXNSZWZlcmVuY2UgPSByLCB0aGlzLmlzQ29uc3QgPSBuLCB0aGlzLmlzU21hcnRQb2ludGVyID0gYSwgdGhpcy5wb2ludGVlVHlwZSA9IGksIHRoaXMuc2hhcmluZ1BvbGljeSA9IHUsIHRoaXMucmF3R2V0UG9pbnRlZSA9IHMsIHRoaXMucmF3Q29uc3RydWN0b3IgPSBsLCB0aGlzLnJhd1NoYXJlID0gZCwgdGhpcy5yYXdEZXN0cnVjdG9yID0gaCwgIWEgJiYgdC5iYXNlQ2xhc3MgPT09IHZvaWQgMCA/IG4gPyAodGhpcy50b1dpcmVUeXBlID0gSXIsIHRoaXMuZGVzdHJ1Y3RvckZ1bmN0aW9uID0gbnVsbCkgOiAodGhpcy50b1dpcmVUeXBlID0gTXIsIHRoaXMuZGVzdHJ1Y3RvckZ1bmN0aW9uID0gbnVsbCkgOiB0aGlzLnRvV2lyZVR5cGUgPSBEcjtcbiAgfVxuICB2YXIgZGUgPSAoZSwgdCwgcikgPT4ge1xuICAgIGMuaGFzT3duUHJvcGVydHkoZSkgfHwgQ3QoXCJSZXBsYWNpbmcgbm9uZXhpc3RlbnQgcHVibGljIHN5bWJvbFwiKSwgY1tlXS5vdmVybG9hZFRhYmxlICE9PSB2b2lkIDAgJiYgciAhPT0gdm9pZCAwID8gY1tlXS5vdmVybG9hZFRhYmxlW3JdID0gdCA6IChjW2VdID0gdCwgY1tlXS5hcmdDb3VudCA9IHIpO1xuICB9LCBoZSA9IFtdLCBwZSwgZyA9IChlKSA9PiB7XG4gICAgdmFyIHQgPSBoZVtlXTtcbiAgICByZXR1cm4gdCB8fCAoaGVbZV0gPSB0ID0gcGUuZ2V0KGUpKSwgdDtcbiAgfSwgV3IgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgbGV0IHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IFtdO1xuICAgIGlmIChlLmluY2x1ZGVzKFwialwiKSlcbiAgICAgIHJldHVybiBkeW5DYWxsTGVnYWN5KGUsIHQsIHIpO1xuICAgIHZhciBuID0gZyh0KSwgYSA9IG4oLi4ucik7XG4gICAgcmV0dXJuIGE7XG4gIH0sIFVyID0gZnVuY3Rpb24oZSwgdCkge1xuICAgIGxldCByID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiAhMTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCwgYSA9IG5ldyBBcnJheShuKSwgaSA9IDA7IGkgPCBuOyBpKyspXG4gICAgICAgIGFbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICByZXR1cm4gV3IoZSwgdCwgYSwgcik7XG4gICAgfTtcbiAgfSwgVSA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBlID0gaihlKTtcbiAgICBmdW5jdGlvbiByKCkge1xuICAgICAgaWYgKGUuaW5jbHVkZXMoXCJqXCIpKVxuICAgICAgICByZXR1cm4gVXIoZSwgdCk7XG4gICAgICB2YXIgYSA9IGcodCk7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgdmFyIG4gPSByKCk7XG4gICAgcmV0dXJuIHR5cGVvZiBuICE9IFwiZnVuY3Rpb25cIiAmJiBDKGB1bmtub3duIGZ1bmN0aW9uIHBvaW50ZXIgd2l0aCBzaWduYXR1cmUgJHtlfTogJHt0fWApLCBuO1xuICB9O1xuICBjbGFzcyBWciBleHRlbmRzIEVycm9yIHtcbiAgfVxuICB2YXIgdmUgPSAoZSkgPT4ge1xuICAgIHZhciB0ID0gTm4oZSksIHIgPSBqKHQpO1xuICAgIHJldHVybiBldCh0KSwgcjtcbiAgfSwgX3QgPSAoZSwgdCkgPT4ge1xuICAgIHZhciByID0gW10sIG4gPSB7fTtcbiAgICBmdW5jdGlvbiBhKGkpIHtcbiAgICAgIGlmICghbltpXSAmJiAhS1tpXSkge1xuICAgICAgICBpZiAoYnRbaV0pIHtcbiAgICAgICAgICBidFtpXS5mb3JFYWNoKGEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByLnB1c2goaSksIG5baV0gPSAhMDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgdC5mb3JFYWNoKGEpLCBuZXcgVnIoYCR7ZX06IGAgKyByLm1hcCh2ZSkuam9pbihbXCIsIFwiXSkpO1xuICB9LCBrciA9IChlLCB0LCByLCBuLCBhLCBpLCB1LCBzLCBsLCBkLCBoLCBwLCB3KSA9PiB7XG4gICAgaCA9IGooaCksIGkgPSBVKGEsIGkpLCBzICYmIChzID0gVSh1LCBzKSksIGQgJiYgKGQgPSBVKGwsIGQpKSwgdyA9IFUocCwgdyk7XG4gICAgdmFyIGIgPSBBcihoKTtcbiAgICBsZShiLCBmdW5jdGlvbigpIHtcbiAgICAgIF90KGBDYW5ub3QgY29uc3RydWN0ICR7aH0gZHVlIHRvIHVuYm91bmQgdHlwZXNgLCBbbl0pO1xuICAgIH0pLCB0dChbZSwgdCwgcl0sIG4gPyBbbl0gOiBbXSwgKF8pID0+IHtcbiAgICAgIF8gPSBfWzBdO1xuICAgICAgdmFyIFMsIEE7XG4gICAgICBuID8gKFMgPSBfLnJlZ2lzdGVyZWRDbGFzcywgQSA9IFMuaW5zdGFuY2VQcm90b3R5cGUpIDogQSA9IFR0LnByb3RvdHlwZTtcbiAgICAgIHZhciBJID0gVXQoaCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykgIT09IFgpXG4gICAgICAgICAgdGhyb3cgbmV3IGZ0KGBVc2UgJ25ldycgdG8gY29uc3RydWN0ICR7aH1gKTtcbiAgICAgICAgaWYgKEwuY29uc3RydWN0b3JfYm9keSA9PT0gdm9pZCAwKVxuICAgICAgICAgIHRocm93IG5ldyBmdChgJHtofSBoYXMgbm8gYWNjZXNzaWJsZSBjb25zdHJ1Y3RvcmApO1xuICAgICAgICBmb3IgKHZhciBPZSA9IGFyZ3VtZW50cy5sZW5ndGgsIHh0ID0gbmV3IEFycmF5KE9lKSwgQXQgPSAwOyBBdCA8IE9lOyBBdCsrKVxuICAgICAgICAgIHh0W0F0XSA9IGFyZ3VtZW50c1tBdF07XG4gICAgICAgIHZhciB4ZSA9IEwuY29uc3RydWN0b3JfYm9keVt4dC5sZW5ndGhdO1xuICAgICAgICBpZiAoeGUgPT09IHZvaWQgMClcbiAgICAgICAgICB0aHJvdyBuZXcgZnQoYFRyaWVkIHRvIGludm9rZSBjdG9yIG9mICR7aH0gd2l0aCBpbnZhbGlkIG51bWJlciBvZiBwYXJhbWV0ZXJzICgke3h0Lmxlbmd0aH0pIC0gZXhwZWN0ZWQgKCR7T2JqZWN0LmtleXMoTC5jb25zdHJ1Y3Rvcl9ib2R5KS50b1N0cmluZygpfSkgcGFyYW1ldGVycyBpbnN0ZWFkIWApO1xuICAgICAgICByZXR1cm4geGUuYXBwbHkodGhpcywgeHQpO1xuICAgICAgfSksIFggPSBPYmplY3QuY3JlYXRlKEEsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogSVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIEkucHJvdG90eXBlID0gWDtcbiAgICAgIHZhciBMID0gbmV3IFNyKGgsIEksIFgsIHcsIFMsIGksIHMsIGQpO1xuICAgICAgaWYgKEwuYmFzZUNsYXNzKSB7XG4gICAgICAgIHZhciBXLCBPdDtcbiAgICAgICAgKE90ID0gKFcgPSBMLmJhc2VDbGFzcykuX19kZXJpdmVkQ2xhc3NlcykgIT09IG51bGwgJiYgT3QgIT09IHZvaWQgMCB8fCAoVy5fX2Rlcml2ZWRDbGFzc2VzID0gW10pLCBMLmJhc2VDbGFzcy5fX2Rlcml2ZWRDbGFzc2VzLnB1c2goTCk7XG4gICAgICB9XG4gICAgICB2YXIgUmEgPSBuZXcgRXQoaCwgTCwgITAsICExLCAhMSksIEVlID0gbmV3IEV0KGggKyBcIipcIiwgTCwgITEsICExLCAhMSksIF9lID0gbmV3IEV0KGggKyBcIiBjb25zdCpcIiwgTCwgITEsICEwLCAhMSk7XG4gICAgICByZXR1cm4gdWVbZV0gPSB7XG4gICAgICAgIHBvaW50ZXJUeXBlOiBFZSxcbiAgICAgICAgY29uc3RQb2ludGVyVHlwZTogX2VcbiAgICAgIH0sIGRlKGIsIEkpLCBbUmEsIEVlLCBfZV07XG4gICAgfSk7XG4gIH0sIGt0ID0gKGUsIHQpID0+IHtcbiAgICBmb3IgKHZhciByID0gW10sIG4gPSAwOyBuIDwgZTsgbisrKVxuICAgICAgci5wdXNoKFBbdCArIG4gKiA0ID4+IDJdKTtcbiAgICByZXR1cm4gcjtcbiAgfTtcbiAgZnVuY3Rpb24gSHIoZSkge1xuICAgIGZvciAodmFyIHQgPSAxOyB0IDwgZS5sZW5ndGg7ICsrdClcbiAgICAgIGlmIChlW3RdICE9PSBudWxsICYmIGVbdF0uZGVzdHJ1Y3RvckZ1bmN0aW9uID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybiAhMDtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgZnVuY3Rpb24gSHQoZSwgdCwgciwgbiwgYSwgaSkge1xuICAgIHZhciB1ID0gdC5sZW5ndGg7XG4gICAgdSA8IDIgJiYgQyhcImFyZ1R5cGVzIGFycmF5IHNpemUgbWlzbWF0Y2ghIE11c3QgYXQgbGVhc3QgZ2V0IHJldHVybiB2YWx1ZSBhbmQgJ3RoaXMnIHR5cGVzIVwiKTtcbiAgICB2YXIgcyA9IHRbMV0gIT09IG51bGwgJiYgciAhPT0gbnVsbCwgbCA9IEhyKHQpLCBkID0gdFswXS5uYW1lICE9PSBcInZvaWRcIiwgaCA9IHUgLSAyLCBwID0gbmV3IEFycmF5KGgpLCB3ID0gW10sIGIgPSBbXSwgXyA9IGZ1bmN0aW9uKCkge1xuICAgICAgYi5sZW5ndGggPSAwO1xuICAgICAgdmFyIFM7XG4gICAgICB3Lmxlbmd0aCA9IHMgPyAyIDogMSwgd1swXSA9IGEsIHMgJiYgKFMgPSB0WzFdLnRvV2lyZVR5cGUoYiwgdGhpcyksIHdbMV0gPSBTKTtcbiAgICAgIGZvciAodmFyIEEgPSAwOyBBIDwgaDsgKytBKVxuICAgICAgICBwW0FdID0gdFtBICsgMl0udG9XaXJlVHlwZShiLCBBIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IEEgPyB2b2lkIDAgOiBhcmd1bWVudHNbQV0pLCB3LnB1c2gocFtBXSk7XG4gICAgICB2YXIgSSA9IG4oLi4udyk7XG4gICAgICBmdW5jdGlvbiBYKEwpIHtcbiAgICAgICAgaWYgKGwpXG4gICAgICAgICAgTHQoYik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKHZhciBXID0gcyA/IDEgOiAyOyBXIDwgdC5sZW5ndGg7IFcrKykge1xuICAgICAgICAgICAgdmFyIE90ID0gVyA9PT0gMSA/IFMgOiBwW1cgLSAyXTtcbiAgICAgICAgICAgIHRbV10uZGVzdHJ1Y3RvckZ1bmN0aW9uICE9PSBudWxsICYmIHRbV10uZGVzdHJ1Y3RvckZ1bmN0aW9uKE90KTtcbiAgICAgICAgICB9XG4gICAgICAgIGlmIChkKVxuICAgICAgICAgIHJldHVybiB0WzBdLmZyb21XaXJlVHlwZShMKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBYKEkpO1xuICAgIH07XG4gICAgcmV0dXJuIFV0KGUsIF8pO1xuICB9XG4gIHZhciBOciA9IChlLCB0LCByLCBuLCBhLCBpKSA9PiB7XG4gICAgdmFyIHUgPSBrdCh0LCByKTtcbiAgICBhID0gVShuLCBhKSwgdHQoW10sIFtlXSwgKHMpID0+IHtcbiAgICAgIHMgPSBzWzBdO1xuICAgICAgdmFyIGwgPSBgY29uc3RydWN0b3IgJHtzLm5hbWV9YDtcbiAgICAgIGlmIChzLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5ID09PSB2b2lkIDAgJiYgKHMucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHkgPSBbXSksIHMucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHlbdCAtIDFdICE9PSB2b2lkIDApXG4gICAgICAgIHRocm93IG5ldyBmdChgQ2Fubm90IHJlZ2lzdGVyIG11bHRpcGxlIGNvbnN0cnVjdG9ycyB3aXRoIGlkZW50aWNhbCBudW1iZXIgb2YgcGFyYW1ldGVycyAoJHt0IC0gMX0pIGZvciBjbGFzcyAnJHtzLm5hbWV9JyEgT3ZlcmxvYWQgcmVzb2x1dGlvbiBpcyBjdXJyZW50bHkgb25seSBwZXJmb3JtZWQgdXNpbmcgdGhlIHBhcmFtZXRlciBjb3VudCwgbm90IGFjdHVhbCB0eXBlIGluZm8hYCk7XG4gICAgICByZXR1cm4gcy5yZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3JfYm9keVt0IC0gMV0gPSAoKSA9PiB7XG4gICAgICAgIF90KGBDYW5ub3QgY29uc3RydWN0ICR7cy5uYW1lfSBkdWUgdG8gdW5ib3VuZCB0eXBlc2AsIHUpO1xuICAgICAgfSwgdHQoW10sIHUsIChkKSA9PiAoZC5zcGxpY2UoMSwgMCwgbnVsbCksIHMucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHlbdCAtIDFdID0gSHQobCwgZCwgbnVsbCwgYSwgaSksIFtdKSksIFtdO1xuICAgIH0pO1xuICB9LCB5ZSA9IChlKSA9PiB7XG4gICAgZSA9IGUudHJpbSgpO1xuICAgIGNvbnN0IHQgPSBlLmluZGV4T2YoXCIoXCIpO1xuICAgIHJldHVybiB0ID09PSAtMSA/IGUgOiBlLnNsaWNlKDAsIHQpO1xuICB9LCB6ciA9IChlLCB0LCByLCBuLCBhLCBpLCB1LCBzLCBsLCBkKSA9PiB7XG4gICAgdmFyIGggPSBrdChyLCBuKTtcbiAgICB0ID0gaih0KSwgdCA9IHllKHQpLCBpID0gVShhLCBpKSwgdHQoW10sIFtlXSwgKHApID0+IHtcbiAgICAgIHAgPSBwWzBdO1xuICAgICAgdmFyIHcgPSBgJHtwLm5hbWV9LiR7dH1gO1xuICAgICAgdC5zdGFydHNXaXRoKFwiQEBcIikgJiYgKHQgPSBTeW1ib2xbdC5zdWJzdHJpbmcoMildKSwgcyAmJiBwLnJlZ2lzdGVyZWRDbGFzcy5wdXJlVmlydHVhbEZ1bmN0aW9ucy5wdXNoKHQpO1xuICAgICAgZnVuY3Rpb24gYigpIHtcbiAgICAgICAgX3QoYENhbm5vdCBjYWxsICR7d30gZHVlIHRvIHVuYm91bmQgdHlwZXNgLCBoKTtcbiAgICAgIH1cbiAgICAgIHZhciBfID0gcC5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGUsIFMgPSBfW3RdO1xuICAgICAgcmV0dXJuIFMgPT09IHZvaWQgMCB8fCBTLm92ZXJsb2FkVGFibGUgPT09IHZvaWQgMCAmJiBTLmNsYXNzTmFtZSAhPT0gcC5uYW1lICYmIFMuYXJnQ291bnQgPT09IHIgLSAyID8gKGIuYXJnQ291bnQgPSByIC0gMiwgYi5jbGFzc05hbWUgPSBwLm5hbWUsIF9bdF0gPSBiKSA6IChjZShfLCB0LCB3KSwgX1t0XS5vdmVybG9hZFRhYmxlW3IgLSAyXSA9IGIpLCB0dChbXSwgaCwgKEEpID0+IHtcbiAgICAgICAgdmFyIEkgPSBIdCh3LCBBLCBwLCBpLCB1KTtcbiAgICAgICAgcmV0dXJuIF9bdF0ub3ZlcmxvYWRUYWJsZSA9PT0gdm9pZCAwID8gKEkuYXJnQ291bnQgPSByIC0gMiwgX1t0XSA9IEkpIDogX1t0XS5vdmVybG9hZFRhYmxlW3IgLSAyXSA9IEksIFtdO1xuICAgICAgfSksIFtdO1xuICAgIH0pO1xuICB9LCBOdCA9IFtdLCB6ID0gW10sIHp0ID0gKGUpID0+IHtcbiAgICBlID4gOSAmJiAtLXpbZSArIDFdID09PSAwICYmICh6W2VdID0gdm9pZCAwLCBOdC5wdXNoKGUpKTtcbiAgfSwgR3IgPSAoKSA9PiB6Lmxlbmd0aCAvIDIgLSA1IC0gTnQubGVuZ3RoLCBYciA9ICgpID0+IHtcbiAgICB6LnB1c2goMCwgMSwgdm9pZCAwLCAxLCBudWxsLCAxLCAhMCwgMSwgITEsIDEpLCBjLmNvdW50X2VtdmFsX2hhbmRsZXMgPSBHcjtcbiAgfSwgRyA9IHtcbiAgICB0b1ZhbHVlOiAoZSkgPT4gKGUgfHwgQyhgQ2Fubm90IHVzZSBkZWxldGVkIHZhbC4gaGFuZGxlID0gJHtlfWApLCB6W2VdKSxcbiAgICB0b0hhbmRsZTogKGUpID0+IHtcbiAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICBjYXNlIHZvaWQgMDpcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICBjYXNlICEwOlxuICAgICAgICAgIHJldHVybiA2O1xuICAgICAgICBjYXNlICExOlxuICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgdCA9IE50LnBvcCgpIHx8IHoubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiB6W3RdID0gZSwgelt0ICsgMV0gPSAxLCB0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCBtZSA9IHtcbiAgICBuYW1lOiBcImVtc2NyaXB0ZW46OnZhbFwiLFxuICAgIGZyb21XaXJlVHlwZTogKGUpID0+IHtcbiAgICAgIHZhciB0ID0gRy50b1ZhbHVlKGUpO1xuICAgICAgcmV0dXJuIHp0KGUpLCB0O1xuICAgIH0sXG4gICAgdG9XaXJlVHlwZTogKGUsIHQpID0+IEcudG9IYW5kbGUodCksXG4gICAgYXJnUGFja0FkdmFuY2U6IE4sXG4gICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IGx0LFxuICAgIGRlc3RydWN0b3JGdW5jdGlvbjogbnVsbFxuICB9LCBxciA9IChlKSA9PiBWKGUsIG1lKSwgWXIgPSAoZSwgdCkgPT4ge1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZyb21XaXJlVHlwZShLdFtyID4+IDJdKTtcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgODpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUodGVbciA+PiAzXSk7XG4gICAgICAgIH07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGZsb2F0IHdpZHRoICgke3R9KTogJHtlfWApO1xuICAgIH1cbiAgfSwgWnIgPSAoZSwgdCwgcikgPT4ge1xuICAgIHQgPSBqKHQpLCBWKGUsIHtcbiAgICAgIG5hbWU6IHQsXG4gICAgICBmcm9tV2lyZVR5cGU6IChuKSA9PiBuLFxuICAgICAgdG9XaXJlVHlwZTogKG4sIGEpID0+IGEsXG4gICAgICBhcmdQYWNrQWR2YW5jZTogTixcbiAgICAgIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiBZcih0LCByKSxcbiAgICAgIGRlc3RydWN0b3JGdW5jdGlvbjogbnVsbFxuICAgIH0pO1xuICB9LCBRciA9IChlLCB0LCByLCBuLCBhLCBpLCB1LCBzKSA9PiB7XG4gICAgdmFyIGwgPSBrdCh0LCByKTtcbiAgICBlID0gaihlKSwgZSA9IHllKGUpLCBhID0gVShuLCBhKSwgbGUoZSwgZnVuY3Rpb24oKSB7XG4gICAgICBfdChgQ2Fubm90IGNhbGwgJHtlfSBkdWUgdG8gdW5ib3VuZCB0eXBlc2AsIGwpO1xuICAgIH0sIHQgLSAxKSwgdHQoW10sIGwsIChkKSA9PiB7XG4gICAgICB2YXIgaCA9IFtkWzBdLCBudWxsXS5jb25jYXQoZC5zbGljZSgxKSk7XG4gICAgICByZXR1cm4gZGUoZSwgSHQoZSwgaCwgbnVsbCwgYSwgaSksIHQgLSAxKSwgW107XG4gICAgfSk7XG4gIH0sIEpyID0gKGUsIHQsIHIpID0+IHtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHIgPyAobikgPT4gUVtuXSA6IChuKSA9PiBCW25dO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gciA/IChuKSA9PiB1dFtuID4+IDFdIDogKG4pID0+IHZ0W24gPj4gMV07XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiByID8gKG4pID0+IGF0W24gPj4gMl0gOiAobikgPT4gUFtuID4+IDJdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBpbnRlZ2VyIHdpZHRoICgke3R9KTogJHtlfWApO1xuICAgIH1cbiAgfSwgS3IgPSAoZSwgdCwgciwgbiwgYSkgPT4ge1xuICAgIHQgPSBqKHQpO1xuICAgIHZhciBpID0gKGgpID0+IGg7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIHZhciB1ID0gMzIgLSA4ICogcjtcbiAgICAgIGkgPSAoaCkgPT4gaCA8PCB1ID4+PiB1O1xuICAgIH1cbiAgICB2YXIgcyA9IHQuaW5jbHVkZXMoXCJ1bnNpZ25lZFwiKSwgbCA9IChoLCBwKSA9PiB7XG4gICAgfSwgZDtcbiAgICBzID8gZCA9IGZ1bmN0aW9uKGgsIHApIHtcbiAgICAgIHJldHVybiBsKHAsIHRoaXMubmFtZSksIHAgPj4+IDA7XG4gICAgfSA6IGQgPSBmdW5jdGlvbihoLCBwKSB7XG4gICAgICByZXR1cm4gbChwLCB0aGlzLm5hbWUpLCBwO1xuICAgIH0sIFYoZSwge1xuICAgICAgbmFtZTogdCxcbiAgICAgIGZyb21XaXJlVHlwZTogaSxcbiAgICAgIHRvV2lyZVR5cGU6IGQsXG4gICAgICBhcmdQYWNrQWR2YW5jZTogTixcbiAgICAgIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiBKcih0LCByLCBuICE9PSAwKSxcbiAgICAgIGRlc3RydWN0b3JGdW5jdGlvbjogbnVsbFxuICAgIH0pO1xuICB9LCB0biA9IChlLCB0LCByKSA9PiB7XG4gICAgdmFyIG4gPSBbSW50OEFycmF5LCBVaW50OEFycmF5LCBJbnQxNkFycmF5LCBVaW50MTZBcnJheSwgSW50MzJBcnJheSwgVWludDMyQXJyYXksIEZsb2F0MzJBcnJheSwgRmxvYXQ2NEFycmF5XSwgYSA9IG5bdF07XG4gICAgZnVuY3Rpb24gaSh1KSB7XG4gICAgICB2YXIgcyA9IFBbdSA+PiAyXSwgbCA9IFBbdSArIDQgPj4gMl07XG4gICAgICByZXR1cm4gbmV3IGEoUS5idWZmZXIsIGwsIHMpO1xuICAgIH1cbiAgICByID0gaihyKSwgVihlLCB7XG4gICAgICBuYW1lOiByLFxuICAgICAgZnJvbVdpcmVUeXBlOiBpLFxuICAgICAgYXJnUGFja0FkdmFuY2U6IE4sXG4gICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogaVxuICAgIH0sIHtcbiAgICAgIGlnbm9yZUR1cGxpY2F0ZVJlZ2lzdHJhdGlvbnM6ICEwXG4gICAgfSk7XG4gIH0sIGVuID0gT2JqZWN0LmFzc2lnbih7XG4gICAgb3B0aW9uYWw6ICEwXG4gIH0sIG1lKSwgcm4gPSAoZSwgdCkgPT4ge1xuICAgIFYoZSwgZW4pO1xuICB9LCBubiA9IChlLCB0LCByLCBuKSA9PiB7XG4gICAgaWYgKCEobiA+IDApKSByZXR1cm4gMDtcbiAgICBmb3IgKHZhciBhID0gciwgaSA9IHIgKyBuIC0gMSwgdSA9IDA7IHUgPCBlLmxlbmd0aDsgKyt1KSB7XG4gICAgICB2YXIgcyA9IGUuY2hhckNvZGVBdCh1KTtcbiAgICAgIGlmIChzID49IDU1Mjk2ICYmIHMgPD0gNTczNDMpIHtcbiAgICAgICAgdmFyIGwgPSBlLmNoYXJDb2RlQXQoKyt1KTtcbiAgICAgICAgcyA9IDY1NTM2ICsgKChzICYgMTAyMykgPDwgMTApIHwgbCAmIDEwMjM7XG4gICAgICB9XG4gICAgICBpZiAocyA8PSAxMjcpIHtcbiAgICAgICAgaWYgKHIgPj0gaSkgYnJlYWs7XG4gICAgICAgIHRbcisrXSA9IHM7XG4gICAgICB9IGVsc2UgaWYgKHMgPD0gMjA0Nykge1xuICAgICAgICBpZiAociArIDEgPj0gaSkgYnJlYWs7XG4gICAgICAgIHRbcisrXSA9IDE5MiB8IHMgPj4gNiwgdFtyKytdID0gMTI4IHwgcyAmIDYzO1xuICAgICAgfSBlbHNlIGlmIChzIDw9IDY1NTM1KSB7XG4gICAgICAgIGlmIChyICsgMiA+PSBpKSBicmVhaztcbiAgICAgICAgdFtyKytdID0gMjI0IHwgcyA+PiAxMiwgdFtyKytdID0gMTI4IHwgcyA+PiA2ICYgNjMsIHRbcisrXSA9IDEyOCB8IHMgJiA2MztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyICsgMyA+PSBpKSBicmVhaztcbiAgICAgICAgdFtyKytdID0gMjQwIHwgcyA+PiAxOCwgdFtyKytdID0gMTI4IHwgcyA+PiAxMiAmIDYzLCB0W3IrK10gPSAxMjggfCBzID4+IDYgJiA2MywgdFtyKytdID0gMTI4IHwgcyAmIDYzO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdFtyXSA9IDAsIHIgLSBhO1xuICB9LCBpdCA9IChlLCB0LCByKSA9PiBubihlLCBCLCB0LCByKSwgZ2UgPSAoZSkgPT4ge1xuICAgIGZvciAodmFyIHQgPSAwLCByID0gMDsgciA8IGUubGVuZ3RoOyArK3IpIHtcbiAgICAgIHZhciBuID0gZS5jaGFyQ29kZUF0KHIpO1xuICAgICAgbiA8PSAxMjcgPyB0KysgOiBuIDw9IDIwNDcgPyB0ICs9IDIgOiBuID49IDU1Mjk2ICYmIG4gPD0gNTczNDMgPyAodCArPSA0LCArK3IpIDogdCArPSAzO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfSwgd2UgPSB0eXBlb2YgVGV4dERlY29kZXIgPCBcInVcIiA/IG5ldyBUZXh0RGVjb2RlcigpIDogdm9pZCAwLCAkZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBsZXQgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogMCwgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogTmFOO1xuICAgIGZvciAodmFyIG4gPSB0ICsgciwgYSA9IHQ7IGVbYV0gJiYgIShhID49IG4pOyApICsrYTtcbiAgICBpZiAoYSAtIHQgPiAxNiAmJiBlLmJ1ZmZlciAmJiB3ZSlcbiAgICAgIHJldHVybiB3ZS5kZWNvZGUoZS5zdWJhcnJheSh0LCBhKSk7XG4gICAgZm9yICh2YXIgaSA9IFwiXCI7IHQgPCBhOyApIHtcbiAgICAgIHZhciB1ID0gZVt0KytdO1xuICAgICAgaWYgKCEodSAmIDEyOCkpIHtcbiAgICAgICAgaSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBzID0gZVt0KytdICYgNjM7XG4gICAgICBpZiAoKHUgJiAyMjQpID09IDE5Mikge1xuICAgICAgICBpICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKHUgJiAzMSkgPDwgNiB8IHMpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBsID0gZVt0KytdICYgNjM7XG4gICAgICBpZiAoKHUgJiAyNDApID09IDIyNCA/IHUgPSAodSAmIDE1KSA8PCAxMiB8IHMgPDwgNiB8IGwgOiB1ID0gKHUgJiA3KSA8PCAxOCB8IHMgPDwgMTIgfCBsIDw8IDYgfCBlW3QrK10gJiA2MywgdSA8IDY1NTM2KVxuICAgICAgICBpICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGQgPSB1IC0gNjU1MzY7XG4gICAgICAgIGkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NiB8IGQgPj4gMTAsIDU2MzIwIHwgZCAmIDEwMjMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfSwgYW4gPSAoZSwgdCkgPT4gZSA/ICRlKEIsIGUsIHQpIDogXCJcIiwgb24gPSAoZSwgdCkgPT4ge1xuICAgIHQgPSBqKHQpLCBWKGUsIHtcbiAgICAgIG5hbWU6IHQsXG4gICAgICBmcm9tV2lyZVR5cGUocikge1xuICAgICAgICBmb3IgKHZhciBuID0gUFtyID4+IDJdLCBhID0gciArIDQsIGksIHMsIHUgPSBhLCBzID0gMDsgcyA8PSBuOyArK3MpIHtcbiAgICAgICAgICB2YXIgbCA9IGEgKyBzO1xuICAgICAgICAgIGlmIChzID09IG4gfHwgQltsXSA9PSAwKSB7XG4gICAgICAgICAgICB2YXIgZCA9IGwgLSB1LCBoID0gYW4odSwgZCk7XG4gICAgICAgICAgICBpID09PSB2b2lkIDAgPyBpID0gaCA6IChpICs9IFwiXFwwXCIsIGkgKz0gaCksIHUgPSBsICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV0KHIpLCBpO1xuICAgICAgfSxcbiAgICAgIHRvV2lyZVR5cGUociwgbikge1xuICAgICAgICBuIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgJiYgKG4gPSBuZXcgVWludDhBcnJheShuKSk7XG4gICAgICAgIHZhciBhLCBpID0gdHlwZW9mIG4gPT0gXCJzdHJpbmdcIjtcbiAgICAgICAgaSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcobikgJiYgbi5CWVRFU19QRVJfRUxFTUVOVCA9PSAxIHx8IEMoXCJDYW5ub3QgcGFzcyBub24tc3RyaW5nIHRvIHN0ZDo6c3RyaW5nXCIpLCBpID8gYSA9IGdlKG4pIDogYSA9IG4ubGVuZ3RoO1xuICAgICAgICB2YXIgdSA9IFBlKDQgKyBhICsgMSksIHMgPSB1ICsgNDtcbiAgICAgICAgcmV0dXJuIFBbdSA+PiAyXSA9IGEsIGkgPyBpdChuLCBzLCBhICsgMSkgOiBCLnNldChuLCBzKSwgciAhPT0gbnVsbCAmJiByLnB1c2goZXQsIHUpLCB1O1xuICAgICAgfSxcbiAgICAgIGFyZ1BhY2tBZHZhbmNlOiBOLFxuICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IGx0LFxuICAgICAgZGVzdHJ1Y3RvckZ1bmN0aW9uKHIpIHtcbiAgICAgICAgZXQocik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIGJlID0gdHlwZW9mIFRleHREZWNvZGVyIDwgXCJ1XCIgPyBuZXcgVGV4dERlY29kZXIoXCJ1dGYtMTZsZVwiKSA6IHZvaWQgMCwgc24gPSAoZSwgdCkgPT4ge1xuICAgIGZvciAodmFyIHIgPSBlLCBuID0gciA+PiAxLCBhID0gbiArIHQgLyAyOyAhKG4gPj0gYSkgJiYgdnRbbl07ICkgKytuO1xuICAgIGlmIChyID0gbiA8PCAxLCByIC0gZSA+IDMyICYmIGJlKSByZXR1cm4gYmUuZGVjb2RlKEIuc3ViYXJyYXkoZSwgcikpO1xuICAgIGZvciAodmFyIGkgPSBcIlwiLCB1ID0gMDsgISh1ID49IHQgLyAyKTsgKyt1KSB7XG4gICAgICB2YXIgcyA9IHV0W2UgKyB1ICogMiA+PiAxXTtcbiAgICAgIGlmIChzID09IDApIGJyZWFrO1xuICAgICAgaSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHMpO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfSwgdW4gPSAoZSwgdCwgcikgPT4ge1xuICAgIGlmIChyICE9IG51bGwgfHwgKHIgPSAyMTQ3NDgzNjQ3KSwgciA8IDIpIHJldHVybiAwO1xuICAgIHIgLT0gMjtcbiAgICBmb3IgKHZhciBuID0gdCwgYSA9IHIgPCBlLmxlbmd0aCAqIDIgPyByIC8gMiA6IGUubGVuZ3RoLCBpID0gMDsgaSA8IGE7ICsraSkge1xuICAgICAgdmFyIHUgPSBlLmNoYXJDb2RlQXQoaSk7XG4gICAgICB1dFt0ID4+IDFdID0gdSwgdCArPSAyO1xuICAgIH1cbiAgICByZXR1cm4gdXRbdCA+PiAxXSA9IDAsIHQgLSBuO1xuICB9LCBjbiA9IChlKSA9PiBlLmxlbmd0aCAqIDIsIGxuID0gKGUsIHQpID0+IHtcbiAgICBmb3IgKHZhciByID0gMCwgbiA9IFwiXCI7ICEociA+PSB0IC8gNCk7ICkge1xuICAgICAgdmFyIGEgPSBhdFtlICsgciAqIDQgPj4gMl07XG4gICAgICBpZiAoYSA9PSAwKSBicmVhaztcbiAgICAgIGlmICgrK3IsIGEgPj0gNjU1MzYpIHtcbiAgICAgICAgdmFyIGkgPSBhIC0gNjU1MzY7XG4gICAgICAgIG4gKz0gU3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NiB8IGkgPj4gMTAsIDU2MzIwIHwgaSAmIDEwMjMpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG4gKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH0sIGZuID0gKGUsIHQsIHIpID0+IHtcbiAgICBpZiAociAhPSBudWxsIHx8IChyID0gMjE0NzQ4MzY0NyksIHIgPCA0KSByZXR1cm4gMDtcbiAgICBmb3IgKHZhciBuID0gdCwgYSA9IG4gKyByIC0gNCwgaSA9IDA7IGkgPCBlLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgdSA9IGUuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmICh1ID49IDU1Mjk2ICYmIHUgPD0gNTczNDMpIHtcbiAgICAgICAgdmFyIHMgPSBlLmNoYXJDb2RlQXQoKytpKTtcbiAgICAgICAgdSA9IDY1NTM2ICsgKCh1ICYgMTAyMykgPDwgMTApIHwgcyAmIDEwMjM7XG4gICAgICB9XG4gICAgICBpZiAoYXRbdCA+PiAyXSA9IHUsIHQgKz0gNCwgdCArIDQgPiBhKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGF0W3QgPj4gMl0gPSAwLCB0IC0gbjtcbiAgfSwgZG4gPSAoZSkgPT4ge1xuICAgIGZvciAodmFyIHQgPSAwLCByID0gMDsgciA8IGUubGVuZ3RoOyArK3IpIHtcbiAgICAgIHZhciBuID0gZS5jaGFyQ29kZUF0KHIpO1xuICAgICAgbiA+PSA1NTI5NiAmJiBuIDw9IDU3MzQzICYmICsrciwgdCArPSA0O1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfSwgaG4gPSAoZSwgdCwgcikgPT4ge1xuICAgIHIgPSBqKHIpO1xuICAgIHZhciBuLCBhLCBpLCB1O1xuICAgIHQgPT09IDIgPyAobiA9IHNuLCBhID0gdW4sIHUgPSBjbiwgaSA9IChzKSA9PiB2dFtzID4+IDFdKSA6IHQgPT09IDQgJiYgKG4gPSBsbiwgYSA9IGZuLCB1ID0gZG4sIGkgPSAocykgPT4gUFtzID4+IDJdKSwgVihlLCB7XG4gICAgICBuYW1lOiByLFxuICAgICAgZnJvbVdpcmVUeXBlOiAocykgPT4ge1xuICAgICAgICBmb3IgKHZhciBsID0gUFtzID4+IDJdLCBkLCBoID0gcyArIDQsIHAgPSAwOyBwIDw9IGw7ICsrcCkge1xuICAgICAgICAgIHZhciB3ID0gcyArIDQgKyBwICogdDtcbiAgICAgICAgICBpZiAocCA9PSBsIHx8IGkodykgPT0gMCkge1xuICAgICAgICAgICAgdmFyIGIgPSB3IC0gaCwgXyA9IG4oaCwgYik7XG4gICAgICAgICAgICBkID09PSB2b2lkIDAgPyBkID0gXyA6IChkICs9IFwiXFwwXCIsIGQgKz0gXyksIGggPSB3ICsgdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV0KHMpLCBkO1xuICAgICAgfSxcbiAgICAgIHRvV2lyZVR5cGU6IChzLCBsKSA9PiB7XG4gICAgICAgIHR5cGVvZiBsICE9IFwic3RyaW5nXCIgJiYgQyhgQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBDKysgc3RyaW5nIHR5cGUgJHtyfWApO1xuICAgICAgICB2YXIgZCA9IHUobCksIGggPSBQZSg0ICsgZCArIHQpO1xuICAgICAgICByZXR1cm4gUFtoID4+IDJdID0gZCAvIHQsIGEobCwgaCArIDQsIGQgKyB0KSwgcyAhPT0gbnVsbCAmJiBzLnB1c2goZXQsIGgpLCBoO1xuICAgICAgfSxcbiAgICAgIGFyZ1BhY2tBZHZhbmNlOiBOLFxuICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IGx0LFxuICAgICAgZGVzdHJ1Y3RvckZ1bmN0aW9uKHMpIHtcbiAgICAgICAgZXQocyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIHBuID0gKGUsIHQsIHIsIG4sIGEsIGkpID0+IHtcbiAgICAkdFtlXSA9IHtcbiAgICAgIG5hbWU6IGoodCksXG4gICAgICByYXdDb25zdHJ1Y3RvcjogVShyLCBuKSxcbiAgICAgIHJhd0Rlc3RydWN0b3I6IFUoYSwgaSksXG4gICAgICBmaWVsZHM6IFtdXG4gICAgfTtcbiAgfSwgdm4gPSAoZSwgdCwgciwgbiwgYSwgaSwgdSwgcywgbCwgZCkgPT4ge1xuICAgICR0W2VdLmZpZWxkcy5wdXNoKHtcbiAgICAgIGZpZWxkTmFtZTogaih0KSxcbiAgICAgIGdldHRlclJldHVyblR5cGU6IHIsXG4gICAgICBnZXR0ZXI6IFUobiwgYSksXG4gICAgICBnZXR0ZXJDb250ZXh0OiBpLFxuICAgICAgc2V0dGVyQXJndW1lbnRUeXBlOiB1LFxuICAgICAgc2V0dGVyOiBVKHMsIGwpLFxuICAgICAgc2V0dGVyQ29udGV4dDogZFxuICAgIH0pO1xuICB9LCB5biA9IChlLCB0KSA9PiB7XG4gICAgdCA9IGoodCksIFYoZSwge1xuICAgICAgaXNWb2lkOiAhMCxcbiAgICAgIG5hbWU6IHQsXG4gICAgICBhcmdQYWNrQWR2YW5jZTogMCxcbiAgICAgIGZyb21XaXJlVHlwZTogKCkgPT4ge1xuICAgICAgfSxcbiAgICAgIHRvV2lyZVR5cGU6IChyLCBuKSA9PiB7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIEd0ID0gW10sIG1uID0gKGUsIHQsIHIsIG4pID0+IChlID0gR3RbZV0sIHQgPSBHLnRvVmFsdWUodCksIGUobnVsbCwgdCwgciwgbikpLCBnbiA9IHt9LCB3biA9IChlKSA9PiB7XG4gICAgdmFyIHQgPSBnbltlXTtcbiAgICByZXR1cm4gdCA9PT0gdm9pZCAwID8gaihlKSA6IHQ7XG4gIH0sIENlID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgZnVuY3Rpb24gZSh0KSB7XG4gICAgICB0LiQkJGVtYmluZF9nbG9iYWwkJCQgPSB0O1xuICAgICAgdmFyIHIgPSB0eXBlb2YgJCQkZW1iaW5kX2dsb2JhbCQkJCA9PSBcIm9iamVjdFwiICYmIHQuJCQkZW1iaW5kX2dsb2JhbCQkJCA9PSB0O1xuICAgICAgcmV0dXJuIHIgfHwgZGVsZXRlIHQuJCQkZW1iaW5kX2dsb2JhbCQkJCwgcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAkJCRlbWJpbmRfZ2xvYmFsJCQkID09IFwib2JqZWN0XCIgfHwgKHR5cGVvZiBnbG9iYWwgPT0gXCJvYmplY3RcIiAmJiBlKGdsb2JhbCkgPyAkJCRlbWJpbmRfZ2xvYmFsJCQkID0gZ2xvYmFsIDogdHlwZW9mIHNlbGYgPT0gXCJvYmplY3RcIiAmJiBlKHNlbGYpICYmICgkJCRlbWJpbmRfZ2xvYmFsJCQkID0gc2VsZiksIHR5cGVvZiAkJCRlbWJpbmRfZ2xvYmFsJCQkID09IFwib2JqZWN0XCIpKVxuICAgICAgcmV0dXJuICQkJGVtYmluZF9nbG9iYWwkJCQ7XG4gICAgdGhyb3cgRXJyb3IoXCJ1bmFibGUgdG8gZ2V0IGdsb2JhbCBvYmplY3QuXCIpO1xuICB9LCAkbiA9IChlKSA9PiBlID09PSAwID8gRy50b0hhbmRsZShDZSgpKSA6IChlID0gd24oZSksIEcudG9IYW5kbGUoQ2UoKVtlXSkpLCBibiA9IChlKSA9PiB7XG4gICAgdmFyIHQgPSBHdC5sZW5ndGg7XG4gICAgcmV0dXJuIEd0LnB1c2goZSksIHQ7XG4gIH0sIFRlID0gKGUsIHQpID0+IHtcbiAgICB2YXIgciA9IEtbZV07XG4gICAgcmV0dXJuIHIgPT09IHZvaWQgMCAmJiBDKGAke3R9IGhhcyB1bmtub3duIHR5cGUgJHt2ZShlKX1gKSwgcjtcbiAgfSwgQ24gPSAoZSwgdCkgPT4ge1xuICAgIGZvciAodmFyIHIgPSBuZXcgQXJyYXkoZSksIG4gPSAwOyBuIDwgZTsgKytuKVxuICAgICAgcltuXSA9IFRlKFBbdCArIG4gKiA0ID4+IDJdLCBgcGFyYW1ldGVyICR7bn1gKTtcbiAgICByZXR1cm4gcjtcbiAgfSwgVG4gPSAoZSwgdCwgcikgPT4ge1xuICAgIHZhciBuID0gW10sIGEgPSBlLnRvV2lyZVR5cGUobiwgcik7XG4gICAgcmV0dXJuIG4ubGVuZ3RoICYmIChQW3QgPj4gMl0gPSBHLnRvSGFuZGxlKG4pKSwgYTtcbiAgfSwgUG4gPSBSZWZsZWN0LmNvbnN0cnVjdCwgRW4gPSAoZSwgdCwgcikgPT4ge1xuICAgIHZhciBuID0gQ24oZSwgdCksIGEgPSBuLnNoaWZ0KCk7XG4gICAgZS0tO1xuICAgIHZhciBpID0gbmV3IEFycmF5KGUpLCB1ID0gKGwsIGQsIGgsIHApID0+IHtcbiAgICAgIGZvciAodmFyIHcgPSAwLCBiID0gMDsgYiA8IGU7ICsrYilcbiAgICAgICAgaVtiXSA9IG5bYl0ucmVhZFZhbHVlRnJvbVBvaW50ZXIocCArIHcpLCB3ICs9IG5bYl0uYXJnUGFja0FkdmFuY2U7XG4gICAgICB2YXIgXyA9IHIgPT09IDEgPyBQbihkLCBpKSA6IGQuYXBwbHkobCwgaSk7XG4gICAgICByZXR1cm4gVG4oYSwgaCwgXyk7XG4gICAgfSwgcyA9IGBtZXRob2RDYWxsZXI8KCR7bi5tYXAoKGwpID0+IGwubmFtZSkuam9pbihcIiwgXCIpfSkgPT4gJHthLm5hbWV9PmA7XG4gICAgcmV0dXJuIGJuKFV0KHMsIHUpKTtcbiAgfSwgX24gPSAoZSkgPT4ge1xuICAgIGUgPiA5ICYmICh6W2UgKyAxXSArPSAxKTtcbiAgfSwgT24gPSAoZSkgPT4ge1xuICAgIHZhciB0ID0gRy50b1ZhbHVlKGUpO1xuICAgIEx0KHQpLCB6dChlKTtcbiAgfSwgeG4gPSAoZSwgdCkgPT4ge1xuICAgIGUgPSBUZShlLCBcIl9lbXZhbF90YWtlX3ZhbHVlXCIpO1xuICAgIHZhciByID0gZS5yZWFkVmFsdWVGcm9tUG9pbnRlcih0KTtcbiAgICByZXR1cm4gRy50b0hhbmRsZShyKTtcbiAgfSwgQW4gPSAoZSwgdCwgciwgbikgPT4ge1xuICAgIHZhciBhID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRGdWxsWWVhcigpLCBpID0gbmV3IERhdGUoYSwgMCwgMSksIHUgPSBuZXcgRGF0ZShhLCA2LCAxKSwgcyA9IGkuZ2V0VGltZXpvbmVPZmZzZXQoKSwgbCA9IHUuZ2V0VGltZXpvbmVPZmZzZXQoKSwgZCA9IE1hdGgubWF4KHMsIGwpO1xuICAgIFBbZSA+PiAyXSA9IGQgKiA2MCwgYXRbdCA+PiAyXSA9ICsocyAhPSBsKTtcbiAgICB2YXIgaCA9IChiKSA9PiB7XG4gICAgICB2YXIgXyA9IGIgPj0gMCA/IFwiLVwiIDogXCIrXCIsIFMgPSBNYXRoLmFicyhiKSwgQSA9IFN0cmluZyhNYXRoLmZsb29yKFMgLyA2MCkpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgSSA9IFN0cmluZyhTICUgNjApLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbiAgICAgIHJldHVybiBgVVRDJHtffSR7QX0ke0l9YDtcbiAgICB9LCBwID0gaChzKSwgdyA9IGgobCk7XG4gICAgbCA8IHMgPyAoaXQocCwgciwgMTcpLCBpdCh3LCBuLCAxNykpIDogKGl0KHAsIG4sIDE3KSwgaXQodywgciwgMTcpKTtcbiAgfSwgU24gPSAoKSA9PiAyMTQ3NDgzNjQ4LCBJbiA9IChlLCB0KSA9PiBNYXRoLmNlaWwoZSAvIHQpICogdCwgRG4gPSAoZSkgPT4ge1xuICAgIHZhciB0ID0gbnQuYnVmZmVyLCByID0gKGUgLSB0LmJ5dGVMZW5ndGggKyA2NTUzNSkgLyA2NTUzNiB8IDA7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBudC5ncm93KHIpLCBlZSgpLCAxO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfSwgTW4gPSAoZSkgPT4ge1xuICAgIHZhciB0ID0gQi5sZW5ndGg7XG4gICAgZSA+Pj49IDA7XG4gICAgdmFyIHIgPSBTbigpO1xuICAgIGlmIChlID4gcilcbiAgICAgIHJldHVybiAhMTtcbiAgICBmb3IgKHZhciBuID0gMTsgbiA8PSA0OyBuICo9IDIpIHtcbiAgICAgIHZhciBhID0gdCAqICgxICsgMC4yIC8gbik7XG4gICAgICBhID0gTWF0aC5taW4oYSwgZSArIDEwMDY2MzI5Nik7XG4gICAgICB2YXIgaSA9IE1hdGgubWluKHIsIEluKE1hdGgubWF4KGUsIGEpLCA2NTUzNikpLCB1ID0gRG4oaSk7XG4gICAgICBpZiAodSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH0sIFh0ID0ge30sIEZuID0gKCkgPT4gTSB8fCBcIi4vdGhpcy5wcm9ncmFtXCIsIGh0ID0gKCkgPT4ge1xuICAgIGlmICghaHQuc3RyaW5ncykge1xuICAgICAgdmFyIGUgPSAodHlwZW9mIG5hdmlnYXRvciA9PSBcIm9iamVjdFwiICYmIG5hdmlnYXRvci5sYW5ndWFnZXMgJiYgbmF2aWdhdG9yLmxhbmd1YWdlc1swXSB8fCBcIkNcIikucmVwbGFjZShcIi1cIiwgXCJfXCIpICsgXCIuVVRGLThcIiwgdCA9IHtcbiAgICAgICAgVVNFUjogXCJ3ZWJfdXNlclwiLFxuICAgICAgICBMT0dOQU1FOiBcIndlYl91c2VyXCIsXG4gICAgICAgIFBBVEg6IFwiL1wiLFxuICAgICAgICBQV0Q6IFwiL1wiLFxuICAgICAgICBIT01FOiBcIi9ob21lL3dlYl91c2VyXCIsXG4gICAgICAgIExBTkc6IGUsXG4gICAgICAgIF86IEZuKClcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciByIGluIFh0KVxuICAgICAgICBYdFtyXSA9PT0gdm9pZCAwID8gZGVsZXRlIHRbcl0gOiB0W3JdID0gWHRbcl07XG4gICAgICB2YXIgbiA9IFtdO1xuICAgICAgZm9yICh2YXIgciBpbiB0KVxuICAgICAgICBuLnB1c2goYCR7cn09JHt0W3JdfWApO1xuICAgICAgaHQuc3RyaW5ncyA9IG47XG4gICAgfVxuICAgIHJldHVybiBodC5zdHJpbmdzO1xuICB9LCBqbiA9IChlLCB0KSA9PiB7XG4gICAgdmFyIHIgPSAwLCBuID0gMDtcbiAgICBmb3IgKHZhciBhIG9mIGh0KCkpIHtcbiAgICAgIHZhciBpID0gdCArIHI7XG4gICAgICBQW2UgKyBuID4+IDJdID0gaSwgciArPSBpdChhLCBpLCAxIC8gMCkgKyAxLCBuICs9IDQ7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LCBSbiA9IChlLCB0KSA9PiB7XG4gICAgdmFyIHIgPSBodCgpO1xuICAgIFBbZSA+PiAyXSA9IHIubGVuZ3RoO1xuICAgIHZhciBuID0gMDtcbiAgICBmb3IgKHZhciBhIG9mIHIpXG4gICAgICBuICs9IGdlKGEpICsgMTtcbiAgICByZXR1cm4gUFt0ID4+IDJdID0gbiwgMDtcbiAgfSwgTG4gPSAoZSkgPT4gNTI7XG4gIGZ1bmN0aW9uIEJuKGUsIHQsIHIsIG4sIGEpIHtcbiAgICByZXR1cm4gNzA7XG4gIH1cbiAgdmFyIFduID0gW251bGwsIFtdLCBbXV0sIFVuID0gKGUsIHQpID0+IHtcbiAgICB2YXIgciA9IFduW2VdO1xuICAgIHQgPT09IDAgfHwgdCA9PT0gMTAgPyAoKGUgPT09IDEgPyBzdCA6IGspKCRlKHIpKSwgci5sZW5ndGggPSAwKSA6IHIucHVzaCh0KTtcbiAgfSwgVm4gPSAoZSwgdCwgciwgbikgPT4ge1xuICAgIGZvciAodmFyIGEgPSAwLCBpID0gMDsgaSA8IHI7IGkrKykge1xuICAgICAgdmFyIHUgPSBQW3QgPj4gMl0sIHMgPSBQW3QgKyA0ID4+IDJdO1xuICAgICAgdCArPSA4O1xuICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBzOyBsKyspXG4gICAgICAgIFVuKGUsIEJbdSArIGxdKTtcbiAgICAgIGEgKz0gcztcbiAgICB9XG4gICAgcmV0dXJuIFBbbiA+PiAyXSA9IGEsIDA7XG4gIH0sIGtuID0gKGUpID0+IGU7XG4gIGJyKCksIF9yKCksIEJyKCksIFhyKCksIGMubm9FeGl0UnVudGltZSAmJiBjLm5vRXhpdFJ1bnRpbWUsIGMucHJpbnQgJiYgKHN0ID0gYy5wcmludCksIGMucHJpbnRFcnIgJiYgKGsgPSBjLnByaW50RXJyKSwgYy53YXNtQmluYXJ5ICYmIChaID0gYy53YXNtQmluYXJ5KSwgYy5hcmd1bWVudHMgJiYgYy5hcmd1bWVudHMsIGMudGhpc1Byb2dyYW0gJiYgKE0gPSBjLnRoaXNQcm9ncmFtKTtcbiAgdmFyIEhuID0ge1xuICAgIHM6IHVyLFxuICAgIHc6IGNyLFxuICAgIGE6IGxyLFxuICAgIGo6IGZyLFxuICAgIG06IGRyLFxuICAgIE46IGhyLFxuICAgIHA6IHByLFxuICAgIGRhOiB2cixcbiAgICBkOiB5cixcbiAgICBfOiBtcixcbiAgICBzYTogd3IsXG4gICAgWjogJHIsXG4gICAgbmE6IFRyLFxuICAgIHFhOiBrcixcbiAgICBwYTogTnIsXG4gICAgRjogenIsXG4gICAgbGE6IHFyLFxuICAgIFI6IFpyLFxuICAgIFM6IFFyLFxuICAgIHk6IEtyLFxuICAgIHQ6IHRuLFxuICAgIHJhOiBybixcbiAgICBtYTogb24sXG4gICAgTzogaG4sXG4gICAgSzogcG4sXG4gICAgdGE6IHZuLFxuICAgIG9hOiB5bixcbiAgICBWOiBtbixcbiAgICB1YTogenQsXG4gICAgd2E6ICRuLFxuICAgICQ6IEVuLFxuICAgIFQ6IF9uLFxuICAgIHZhOiBPbixcbiAgICBrYTogeG4sXG4gICAgYWE6IEFuLFxuICAgIGVhOiBNbixcbiAgICBiYTogam4sXG4gICAgY2E6IFJuLFxuICAgIGZhOiBMbixcbiAgICBYOiBCbixcbiAgICBROiBWbixcbiAgICBJOiBiYSxcbiAgICBDOiBUYSxcbiAgICBVOiBvYSxcbiAgICBQOiBTYSxcbiAgICBxOiBtYSxcbiAgICBiOiBlYSxcbiAgICBEOiAkYSxcbiAgICBpYTogRWEsXG4gICAgYzogbmEsXG4gICAgaGE6IF9hLFxuICAgIGg6IGFhLFxuICAgIGk6IGxhLFxuICAgIHI6IGRhLFxuICAgIE06IHdhLFxuICAgIHY6IHBhLFxuICAgIEU6IHlhLFxuICAgIEo6IGdhLFxuICAgIEE6IFBhLFxuICAgIEg6IElhLFxuICAgIFc6IEZhLFxuICAgIGs6IHNhLFxuICAgIGY6IGlhLFxuICAgIGU6IHJhLFxuICAgIGc6IHRhLFxuICAgIEw6IEFhLFxuICAgIGw6IGNhLFxuICAgIGphOiBDYSxcbiAgICBvOiBoYSxcbiAgICB4OiBmYSxcbiAgICB1OiB2YSxcbiAgICBnYTogeGEsXG4gICAgQjogT2EsXG4gICAgbjogdWEsXG4gICAgRzogRGEsXG4gICAgWTogTWEsXG4gICAgejoga25cbiAgfSwgRSA9IGF3YWl0IG9yKCk7XG4gIEUueWE7XG4gIHZhciBObiA9IEUuemEsIGV0ID0gYy5fZnJlZSA9IEUuQWEsIFBlID0gYy5fbWFsbG9jID0gRS5DYSwgem4gPSBFLkRhLCB2ID0gRS5FYSwgR24gPSBFLkZhLCBYbiA9IEUuR2EsIHFuID0gRS5IYSwgWW4gPSBFLklhLCBabiA9IEUuSmEsIFFuID0gRS5LYTtcbiAgYy5keW5DYWxsX3ZpaWppaSA9IEUuTGE7XG4gIHZhciBKbiA9IGMuZHluQ2FsbF92aWogPSBFLk1hO1xuICBjLmR5bkNhbGxfamlqaSA9IEUuTmE7XG4gIHZhciBLbiA9IGMuZHluQ2FsbF9qaWlpaSA9IEUuT2E7XG4gIGMuZHluQ2FsbF9paWlpaWogPSBFLlBhLCBjLmR5bkNhbGxfaWlpaWlqaiA9IEUuUWEsIGMuZHluQ2FsbF9paWlpaWlqaiA9IEUuUmE7XG4gIGZ1bmN0aW9uIHRhKGUsIHQsIHIsIG4pIHtcbiAgICB2YXIgYSA9IG0oKTtcbiAgICB0cnkge1xuICAgICAgZyhlKSh0LCByLCBuKTtcbiAgICB9IGNhdGNoIChpKSB7XG4gICAgICBpZiAoeShhKSwgaSAhPT0gaSArIDApIHRocm93IGk7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBlYShlLCB0KSB7XG4gICAgdmFyIHIgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnKGUpKHQpO1xuICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgIGlmICh5KHIpLCBuICE9PSBuICsgMCkgdGhyb3cgbjtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJhKGUsIHQsIHIpIHtcbiAgICB2YXIgbiA9IG0oKTtcbiAgICB0cnkge1xuICAgICAgZyhlKSh0LCByKTtcbiAgICB9IGNhdGNoIChhKSB7XG4gICAgICBpZiAoeShuKSwgYSAhPT0gYSArIDApIHRocm93IGE7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBuYShlLCB0LCByKSB7XG4gICAgdmFyIG4gPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnKGUpKHQsIHIpO1xuICAgIH0gY2F0Y2ggKGEpIHtcbiAgICAgIGlmICh5KG4pLCBhICE9PSBhICsgMCkgdGhyb3cgYTtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFhKGUsIHQsIHIsIG4pIHtcbiAgICB2YXIgYSA9IG0oKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGcoZSkodCwgciwgbik7XG4gICAgfSBjYXRjaCAoaSkge1xuICAgICAgaWYgKHkoYSksIGkgIT09IGkgKyAwKSB0aHJvdyBpO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb2EoZSwgdCwgciwgbiwgYSkge1xuICAgIHZhciBpID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZyhlKSh0LCByLCBuLCBhKTtcbiAgICB9IGNhdGNoICh1KSB7XG4gICAgICBpZiAoeShpKSwgdSAhPT0gdSArIDApIHRocm93IHU7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpYShlLCB0KSB7XG4gICAgdmFyIHIgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIGcoZSkodCk7XG4gICAgfSBjYXRjaCAobikge1xuICAgICAgaWYgKHkociksIG4gIT09IG4gKyAwKSB0aHJvdyBuO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2EoZSkge1xuICAgIHZhciB0ID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICBnKGUpKCk7XG4gICAgfSBjYXRjaCAocikge1xuICAgICAgaWYgKHkodCksIHIgIT09IHIgKyAwKSB0aHJvdyByO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdWEoZSwgdCwgciwgbiwgYSwgaSwgdSwgcywgbCwgZCwgaCkge1xuICAgIHZhciBwID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICBnKGUpKHQsIHIsIG4sIGEsIGksIHUsIHMsIGwsIGQsIGgpO1xuICAgIH0gY2F0Y2ggKHcpIHtcbiAgICAgIGlmICh5KHApLCB3ICE9PSB3ICsgMCkgdGhyb3cgdztcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNhKGUsIHQsIHIsIG4sIGEpIHtcbiAgICB2YXIgaSA9IG0oKTtcbiAgICB0cnkge1xuICAgICAgZyhlKSh0LCByLCBuLCBhKTtcbiAgICB9IGNhdGNoICh1KSB7XG4gICAgICBpZiAoeShpKSwgdSAhPT0gdSArIDApIHRocm93IHU7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBsYShlLCB0LCByLCBuLCBhKSB7XG4gICAgdmFyIGkgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnKGUpKHQsIHIsIG4sIGEpO1xuICAgIH0gY2F0Y2ggKHUpIHtcbiAgICAgIGlmICh5KGkpLCB1ICE9PSB1ICsgMCkgdGhyb3cgdTtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGZhKGUsIHQsIHIsIG4sIGEsIGksIHUpIHtcbiAgICB2YXIgcyA9IG0oKTtcbiAgICB0cnkge1xuICAgICAgZyhlKSh0LCByLCBuLCBhLCBpLCB1KTtcbiAgICB9IGNhdGNoIChsKSB7XG4gICAgICBpZiAoeShzKSwgbCAhPT0gbCArIDApIHRocm93IGw7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkYShlLCB0LCByLCBuLCBhLCBpKSB7XG4gICAgdmFyIHUgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnKGUpKHQsIHIsIG4sIGEsIGkpO1xuICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgIGlmICh5KHUpLCBzICE9PSBzICsgMCkgdGhyb3cgcztcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhKGUsIHQsIHIsIG4sIGEsIGkpIHtcbiAgICB2YXIgdSA9IG0oKTtcbiAgICB0cnkge1xuICAgICAgZyhlKSh0LCByLCBuLCBhLCBpKTtcbiAgICB9IGNhdGNoIChzKSB7XG4gICAgICBpZiAoeSh1KSwgcyAhPT0gcyArIDApIHRocm93IHM7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwYShlLCB0LCByLCBuLCBhLCBpLCB1KSB7XG4gICAgdmFyIHMgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnKGUpKHQsIHIsIG4sIGEsIGksIHUpO1xuICAgIH0gY2F0Y2ggKGwpIHtcbiAgICAgIGlmICh5KHMpLCBsICE9PSBsICsgMCkgdGhyb3cgbDtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHZhKGUsIHQsIHIsIG4sIGEsIGksIHUsIHMpIHtcbiAgICB2YXIgbCA9IG0oKTtcbiAgICB0cnkge1xuICAgICAgZyhlKSh0LCByLCBuLCBhLCBpLCB1LCBzKTtcbiAgICB9IGNhdGNoIChkKSB7XG4gICAgICBpZiAoeShsKSwgZCAhPT0gZCArIDApIHRocm93IGQ7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB5YShlLCB0LCByLCBuLCBhLCBpLCB1LCBzKSB7XG4gICAgdmFyIGwgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnKGUpKHQsIHIsIG4sIGEsIGksIHUsIHMpO1xuICAgIH0gY2F0Y2ggKGQpIHtcbiAgICAgIGlmICh5KGwpLCBkICE9PSBkICsgMCkgdGhyb3cgZDtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1hKGUpIHtcbiAgICB2YXIgdCA9IG0oKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGcoZSkoKTtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICBpZiAoeSh0KSwgciAhPT0gciArIDApIHRocm93IHI7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnYShlLCB0LCByLCBuLCBhLCBpLCB1LCBzLCBsKSB7XG4gICAgdmFyIGQgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnKGUpKHQsIHIsIG4sIGEsIGksIHUsIHMsIGwpO1xuICAgIH0gY2F0Y2ggKGgpIHtcbiAgICAgIGlmICh5KGQpLCBoICE9PSBoICsgMCkgdGhyb3cgaDtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHdhKGUsIHQsIHIsIG4sIGEsIGksIHUpIHtcbiAgICB2YXIgcyA9IG0oKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGcoZSkodCwgciwgbiwgYSwgaSwgdSk7XG4gICAgfSBjYXRjaCAobCkge1xuICAgICAgaWYgKHkocyksIGwgIT09IGwgKyAwKSB0aHJvdyBsO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gJGEoZSwgdCwgciwgbikge1xuICAgIHZhciBhID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZyhlKSh0LCByLCBuKTtcbiAgICB9IGNhdGNoIChpKSB7XG4gICAgICBpZiAoeShhKSwgaSAhPT0gaSArIDApIHRocm93IGk7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBiYShlLCB0LCByLCBuKSB7XG4gICAgdmFyIGEgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnKGUpKHQsIHIsIG4pO1xuICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgIGlmICh5KGEpLCBpICE9PSBpICsgMCkgdGhyb3cgaTtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIENhKGUsIHQsIHIsIG4sIGEsIGksIHUsIHMpIHtcbiAgICB2YXIgbCA9IG0oKTtcbiAgICB0cnkge1xuICAgICAgZyhlKSh0LCByLCBuLCBhLCBpLCB1LCBzKTtcbiAgICB9IGNhdGNoIChkKSB7XG4gICAgICBpZiAoeShsKSwgZCAhPT0gZCArIDApIHRocm93IGQ7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBUYShlLCB0LCByLCBuLCBhLCBpKSB7XG4gICAgdmFyIHUgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnKGUpKHQsIHIsIG4sIGEsIGkpO1xuICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgIGlmICh5KHUpLCBzICE9PSBzICsgMCkgdGhyb3cgcztcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIFBhKGUsIHQsIHIsIG4sIGEsIGksIHUsIHMsIGwsIGQpIHtcbiAgICB2YXIgaCA9IG0oKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGcoZSkodCwgciwgbiwgYSwgaSwgdSwgcywgbCwgZCk7XG4gICAgfSBjYXRjaCAocCkge1xuICAgICAgaWYgKHkoaCksIHAgIT09IHAgKyAwKSB0aHJvdyBwO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gRWEoZSwgdCwgcikge1xuICAgIHZhciBuID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZyhlKSh0LCByKTtcbiAgICB9IGNhdGNoIChhKSB7XG4gICAgICBpZiAoeShuKSwgYSAhPT0gYSArIDApIHRocm93IGE7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfYShlLCB0LCByLCBuLCBhKSB7XG4gICAgdmFyIGkgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnKGUpKHQsIHIsIG4sIGEpO1xuICAgIH0gY2F0Y2ggKHUpIHtcbiAgICAgIGlmICh5KGkpLCB1ICE9PSB1ICsgMCkgdGhyb3cgdTtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIE9hKGUsIHQsIHIsIG4sIGEsIGksIHUsIHMsIGwsIGQpIHtcbiAgICB2YXIgaCA9IG0oKTtcbiAgICB0cnkge1xuICAgICAgZyhlKSh0LCByLCBuLCBhLCBpLCB1LCBzLCBsLCBkKTtcbiAgICB9IGNhdGNoIChwKSB7XG4gICAgICBpZiAoeShoKSwgcCAhPT0gcCArIDApIHRocm93IHA7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB4YShlLCB0LCByLCBuLCBhLCBpLCB1LCBzLCBsKSB7XG4gICAgdmFyIGQgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIGcoZSkodCwgciwgbiwgYSwgaSwgdSwgcywgbCk7XG4gICAgfSBjYXRjaCAoaCkge1xuICAgICAgaWYgKHkoZCksIGggIT09IGggKyAwKSB0aHJvdyBoO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gQWEoZSwgdCwgciwgbiwgYSwgaSwgdSkge1xuICAgIHZhciBzID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICBnKGUpKHQsIHIsIG4sIGEsIGksIHUpO1xuICAgIH0gY2F0Y2ggKGwpIHtcbiAgICAgIGlmICh5KHMpLCBsICE9PSBsICsgMCkgdGhyb3cgbDtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIFNhKGUsIHQsIHIsIG4pIHtcbiAgICB2YXIgYSA9IG0oKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGcoZSkodCwgciwgbik7XG4gICAgfSBjYXRjaCAoaSkge1xuICAgICAgaWYgKHkoYSksIGkgIT09IGkgKyAwKSB0aHJvdyBpO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gSWEoZSwgdCwgciwgbiwgYSwgaSwgdSwgcywgbCwgZCwgaCwgcCkge1xuICAgIHZhciB3ID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZyhlKSh0LCByLCBuLCBhLCBpLCB1LCBzLCBsLCBkLCBoLCBwKTtcbiAgICB9IGNhdGNoIChiKSB7XG4gICAgICBpZiAoeSh3KSwgYiAhPT0gYiArIDApIHRocm93IGI7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBEYShlLCB0LCByLCBuLCBhLCBpLCB1LCBzLCBsLCBkLCBoLCBwLCB3LCBiLCBfLCBTKSB7XG4gICAgdmFyIEEgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIGcoZSkodCwgciwgbiwgYSwgaSwgdSwgcywgbCwgZCwgaCwgcCwgdywgYiwgXywgUyk7XG4gICAgfSBjYXRjaCAoSSkge1xuICAgICAgaWYgKHkoQSksIEkgIT09IEkgKyAwKSB0aHJvdyBJO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gTWEoZSwgdCwgciwgbikge1xuICAgIHZhciBhID0gbSgpO1xuICAgIHRyeSB7XG4gICAgICBKbihlLCB0LCByLCBuKTtcbiAgICB9IGNhdGNoIChpKSB7XG4gICAgICBpZiAoeShhKSwgaSAhPT0gaSArIDApIHRocm93IGk7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBGYShlLCB0LCByLCBuLCBhKSB7XG4gICAgdmFyIGkgPSBtKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBLbihlLCB0LCByLCBuLCBhKTtcbiAgICB9IGNhdGNoICh1KSB7XG4gICAgICBpZiAoeShpKSwgdSAhPT0gdSArIDApIHRocm93IHU7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBxdCgpIHtcbiAgICBpZiAoSiA+IDApIHtcbiAgICAgIGN0ID0gcXQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChxZSgpLCBKID4gMCkge1xuICAgICAgY3QgPSBxdDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgIHZhciB0O1xuICAgICAgYy5jYWxsZWRSdW4gPSAhMCwgIUp0ICYmIChZZSgpLCBUKGMpLCAodCA9IGMub25SdW50aW1lSW5pdGlhbGl6ZWQpID09PSBudWxsIHx8IHQgPT09IHZvaWQgMCB8fCB0LmNhbGwoYyksIFplKCkpO1xuICAgIH1cbiAgICBjLnNldFN0YXR1cyA/IChjLnNldFN0YXR1cyhcIlJ1bm5pbmcuLi5cIiksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBjLnNldFN0YXR1cyhcIlwiKSwgMSksIGUoKTtcbiAgICB9LCAxKSkgOiBlKCk7XG4gIH1cbiAgZnVuY3Rpb24gamEoKSB7XG4gICAgaWYgKGMucHJlSW5pdClcbiAgICAgIGZvciAodHlwZW9mIGMucHJlSW5pdCA9PSBcImZ1bmN0aW9uXCIgJiYgKGMucHJlSW5pdCA9IFtjLnByZUluaXRdKTsgYy5wcmVJbml0Lmxlbmd0aCA+IDA7IClcbiAgICAgICAgYy5wcmVJbml0LnNoaWZ0KCkoKTtcbiAgfVxuICByZXR1cm4gamEoKSwgcXQoKSwgZiA9IHgsIGY7XG59O1xuZnVuY3Rpb24gQmUobykge1xuICByZXR1cm4gTGUoUXQsIG8pO1xufVxuZnVuY3Rpb24gQ28oKSB7XG4gIHJldHVybiBLYShRdCk7XG59XG5mdW5jdGlvbiBUbyhvKSB7XG4gIEJlKHtcbiAgICBvdmVycmlkZXM6IG8sXG4gICAgZXF1YWxpdHlGbjogT2JqZWN0LmlzLFxuICAgIGZpcmVJbW1lZGlhdGVseTogITFcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBlbyhvLCBmKSB7XG4gIHJldHVybiB0byhRdCwgbywgZik7XG59XG5jb25zdCBQbyA9IFwiM2MwNzAyN2RiZmQ2ZGE0NzMzMGFjMThlNzRlNjkyNDAxOWQ5YWM5YTRjMWUxNjFiODAwNjY2ZjllM2M5MjVjYVwiLCBXZSA9IFtcbiAgW1wiYXp0ZWNcIiwgXCJBenRlY1wiXSxcbiAgW1wiY29kZV8xMjhcIiwgXCJDb2RlMTI4XCJdLFxuICBbXCJjb2RlXzM5XCIsIFwiQ29kZTM5XCJdLFxuICBbXCJjb2RlXzkzXCIsIFwiQ29kZTkzXCJdLFxuICBbXCJjb2RhYmFyXCIsIFwiQ29kYWJhclwiXSxcbiAgW1wiZGF0YWJhclwiLCBcIkRhdGFCYXJcIl0sXG4gIFtcImRhdGFiYXJfZXhwYW5kZWRcIiwgXCJEYXRhQmFyRXhwYW5kZWRcIl0sXG4gIFtcImRhdGFiYXJfbGltaXRlZFwiLCBcIkRhdGFCYXJMaW1pdGVkXCJdLFxuICBbXCJkYXRhX21hdHJpeFwiLCBcIkRhdGFNYXRyaXhcIl0sXG4gIFtcImR4X2ZpbG1fZWRnZVwiLCBcIkRYRmlsbUVkZ2VcIl0sXG4gIFtcImVhbl8xM1wiLCBcIkVBTi0xM1wiXSxcbiAgW1wiZWFuXzhcIiwgXCJFQU4tOFwiXSxcbiAgW1wiaXRmXCIsIFwiSVRGXCJdLFxuICBbXCJtYXhpX2NvZGVcIiwgXCJNYXhpQ29kZVwiXSxcbiAgW1wibWljcm9fcXJfY29kZVwiLCBcIk1pY3JvUVJDb2RlXCJdLFxuICBbXCJwZGY0MTdcIiwgXCJQREY0MTdcIl0sXG4gIFtcInFyX2NvZGVcIiwgXCJRUkNvZGVcIl0sXG4gIFtcInJtX3FyX2NvZGVcIiwgXCJyTVFSQ29kZVwiXSxcbiAgW1widXBjX2FcIiwgXCJVUEMtQVwiXSxcbiAgW1widXBjX2VcIiwgXCJVUEMtRVwiXSxcbiAgW1wibGluZWFyX2NvZGVzXCIsIFwiTGluZWFyLUNvZGVzXCJdLFxuICBbXCJtYXRyaXhfY29kZXNcIiwgXCJNYXRyaXgtQ29kZXNcIl0sXG4gIFtcImFueVwiLCBcIkFueVwiXVxuXSwgcm8gPSBbLi4uV2UsIFtcInVua25vd25cIl1dLm1hcCgobykgPT4gb1swXSksIFp0ID0gbmV3IE1hcChcbiAgV2Vcbik7XG5mdW5jdGlvbiBubyhvKSB7XG4gIGZvciAoY29uc3QgW2YsIGNdIG9mIFp0KVxuICAgIGlmIChvID09PSBjKVxuICAgICAgcmV0dXJuIGY7XG4gIHJldHVybiBcInVua25vd25cIjtcbn1cbmZ1bmN0aW9uIGFvKG8pIHtcbiAgaWYgKFVlKG8pKVxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogby5uYXR1cmFsV2lkdGgsXG4gICAgICBoZWlnaHQ6IG8ubmF0dXJhbEhlaWdodFxuICAgIH07XG4gIGlmIChWZShvKSlcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IG8ud2lkdGguYmFzZVZhbC52YWx1ZSxcbiAgICAgIGhlaWdodDogby5oZWlnaHQuYmFzZVZhbC52YWx1ZVxuICAgIH07XG4gIGlmIChrZShvKSlcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IG8udmlkZW9XaWR0aCxcbiAgICAgIGhlaWdodDogby52aWRlb0hlaWdodFxuICAgIH07XG4gIGlmIChOZShvKSlcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IG8ud2lkdGgsXG4gICAgICBoZWlnaHQ6IG8uaGVpZ2h0XG4gICAgfTtcbiAgaWYgKEdlKG8pKVxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogby5kaXNwbGF5V2lkdGgsXG4gICAgICBoZWlnaHQ6IG8uZGlzcGxheUhlaWdodFxuICAgIH07XG4gIGlmIChIZShvKSlcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IG8ud2lkdGgsXG4gICAgICBoZWlnaHQ6IG8uaGVpZ2h0XG4gICAgfTtcbiAgaWYgKHplKG8pKVxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogby53aWR0aCxcbiAgICAgIGhlaWdodDogby5oZWlnaHRcbiAgICB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgIFwiVGhlIHByb3ZpZGVkIHZhbHVlIGlzIG5vdCBvZiB0eXBlICcoQmxvYiBvciBIVE1MQ2FudmFzRWxlbWVudCBvciBIVE1MSW1hZ2VFbGVtZW50IG9yIEhUTUxWaWRlb0VsZW1lbnQgb3IgSW1hZ2VCaXRtYXAgb3IgSW1hZ2VEYXRhIG9yIE9mZnNjcmVlbkNhbnZhcyBvciBTVkdJbWFnZUVsZW1lbnQgb3IgVmlkZW9GcmFtZSknLlwiXG4gICk7XG59XG5mdW5jdGlvbiBVZShvKSB7XG4gIHZhciBmLCBjO1xuICB0cnkge1xuICAgIHJldHVybiBvIGluc3RhbmNlb2YgKChjID0gKGYgPSBvID09IG51bGwgPyB2b2lkIDAgOiBvLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBmLmRlZmF1bHRWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogYy5IVE1MSW1hZ2VFbGVtZW50KTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBWZShvKSB7XG4gIHZhciBmLCBjO1xuICB0cnkge1xuICAgIHJldHVybiBvIGluc3RhbmNlb2YgKChjID0gKGYgPSBvID09IG51bGwgPyB2b2lkIDAgOiBvLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBmLmRlZmF1bHRWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogYy5TVkdJbWFnZUVsZW1lbnQpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmZ1bmN0aW9uIGtlKG8pIHtcbiAgdmFyIGYsIGM7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG8gaW5zdGFuY2VvZiAoKGMgPSAoZiA9IG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8ub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IGYuZGVmYXVsdFZpZXcpID09IG51bGwgPyB2b2lkIDAgOiBjLkhUTUxWaWRlb0VsZW1lbnQpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmZ1bmN0aW9uIEhlKG8pIHtcbiAgdmFyIGYsIGM7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG8gaW5zdGFuY2VvZiAoKGMgPSAoZiA9IG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8ub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IGYuZGVmYXVsdFZpZXcpID09IG51bGwgPyB2b2lkIDAgOiBjLkhUTUxDYW52YXNFbGVtZW50KTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBOZShvKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG8gaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBJbWFnZUJpdG1hcF1cIjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiB6ZShvKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG8gaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSBcIltvYmplY3QgT2Zmc2NyZWVuQ2FudmFzXVwiO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmZ1bmN0aW9uIEdlKG8pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbyBpbnN0YW5jZW9mIFZpZGVvRnJhbWUgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSBcIltvYmplY3QgVmlkZW9GcmFtZV1cIjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBvbyhvKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG8gaW5zdGFuY2VvZiBCbG9iIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gXCJbb2JqZWN0IEJsb2JdXCI7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gaW8obykge1xuICB0cnkge1xuICAgIHJldHVybiBvIGluc3RhbmNlb2YgSW1hZ2VEYXRhIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gXCJbb2JqZWN0IEltYWdlRGF0YV1cIjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBzbyhvLCBmKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgYyA9IG5ldyBPZmZzY3JlZW5DYW52YXMobywgZik7XG4gICAgaWYgKGMuZ2V0Q29udGV4dChcIjJkXCIpIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKVxuICAgICAgcmV0dXJuIGM7XG4gICAgdGhyb3cgdm9pZCAwO1xuICB9IGNhdGNoIHtcbiAgICBjb25zdCBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICByZXR1cm4gYy53aWR0aCA9IG8sIGMuaGVpZ2h0ID0gZiwgYztcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gWGUobykge1xuICBpZiAoVWUobykgJiYgIWF3YWl0IGZvKG8pKVxuICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXG4gICAgICBcIkZhaWxlZCB0byBsb2FkIG9yIGRlY29kZSBIVE1MSW1hZ2VFbGVtZW50LlwiLFxuICAgICAgXCJJbnZhbGlkU3RhdGVFcnJvclwiXG4gICAgKTtcbiAgaWYgKFZlKG8pICYmICFhd2FpdCBobyhvKSlcbiAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgXCJGYWlsZWQgdG8gbG9hZCBvciBkZWNvZGUgU1ZHSW1hZ2VFbGVtZW50LlwiLFxuICAgICAgXCJJbnZhbGlkU3RhdGVFcnJvclwiXG4gICAgKTtcbiAgaWYgKEdlKG8pICYmIHBvKG8pKVxuICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJWaWRlb0ZyYW1lIGlzIGNsb3NlZC5cIiwgXCJJbnZhbGlkU3RhdGVFcnJvclwiKTtcbiAgaWYgKGtlKG8pICYmIChvLnJlYWR5U3RhdGUgPT09IDAgfHwgby5yZWFkeVN0YXRlID09PSAxKSlcbiAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiSW52YWxpZCBlbGVtZW50IG9yIHN0YXRlLlwiLCBcIkludmFsaWRTdGF0ZUVycm9yXCIpO1xuICBpZiAoTmUobykgJiYgeW8obykpXG4gICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcbiAgICAgIFwiVGhlIGltYWdlIHNvdXJjZSBpcyBkZXRhY2hlZC5cIixcbiAgICAgIFwiSW52YWxpZFN0YXRlRXJyb3JcIlxuICAgICk7XG4gIGNvbnN0IHsgd2lkdGg6IGYsIGhlaWdodDogYyB9ID0gYW8obyk7XG4gIGlmIChmID09PSAwIHx8IGMgPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0ICQgPSBzbyhmLCBjKS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICQuZHJhd0ltYWdlKG8sIDAsIDApO1xuICB0cnkge1xuICAgIHJldHVybiAkLmdldEltYWdlRGF0YSgwLCAwLCBmLCBjKTtcbiAgfSBjYXRjaCB7XG4gICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIlNvdXJjZSB3b3VsZCB0YWludCBvcmlnaW4uXCIsIFwiU2VjdXJpdHlFcnJvclwiKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gdW8obykge1xuICBsZXQgZjtcbiAgdHJ5IHtcbiAgICBmID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAobyk7XG4gIH0gY2F0Y2gge1xuICAgIHRyeSB7XG4gICAgICBpZiAoZ2xvYmFsVGhpcy5JbWFnZSkge1xuICAgICAgICBmID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGxldCAkID0gXCJcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAkID0gVVJMLmNyZWF0ZU9iamVjdFVSTChvKSwgZi5zcmMgPSAkLCBhd2FpdCBmLmRlY29kZSgpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoJCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gbztcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXG4gICAgICAgIFwiRmFpbGVkIHRvIGxvYWQgb3IgZGVjb2RlIEJsb2IuXCIsXG4gICAgICAgIFwiSW52YWxpZFN0YXRlRXJyb3JcIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGF3YWl0IFhlKGYpO1xufVxuZnVuY3Rpb24gY28obykge1xuICBjb25zdCB7IHdpZHRoOiBmLCBoZWlnaHQ6IGMgfSA9IG87XG4gIGlmIChmID09PSAwIHx8IGMgPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IFQgPSBvLmdldENvbnRleHQoXCIyZFwiKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gVC5nZXRJbWFnZURhdGEoMCwgMCwgZiwgYyk7XG4gIH0gY2F0Y2gge1xuICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJTb3VyY2Ugd291bGQgdGFpbnQgb3JpZ2luLlwiLCBcIlNlY3VyaXR5RXJyb3JcIik7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGxvKG8pIHtcbiAgaWYgKG9vKG8pKVxuICAgIHJldHVybiBhd2FpdCB1byhvKTtcbiAgaWYgKGlvKG8pKSB7XG4gICAgaWYgKHZvKG8pKVxuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcbiAgICAgICAgXCJUaGUgaW1hZ2UgZGF0YSBoYXMgYmVlbiBkZXRhY2hlZC5cIixcbiAgICAgICAgXCJJbnZhbGlkU3RhdGVFcnJvclwiXG4gICAgICApO1xuICAgIHJldHVybiBvO1xuICB9XG4gIHJldHVybiBIZShvKSB8fCB6ZShvKSA/IGNvKG8pIDogYXdhaXQgWGUobyk7XG59XG5hc3luYyBmdW5jdGlvbiBmbyhvKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IG8uZGVjb2RlKCksICEwO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGhvKG8pIHtcbiAgdmFyIGY7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0ICgoZiA9IG8uZGVjb2RlKSA9PSBudWxsID8gdm9pZCAwIDogZi5jYWxsKG8pKSwgITA7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gcG8obykge1xuICByZXR1cm4gby5mb3JtYXQgPT09IG51bGw7XG59XG5mdW5jdGlvbiB2byhvKSB7XG4gIHJldHVybiBvLmRhdGEuYnVmZmVyLmJ5dGVMZW5ndGggPT09IDA7XG59XG5mdW5jdGlvbiB5byhvKSB7XG4gIHJldHVybiBvLndpZHRoID09PSAwICYmIG8uaGVpZ2h0ID09PSAwO1xufVxuZnVuY3Rpb24gUmUobywgZikge1xuICByZXR1cm4gbW8obykgPyBuZXcgRE9NRXhjZXB0aW9uKGAke2Z9OiAke28ubWVzc2FnZX1gLCBvLm5hbWUpIDogZ28obykgPyBuZXcgby5jb25zdHJ1Y3RvcihgJHtmfTogJHtvLm1lc3NhZ2V9YCkgOiBuZXcgRXJyb3IoYCR7Zn06ICR7b31gKTtcbn1cbmZ1bmN0aW9uIG1vKG8pIHtcbiAgcmV0dXJuIG8gaW5zdGFuY2VvZiBET01FeGNlcHRpb24gfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSBcIltvYmplY3QgRE9NRXhjZXB0aW9uXVwiO1xufVxuZnVuY3Rpb24gZ28obykge1xuICByZXR1cm4gbyBpbnN0YW5jZW9mIEVycm9yIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gXCJbb2JqZWN0IEVycm9yXVwiO1xufVxudmFyIHB0O1xuY2xhc3MgRW8ge1xuICBjb25zdHJ1Y3RvcihmID0ge30pIHtcbiAgICBEZSh0aGlzLCBwdCk7XG4gICAgdmFyIGM7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IFQgPSAoYyA9IGYgPT0gbnVsbCA/IHZvaWQgMCA6IGYuZm9ybWF0cykgPT0gbnVsbCA/IHZvaWQgMCA6IGMuZmlsdGVyKFxuICAgICAgICAoJCkgPT4gJCAhPT0gXCJ1bmtub3duXCJcbiAgICAgICk7XG4gICAgICBpZiAoKFQgPT0gbnVsbCA/IHZvaWQgMCA6IFQubGVuZ3RoKSA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkhpbnQgb3B0aW9uIHByb3ZpZGVkLCBidXQgaXMgZW1wdHkuXCIpO1xuICAgICAgZm9yIChjb25zdCAkIG9mIFQgIT0gbnVsbCA/IFQgOiBbXSlcbiAgICAgICAgaWYgKCFadC5oYXMoJCkpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gcmVhZCB0aGUgJ2Zvcm1hdHMnIHByb3BlcnR5IGZyb20gJ0JhcmNvZGVEZXRlY3Rvck9wdGlvbnMnOiBUaGUgcHJvdmlkZWQgdmFsdWUgJyR7JH0nIGlzIG5vdCBhIHZhbGlkIGVudW0gdmFsdWUgb2YgdHlwZSBCYXJjb2RlRm9ybWF0LmBcbiAgICAgICAgICApO1xuICAgICAgTWUodGhpcywgcHQsIFQgIT0gbnVsbCA/IFQgOiBbXSksIEJlKHsgZmlyZUltbWVkaWF0ZWx5OiAhMCB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChUKSB7XG4gICAgICB0aHJvdyBSZShcbiAgICAgICAgVCxcbiAgICAgICAgXCJGYWlsZWQgdG8gY29uc3RydWN0ICdCYXJjb2RlRGV0ZWN0b3InXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBhc3luYyBnZXRTdXBwb3J0ZWRGb3JtYXRzKCkge1xuICAgIHJldHVybiByby5maWx0ZXIoKGYpID0+IGYgIT09IFwidW5rbm93blwiKTtcbiAgfVxuICBhc3luYyBkZXRlY3QoZikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjID0gYXdhaXQgbG8oZik7XG4gICAgICBpZiAoYyA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgbGV0IFQ7XG4gICAgICBjb25zdCAkID0ge1xuICAgICAgICB0cnlDb2RlMzlFeHRlbmRlZE1vZGU6ICExLFxuICAgICAgICB0ZXh0TW9kZTogXCJQbGFpblwiLFxuICAgICAgICBmb3JtYXRzOiBJZSh0aGlzLCBwdCkubWFwKCh4KSA9PiBadC5nZXQoeCkpXG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgVCA9IGF3YWl0IGVvKGMsICQpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB0aHJvdyBjb25zb2xlLmVycm9yKHgpLCBuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgICAgIFwiQmFyY29kZSBkZXRlY3Rpb24gc2VydmljZSB1bmF2YWlsYWJsZS5cIixcbiAgICAgICAgICBcIk5vdFN1cHBvcnRlZEVycm9yXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBULm1hcCgoeCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdG9wTGVmdDogeyB4OiBELCB5OiBSIH0sXG4gICAgICAgICAgdG9wUmlnaHQ6IHsgeDogTywgeTogTSB9LFxuICAgICAgICAgIGJvdHRvbUxlZnQ6IHsgeDogRiwgeTogcSB9LFxuICAgICAgICAgIGJvdHRvbVJpZ2h0OiB7IHg6IHJ0LCB5OiBZIH1cbiAgICAgICAgfSA9IHgucG9zaXRpb24sIHN0ID0gTWF0aC5taW4oRCwgTywgRiwgcnQpLCBrID0gTWF0aC5taW4oUiwgTSwgcSwgWSksIFogPSBNYXRoLm1heChELCBPLCBGLCBydCksIG50ID0gTWF0aC5tYXgoUiwgTSwgcSwgWSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYm91bmRpbmdCb3g6IG5ldyBET01SZWN0UmVhZE9ubHkoXG4gICAgICAgICAgICBzdCxcbiAgICAgICAgICAgIGssXG4gICAgICAgICAgICBaIC0gc3QsXG4gICAgICAgICAgICBudCAtIGtcbiAgICAgICAgICApLFxuICAgICAgICAgIHJhd1ZhbHVlOiB4LnRleHQsXG4gICAgICAgICAgZm9ybWF0OiBubyh4LmZvcm1hdCksXG4gICAgICAgICAgY29ybmVyUG9pbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IEQsXG4gICAgICAgICAgICAgIHk6IFJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IE8sXG4gICAgICAgICAgICAgIHk6IE1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IHJ0LFxuICAgICAgICAgICAgICB5OiBZXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiBGLFxuICAgICAgICAgICAgICB5OiBxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoYykge1xuICAgICAgdGhyb3cgUmUoXG4gICAgICAgIGMsXG4gICAgICAgIFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ2RldGVjdCcgb24gJ0JhcmNvZGVEZXRlY3RvcidcIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbnB0ID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCB7XG4gIEVvIGFzIEJhcmNvZGVEZXRlY3RvcixcbiAgYm8gYXMgWlhJTkdfQ1BQX0NPTU1JVCxcbiAgUG8gYXMgWlhJTkdfV0FTTV9TSEEyNTYsXG4gICRvIGFzIFpYSU5HX1dBU01fVkVSU0lPTixcbiAgQmUgYXMgcHJlcGFyZVpYaW5nTW9kdWxlLFxuICBDbyBhcyBwdXJnZVpYaW5nTW9kdWxlLFxuICBUbyBhcyBzZXRaWGluZ01vZHVsZU92ZXJyaWRlc1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/barcode-detector/dist/es/ponyfill.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!**************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \**************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/page.tsx */ \"(app-pages-browser)/./app/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGaG9tZSUyRnJ1bm5lciUyRndvcmtzcGFjZSUyRmFwcCUyRnBhZ2UudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsc0pBQXdFIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL2FwcC9wYWdlLnRzeFwiKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return type.displayName || \"Context\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, props, owner, debugStack, debugTask) {\n      var refProp = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== refProp ? refProp : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        maybeKey,\n        getOwner(),\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      react_stack_bottom_frame: function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (type, config, maybeKey, isStaticChildren) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsc0dBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCLElBQUksY0FBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0VcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgICBjYXNlIFJFQUNUX0FDVElWSVRZX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiQWN0aXZpdHlcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgdmFyIGlubmVyVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICB0eXBlIHx8XG4gICAgICAgICAgICAgICgodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgKHR5cGUgPSBcIlwiICE9PSB0eXBlID8gXCJGb3J3YXJkUmVmKFwiICsgdHlwZSArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgID8gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITA7XG4gICAgICB9XG4gICAgICBpZiAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGNvbnNvbGU7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuZXJyb3I7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPVxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTeW1ib2wgJiZcbiAgICAgICAgICAgIFN5bWJvbC50b1N0cmluZ1RhZyAmJlxuICAgICAgICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSkgfHxcbiAgICAgICAgICB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8XG4gICAgICAgICAgXCJPYmplY3RcIjtcbiAgICAgICAgSlNDb21waWxlcl90ZW1wX2NvbnN0LmNhbGwoXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LFxuICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRhc2tOYW1lKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSByZXR1cm4gXCI8PlwiO1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRVxuICAgICAgKVxuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHJldHVybiBuYW1lID8gXCI8XCIgKyBuYW1lICsgXCI+XCIgOiBcIjwuLi4+XCI7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBcIjwuLi4+XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE93bmVyKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICAgICAgcmV0dXJuIG51bGwgPT09IGRpc3BhdGNoZXIgPyBudWxsIDogZGlzcGF0Y2hlci5nZXRPd25lcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVbmtub3duT3duZXIoKSB7XG4gICAgICByZXR1cm4gRXJyb3IoXCJyZWFjdC1zdGFjay10b3AtZnJhbWVcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gd2FybkFib3V0QWNjZXNzaW5nS2V5KCkge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biB8fFxuICAgICAgICAgICgoc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gITA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRoaXMudHlwZSk7XG4gICAgICBkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICgoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxuICAgICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcHJvcHMsIG93bmVyLCBkZWJ1Z1N0YWNrLCBkZWJ1Z1Rhc2spIHtcbiAgICAgIHZhciByZWZQcm9wID0gcHJvcHMucmVmO1xuICAgICAgdHlwZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgX293bmVyOiBvd25lclxuICAgICAgfTtcbiAgICAgIG51bGwgIT09ICh2b2lkIDAgIT09IHJlZlByb3AgPyByZWZQcm9wIDogbnVsbClcbiAgICAgICAgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICBnZXQ6IGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwgeyBlbnVtZXJhYmxlOiAhMSwgdmFsdWU6IG51bGwgfSk7XG4gICAgICB0eXBlLl9zdG9yZSA9IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z0luZm9cIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdTdGFja1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1N0YWNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1Rhc2tcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogZGVidWdUYXNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgZGVidWdTdGFjayxcbiAgICAgIGRlYnVnVGFza1xuICAgICkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gY29uZmlnLmNoaWxkcmVuO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPSAwO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuIDwgY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baXNTdGF0aWNDaGlsZHJlbl0pO1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICBlbHNlIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuKTtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgICAgbWF5YmVLZXkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcbiAgICAgIGNoaWxkcmVuICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIG1heWJlS2V5LFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIG1heWJlS2V5LFxuICAgICAgICBnZXRPd25lcigpLFxuICAgICAgICBkZWJ1Z1N0YWNrLFxuICAgICAgICBkZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUpIHtcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmXG4gICAgICAgIG51bGwgIT09IG5vZGUgJiZcbiAgICAgICAgbm9kZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFICYmXG4gICAgICAgIG5vZGUuX3N0b3JlICYmXG4gICAgICAgIChub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSAxKTtcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSxcbiAgICAgIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfQUNUSVZJVFlfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5hY3Rpdml0eVwiKSxcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzID1cbiAgICAgICAgUmVhY3QuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5LFxuICAgICAgY3JlYXRlVGFzayA9IGNvbnNvbGUuY3JlYXRlVGFza1xuICAgICAgICA/IGNvbnNvbGUuY3JlYXRlVGFza1xuICAgICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH07XG4gICAgUmVhY3QgPSB7XG4gICAgICByZWFjdF9zdGFja19ib3R0b21fZnJhbWU6IGZ1bmN0aW9uIChjYWxsU3RhY2tGb3JFcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbFN0YWNrRm9yRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbiAgICB2YXIgZGlkV2FybkFib3V0RWxlbWVudFJlZiA9IHt9O1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1N0YWNrID0gUmVhY3QucmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lLmJpbmQoXG4gICAgICBSZWFjdCxcbiAgICAgIFVua25vd25Pd25lclxuICAgICkoKTtcbiAgICB2YXIgdW5rbm93bk93bmVyRGVidWdUYXNrID0gY3JlYXRlVGFzayhnZXRUYXNrTmFtZShVbmtub3duT3duZXIpKTtcbiAgICB2YXIgZGlkV2FybkFib3V0S2V5U3ByZWFkID0ge307XG4gICAgZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG4gICAgZXhwb3J0cy5qc3hERVYgPSBmdW5jdGlvbiAodHlwZSwgY29uZmlnLCBtYXliZUtleSwgaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgdmFyIHRyYWNrQWN0dWFsT3duZXIgPVxuICAgICAgICAxZTQgPiBSZWFjdFNoYXJlZEludGVybmFscy5yZWNlbnRseUNyZWF0ZWRPd25lclN0YWNrcysrO1xuICAgICAgcmV0dXJuIGpzeERFVkltcGwoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgbWF5YmVLZXksXG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgIHRyYWNrQWN0dWFsT3duZXJcbiAgICAgICAgICA/IEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpXG4gICAgICAgICAgOiB1bmtub3duT3duZXJEZWJ1Z1N0YWNrLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyID8gY3JlYXRlVGFzayhnZXRUYXNrTmFtZSh0eXBlKSkgOiB1bmtub3duT3duZXJEZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgfTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/sdp/sdp.js":
/*!*********************************!*\
  !*** ./node_modules/sdp/sdp.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* eslint-env node */\n\n\n// SDP helpers.\nconst SDPUtils = {};\n\n// Generate an alphanumeric identifier for cname or mids.\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\nSDPUtils.generateIdentifier = function() {\n  return Math.random().toString(36).substring(2, 12);\n};\n\n// The RTCP CNAME used by all peerconnections from the same JS.\nSDPUtils.localCName = SDPUtils.generateIdentifier();\n\n// Splits SDP into lines, dealing with both CRLF and LF.\nSDPUtils.splitLines = function(blob) {\n  return blob.trim().split('\\n').map(line => line.trim());\n};\n// Splits SDP into sessionpart and mediasections. Ensures CRLF.\nSDPUtils.splitSections = function(blob) {\n  const parts = blob.split('\\nm=');\n  return parts.map((part, index) => (index > 0 ?\n    'm=' + part : part).trim() + '\\r\\n');\n};\n\n// Returns the session description.\nSDPUtils.getDescription = function(blob) {\n  const sections = SDPUtils.splitSections(blob);\n  return sections && sections[0];\n};\n\n// Returns the individual media sections.\nSDPUtils.getMediaSections = function(blob) {\n  const sections = SDPUtils.splitSections(blob);\n  sections.shift();\n  return sections;\n};\n\n// Returns lines that start with a certain prefix.\nSDPUtils.matchPrefix = function(blob, prefix) {\n  return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);\n};\n\n// Parses an ICE candidate line. Sample input:\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n// rport 55996\"\n// Input can be prefixed with a=.\nSDPUtils.parseCandidate = function(line) {\n  let parts;\n  // Parse both variants.\n  if (line.indexOf('a=candidate:') === 0) {\n    parts = line.substring(12).split(' ');\n  } else {\n    parts = line.substring(10).split(' ');\n  }\n\n  const candidate = {\n    foundation: parts[0],\n    component: {1: 'rtp', 2: 'rtcp'}[parts[1]] || parts[1],\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    address: parts[4], // address is an alias for ip.\n    port: parseInt(parts[5], 10),\n    // skip parts[6] == 'typ'\n    type: parts[7],\n  };\n\n  for (let i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case 'raddr':\n        candidate.relatedAddress = parts[i + 1];\n        break;\n      case 'rport':\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\n        break;\n      case 'tcptype':\n        candidate.tcpType = parts[i + 1];\n        break;\n      case 'ufrag':\n        candidate.ufrag = parts[i + 1]; // for backward compatibility.\n        candidate.usernameFragment = parts[i + 1];\n        break;\n      default: // extension handling, in particular ufrag. Don't overwrite.\n        if (candidate[parts[i]] === undefined) {\n          candidate[parts[i]] = parts[i + 1];\n        }\n        break;\n    }\n  }\n  return candidate;\n};\n\n// Translates a candidate object into SDP candidate attribute.\n// This does not include the a= prefix!\nSDPUtils.writeCandidate = function(candidate) {\n  const sdp = [];\n  sdp.push(candidate.foundation);\n\n  const component = candidate.component;\n  if (component === 'rtp') {\n    sdp.push(1);\n  } else if (component === 'rtcp') {\n    sdp.push(2);\n  } else {\n    sdp.push(component);\n  }\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.address || candidate.ip);\n  sdp.push(candidate.port);\n\n  const type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n  if (type !== 'host' && candidate.relatedAddress &&\n      candidate.relatedPort) {\n    sdp.push('raddr');\n    sdp.push(candidate.relatedAddress);\n    sdp.push('rport');\n    sdp.push(candidate.relatedPort);\n  }\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n  if (candidate.usernameFragment || candidate.ufrag) {\n    sdp.push('ufrag');\n    sdp.push(candidate.usernameFragment || candidate.ufrag);\n  }\n  return 'candidate:' + sdp.join(' ');\n};\n\n// Parses an ice-options line, returns an array of option tags.\n// Sample input:\n// a=ice-options:foo bar\nSDPUtils.parseIceOptions = function(line) {\n  return line.substring(14).split(' ');\n};\n\n// Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n// a=rtpmap:111 opus/48000/2\nSDPUtils.parseRtpMap = function(line) {\n  let parts = line.substring(9).split(' ');\n  const parsed = {\n    payloadType: parseInt(parts.shift(), 10), // was: id\n  };\n\n  parts = parts[0].split('/');\n\n  parsed.name = parts[0];\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n  // legacy alias, got renamed back to channels in ORTC.\n  parsed.numChannels = parsed.channels;\n  return parsed;\n};\n\n// Generates a rtpmap line from RTCRtpCodecCapability or\n// RTCRtpCodecParameters.\nSDPUtils.writeRtpMap = function(codec) {\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  const channels = codec.channels || codec.numChannels || 1;\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +\n      (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n};\n\n// Parses a extmap line (headerextension from RFC 5285). Sample input:\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\nSDPUtils.parseExtmap = function(line) {\n  const parts = line.substring(9).split(' ');\n  return {\n    id: parseInt(parts[0], 10),\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n    uri: parts[1],\n    attributes: parts.slice(2).join(' '),\n  };\n};\n\n// Generates an extmap line from RTCRtpHeaderExtensionParameters or\n// RTCRtpHeaderExtension.\nSDPUtils.writeExtmap = function(headerExtension) {\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +\n      (headerExtension.direction && headerExtension.direction !== 'sendrecv'\n        ? '/' + headerExtension.direction\n        : '') +\n      ' ' + headerExtension.uri +\n      (headerExtension.attributes ? ' ' + headerExtension.attributes : '') +\n      '\\r\\n';\n};\n\n// Parses a fmtp line, returns dictionary. Sample input:\n// a=fmtp:96 vbr=on;cng=on\n// Also deals with vbr=on; cng=on\n// Non-key-value such as telephone-events `0-15` get parsed as\n// {`0-15`:undefined}\nSDPUtils.parseFmtp = function(line) {\n  const parsed = {};\n  let kv;\n  const parts = line.substring(line.indexOf(' ') + 1).split(';');\n  for (let j = 0; j < parts.length; j++) {\n    kv = parts[j].trim().split('=');\n    parsed[kv[0].trim()] = kv[1];\n  }\n  return parsed;\n};\n\n// Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeFmtp = function(codec) {\n  let line = '';\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.parameters && Object.keys(codec.parameters).length) {\n    const params = [];\n    Object.keys(codec.parameters).forEach(param => {\n      if (codec.parameters[param] !== undefined) {\n        params.push(param + '=' + codec.parameters[param]);\n      } else {\n        params.push(param);\n      }\n    });\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n  }\n  return line;\n};\n\n// Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n// a=rtcp-fb:98 nack rpsi\nSDPUtils.parseRtcpFb = function(line) {\n  const parts = line.substring(line.indexOf(' ') + 1).split(' ');\n  return {\n    type: parts.shift(),\n    parameter: parts.join(' '),\n  };\n};\n\n// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeRtcpFb = function(codec) {\n  let lines = '';\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n    // FIXME: special handling for trr-int?\n    codec.rtcpFeedback.forEach(fb => {\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +\n      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +\n          '\\r\\n';\n    });\n  }\n  return lines;\n};\n\n// Parses a RFC 5576 ssrc media attribute. Sample input:\n// a=ssrc:3735928559 cname:something\nSDPUtils.parseSsrcMedia = function(line) {\n  const sp = line.indexOf(' ');\n  const parts = {\n    ssrc: parseInt(line.substring(7, sp), 10),\n  };\n  const colon = line.indexOf(':', sp);\n  if (colon > -1) {\n    parts.attribute = line.substring(sp + 1, colon);\n    parts.value = line.substring(colon + 1);\n  } else {\n    parts.attribute = line.substring(sp + 1);\n  }\n  return parts;\n};\n\n// Parse a ssrc-group line (see RFC 5576). Sample input:\n// a=ssrc-group:semantics 12 34\nSDPUtils.parseSsrcGroup = function(line) {\n  const parts = line.substring(13).split(' ');\n  return {\n    semantics: parts.shift(),\n    ssrcs: parts.map(ssrc => parseInt(ssrc, 10)),\n  };\n};\n\n// Extracts the MID (RFC 5888) from a media section.\n// Returns the MID or undefined if no mid line was found.\nSDPUtils.getMid = function(mediaSection) {\n  const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n  if (mid) {\n    return mid.substring(6);\n  }\n};\n\n// Parses a fingerprint line for DTLS-SRTP.\nSDPUtils.parseFingerprint = function(line) {\n  const parts = line.substring(14).split(' ');\n  return {\n    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.\n    value: parts[1].toUpperCase(), // the definition is upper-case in RFC 4572.\n  };\n};\n\n// Extracts DTLS parameters from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the fingerprint line as input. See also getIceParameters.\nSDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=fingerprint:');\n  // Note: a=setup line is ignored since we use the 'auto' role in Edge.\n  return {\n    role: 'auto',\n    fingerprints: lines.map(SDPUtils.parseFingerprint),\n  };\n};\n\n// Serializes DTLS parameters to SDP.\nSDPUtils.writeDtlsParameters = function(params, setupType) {\n  let sdp = 'a=setup:' + setupType + '\\r\\n';\n  params.fingerprints.forEach(fp => {\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n  });\n  return sdp;\n};\n\n// Parses a=crypto lines into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\nSDPUtils.parseCryptoLine = function(line) {\n  const parts = line.substring(9).split(' ');\n  return {\n    tag: parseInt(parts[0], 10),\n    cryptoSuite: parts[1],\n    keyParams: parts[2],\n    sessionParams: parts.slice(3),\n  };\n};\n\nSDPUtils.writeCryptoLine = function(parameters) {\n  return 'a=crypto:' + parameters.tag + ' ' +\n    parameters.cryptoSuite + ' ' +\n    (typeof parameters.keyParams === 'object'\n      ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)\n      : parameters.keyParams) +\n    (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +\n    '\\r\\n';\n};\n\n// Parses the crypto key parameters into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\nSDPUtils.parseCryptoKeyParams = function(keyParams) {\n  if (keyParams.indexOf('inline:') !== 0) {\n    return null;\n  }\n  const parts = keyParams.substring(7).split('|');\n  return {\n    keyMethod: 'inline',\n    keySalt: parts[0],\n    lifeTime: parts[1],\n    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,\n    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,\n  };\n};\n\nSDPUtils.writeCryptoKeyParams = function(keyParams) {\n  return keyParams.keyMethod + ':'\n    + keyParams.keySalt +\n    (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +\n    (keyParams.mkiValue && keyParams.mkiLength\n      ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength\n      : '');\n};\n\n// Extracts all SDES parameters.\nSDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=crypto:');\n  return lines.map(SDPUtils.parseCryptoLine);\n};\n\n// Parses ICE information from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the ice-ufrag and ice-pwd lines as input.\nSDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n  const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=ice-ufrag:')[0];\n  const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=ice-pwd:')[0];\n  if (!(ufrag && pwd)) {\n    return null;\n  }\n  return {\n    usernameFragment: ufrag.substring(12),\n    password: pwd.substring(10),\n  };\n};\n\n// Serializes ICE parameters to SDP.\nSDPUtils.writeIceParameters = function(params) {\n  let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' +\n      'a=ice-pwd:' + params.password + '\\r\\n';\n  if (params.iceLite) {\n    sdp += 'a=ice-lite\\r\\n';\n  }\n  return sdp;\n};\n\n// Parses the SDP media section and returns RTCRtpParameters.\nSDPUtils.parseRtpParameters = function(mediaSection) {\n  const description = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: [],\n    rtcp: [],\n  };\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n  description.profile = mline[2];\n  for (let i = 3; i < mline.length; i++) { // find all codecs from mline[3..]\n    const pt = mline[i];\n    const rtpmapline = SDPUtils.matchPrefix(\n      mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n    if (rtpmapline) {\n      const codec = SDPUtils.parseRtpMap(rtpmapline);\n      const fmtps = SDPUtils.matchPrefix(\n        mediaSection, 'a=fmtp:' + pt + ' ');\n      // Only the first a=fmtp:<pt> is considered.\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n      codec.rtcpFeedback = SDPUtils.matchPrefix(\n        mediaSection, 'a=rtcp-fb:' + pt + ' ')\n        .map(SDPUtils.parseRtcpFb);\n      description.codecs.push(codec);\n      // parse FEC mechanisms from rtpmap lines.\n      switch (codec.name.toUpperCase()) {\n        case 'RED':\n        case 'ULPFEC':\n          description.fecMechanisms.push(codec.name.toUpperCase());\n          break;\n        default: // only RED and ULPFEC are recognized as FEC mechanisms.\n          break;\n      }\n    }\n  }\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\n  });\n  const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:* ')\n    .map(SDPUtils.parseRtcpFb);\n  description.codecs.forEach(codec => {\n    wildcardRtcpFb.forEach(fb=> {\n      const duplicate = codec.rtcpFeedback.find(existingFeedback => {\n        return existingFeedback.type === fb.type &&\n          existingFeedback.parameter === fb.parameter;\n      });\n      if (!duplicate) {\n        codec.rtcpFeedback.push(fb);\n      }\n    });\n  });\n  // FIXME: parse rtcp.\n  return description;\n};\n\n// Generates parts of the SDP media section describing the capabilities /\n// parameters.\nSDPUtils.writeRtpDescription = function(kind, caps) {\n  let sdp = '';\n\n  // Build the mline.\n  sdp += 'm=' + kind + ' ';\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n  sdp += ' ' + (caps.profile || 'UDP/TLS/RTP/SAVPF') + ' ';\n  sdp += caps.codecs.map(codec => {\n    if (codec.preferredPayloadType !== undefined) {\n      return codec.preferredPayloadType;\n    }\n    return codec.payloadType;\n  }).join(' ') + '\\r\\n';\n\n  sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n  caps.codecs.forEach(codec => {\n    sdp += SDPUtils.writeRtpMap(codec);\n    sdp += SDPUtils.writeFmtp(codec);\n    sdp += SDPUtils.writeRtcpFb(codec);\n  });\n  let maxptime = 0;\n  caps.codecs.forEach(codec => {\n    if (codec.maxptime > maxptime) {\n      maxptime = codec.maxptime;\n    }\n  });\n  if (maxptime > 0) {\n    sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n  }\n\n  if (caps.headerExtensions) {\n    caps.headerExtensions.forEach(extension => {\n      sdp += SDPUtils.writeExtmap(extension);\n    });\n  }\n  // FIXME: write fecMechanisms.\n  return sdp;\n};\n\n// Parses the SDP media section and returns an array of\n// RTCRtpEncodingParameters.\nSDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n  const encodingParameters = [];\n  const description = SDPUtils.parseRtpParameters(mediaSection);\n  const hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n  const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n  // filter a=ssrc:... cname:, ignore PlanB-msid\n  const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(line => SDPUtils.parseSsrcMedia(line))\n    .filter(parts => parts.attribute === 'cname');\n  const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n  let secondarySsrc;\n\n  const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')\n    .map(line => {\n      const parts = line.substring(17).split(' ');\n      return parts.map(part => parseInt(part, 10));\n    });\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n    secondarySsrc = flows[0][1];\n  }\n\n  description.codecs.forEach(codec => {\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n      let encParam = {\n        ssrc: primarySsrc,\n        codecPayloadType: parseInt(codec.parameters.apt, 10),\n      };\n      if (primarySsrc && secondarySsrc) {\n        encParam.rtx = {ssrc: secondarySsrc};\n      }\n      encodingParameters.push(encParam);\n      if (hasRed) {\n        encParam = JSON.parse(JSON.stringify(encParam));\n        encParam.fec = {\n          ssrc: primarySsrc,\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red',\n        };\n        encodingParameters.push(encParam);\n      }\n    }\n  });\n  if (encodingParameters.length === 0 && primarySsrc) {\n    encodingParameters.push({\n      ssrc: primarySsrc,\n    });\n  }\n\n  // we support both b=AS and b=TIAS but interpret AS as TIAS.\n  let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n  if (bandwidth.length) {\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n      bandwidth = parseInt(bandwidth[0].substring(7), 10);\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n      // use formula from JSEP to convert b=AS to TIAS value.\n      bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95\n          - (50 * 40 * 8);\n    } else {\n      bandwidth = undefined;\n    }\n    encodingParameters.forEach(params => {\n      params.maxBitrate = bandwidth;\n    });\n  }\n  return encodingParameters;\n};\n\n// parses http://draft.ortc.org/#rtcrtcpparameters*\nSDPUtils.parseRtcpParameters = function(mediaSection) {\n  const rtcpParameters = {};\n\n  // Gets the first SSRC. Note that with RTX there might be multiple\n  // SSRCs.\n  const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(line => SDPUtils.parseSsrcMedia(line))\n    .filter(obj => obj.attribute === 'cname')[0];\n  if (remoteSsrc) {\n    rtcpParameters.cname = remoteSsrc.value;\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\n  }\n\n  // Edge uses the compound attribute instead of reducedSize\n  // compound is !reducedSize\n  const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n  rtcpParameters.reducedSize = rsize.length > 0;\n  rtcpParameters.compound = rsize.length === 0;\n\n  // parses the rtcp-mux attrbute.\n  // Note that Edge does not support unmuxed RTCP.\n  const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n  rtcpParameters.mux = mux.length > 0;\n\n  return rtcpParameters;\n};\n\nSDPUtils.writeRtcpParameters = function(rtcpParameters) {\n  let sdp = '';\n  if (rtcpParameters.reducedSize) {\n    sdp += 'a=rtcp-rsize\\r\\n';\n  }\n  if (rtcpParameters.mux) {\n    sdp += 'a=rtcp-mux\\r\\n';\n  }\n  if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\n    sdp += 'a=ssrc:' + rtcpParameters.ssrc +\n      ' cname:' + rtcpParameters.cname + '\\r\\n';\n  }\n  return sdp;\n};\n\n\n// parses either a=msid: or a=ssrc:... msid lines and returns\n// the id of the MediaStream and MediaStreamTrack.\nSDPUtils.parseMsid = function(mediaSection) {\n  let parts;\n  const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n  if (spec.length === 1) {\n    parts = spec[0].substring(7).split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n  const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(line => SDPUtils.parseSsrcMedia(line))\n    .filter(msidParts => msidParts.attribute === 'msid');\n  if (planB.length > 0) {\n    parts = planB[0].value.split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n};\n\n// SCTP\n// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n// to draft-ietf-mmusic-sctp-sdp-05\nSDPUtils.parseSctpDescription = function(mediaSection) {\n  const mline = SDPUtils.parseMLine(mediaSection);\n  const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');\n  let maxMessageSize;\n  if (maxSizeLine.length > 0) {\n    maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);\n  }\n  if (isNaN(maxMessageSize)) {\n    maxMessageSize = 65536;\n  }\n  const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');\n  if (sctpPort.length > 0) {\n    return {\n      port: parseInt(sctpPort[0].substring(12), 10),\n      protocol: mline.fmt,\n      maxMessageSize,\n    };\n  }\n  const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');\n  if (sctpMapLines.length > 0) {\n    const parts = sctpMapLines[0]\n      .substring(10)\n      .split(' ');\n    return {\n      port: parseInt(parts[0], 10),\n      protocol: parts[1],\n      maxMessageSize,\n    };\n  }\n};\n\n// SCTP\n// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n// support by now receiving in this format, unless we originally parsed\n// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n// protocol of DTLS/SCTP -- without UDP/ or TCP/)\nSDPUtils.writeSctpDescription = function(media, sctp) {\n  let output = [];\n  if (media.protocol !== 'DTLS/SCTP') {\n    output = [\n      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\\r\\n',\n      'c=IN IP4 0.0.0.0\\r\\n',\n      'a=sctp-port:' + sctp.port + '\\r\\n',\n    ];\n  } else {\n    output = [\n      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\\r\\n',\n      'c=IN IP4 0.0.0.0\\r\\n',\n      'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\\r\\n',\n    ];\n  }\n  if (sctp.maxMessageSize !== undefined) {\n    output.push('a=max-message-size:' + sctp.maxMessageSize + '\\r\\n');\n  }\n  return output.join('');\n};\n\n// Generate a session ID for SDP.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n// recommends using a cryptographically random +ve 64-bit value\n// but right now this should be acceptable and within the right range\nSDPUtils.generateSessionId = function() {\n  return Math.random().toString().substr(2, 22);\n};\n\n// Write boiler plate for start of SDP\n// sessId argument is optional - if not supplied it will\n// be generated randomly\n// sessVersion is optional and defaults to 2\n// sessUser is optional and defaults to 'thisisadapterortc'\nSDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {\n  let sessionId;\n  const version = sessVer !== undefined ? sessVer : 2;\n  if (sessId) {\n    sessionId = sessId;\n  } else {\n    sessionId = SDPUtils.generateSessionId();\n  }\n  const user = sessUser || 'thisisadapterortc';\n  // FIXME: sess-id should be an NTP timestamp.\n  return 'v=0\\r\\n' +\n      'o=' + user + ' ' + sessionId + ' ' + version +\n        ' IN IP4 127.0.0.1\\r\\n' +\n      's=-\\r\\n' +\n      't=0 0\\r\\n';\n};\n\n// Gets the direction from the mediaSection or the sessionpart.\nSDPUtils.getDirection = function(mediaSection, sessionpart) {\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n  const lines = SDPUtils.splitLines(mediaSection);\n  for (let i = 0; i < lines.length; i++) {\n    switch (lines[i]) {\n      case 'a=sendrecv':\n      case 'a=sendonly':\n      case 'a=recvonly':\n      case 'a=inactive':\n        return lines[i].substring(2);\n      default:\n        // FIXME: What should happen here?\n    }\n  }\n  if (sessionpart) {\n    return SDPUtils.getDirection(sessionpart);\n  }\n  return 'sendrecv';\n};\n\nSDPUtils.getKind = function(mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n  return mline[0].substring(2);\n};\n\nSDPUtils.isRejected = function(mediaSection) {\n  return mediaSection.split(' ', 2)[1] === '0';\n};\n\nSDPUtils.parseMLine = function(mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const parts = lines[0].substring(2).split(' ');\n  return {\n    kind: parts[0],\n    port: parseInt(parts[1], 10),\n    protocol: parts[2],\n    fmt: parts.slice(3).join(' '),\n  };\n};\n\nSDPUtils.parseOLine = function(mediaSection) {\n  const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n  const parts = line.substring(2).split(' ');\n  return {\n    username: parts[0],\n    sessionId: parts[1],\n    sessionVersion: parseInt(parts[2], 10),\n    netType: parts[3],\n    addressType: parts[4],\n    address: parts[5],\n  };\n};\n\n// a very naive interpretation of a valid SDP.\nSDPUtils.isValidSDP = function(blob) {\n  if (typeof blob !== 'string' || blob.length === 0) {\n    return false;\n  }\n  const lines = SDPUtils.splitLines(blob);\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\n      return false;\n    }\n    // TODO: check the modifier a bit more.\n  }\n  return true;\n};\n\n// Expose public methods.\nif (true) {\n  module.exports = SDPUtils;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zZHAvc2RwLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCLDJCQUEyQjtBQUMzQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxJQUEwQjtBQUM5QjtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9zZHAvc2RwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBTRFAgaGVscGVycy5cbmNvbnN0IFNEUFV0aWxzID0ge307XG5cbi8vIEdlbmVyYXRlIGFuIGFscGhhbnVtZXJpYyBpZGVudGlmaWVyIGZvciBjbmFtZSBvciBtaWRzLlxuLy8gVE9ETzogdXNlIFVVSURzIGluc3RlYWQ/IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2plZC85ODI4ODNcblNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDEyKTtcbn07XG5cbi8vIFRoZSBSVENQIENOQU1FIHVzZWQgYnkgYWxsIHBlZXJjb25uZWN0aW9ucyBmcm9tIHRoZSBzYW1lIEpTLlxuU0RQVXRpbHMubG9jYWxDTmFtZSA9IFNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllcigpO1xuXG4vLyBTcGxpdHMgU0RQIGludG8gbGluZXMsIGRlYWxpbmcgd2l0aCBib3RoIENSTEYgYW5kIExGLlxuU0RQVXRpbHMuc3BsaXRMaW5lcyA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgcmV0dXJuIGJsb2IudHJpbSgpLnNwbGl0KCdcXG4nKS5tYXAobGluZSA9PiBsaW5lLnRyaW0oKSk7XG59O1xuLy8gU3BsaXRzIFNEUCBpbnRvIHNlc3Npb25wYXJ0IGFuZCBtZWRpYXNlY3Rpb25zLiBFbnN1cmVzIENSTEYuXG5TRFBVdGlscy5zcGxpdFNlY3Rpb25zID0gZnVuY3Rpb24oYmxvYikge1xuICBjb25zdCBwYXJ0cyA9IGJsb2Iuc3BsaXQoJ1xcbm09Jyk7XG4gIHJldHVybiBwYXJ0cy5tYXAoKHBhcnQsIGluZGV4KSA9PiAoaW5kZXggPiAwID9cbiAgICAnbT0nICsgcGFydCA6IHBhcnQpLnRyaW0oKSArICdcXHJcXG4nKTtcbn07XG5cbi8vIFJldHVybnMgdGhlIHNlc3Npb24gZGVzY3JpcHRpb24uXG5TRFBVdGlscy5nZXREZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgY29uc3Qgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGJsb2IpO1xuICByZXR1cm4gc2VjdGlvbnMgJiYgc2VjdGlvbnNbMF07XG59O1xuXG4vLyBSZXR1cm5zIHRoZSBpbmRpdmlkdWFsIG1lZGlhIHNlY3Rpb25zLlxuU0RQVXRpbHMuZ2V0TWVkaWFTZWN0aW9ucyA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgY29uc3Qgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGJsb2IpO1xuICBzZWN0aW9ucy5zaGlmdCgpO1xuICByZXR1cm4gc2VjdGlvbnM7XG59O1xuXG4vLyBSZXR1cm5zIGxpbmVzIHRoYXQgc3RhcnQgd2l0aCBhIGNlcnRhaW4gcHJlZml4LlxuU0RQVXRpbHMubWF0Y2hQcmVmaXggPSBmdW5jdGlvbihibG9iLCBwcmVmaXgpIHtcbiAgcmV0dXJuIFNEUFV0aWxzLnNwbGl0TGluZXMoYmxvYikuZmlsdGVyKGxpbmUgPT4gbGluZS5pbmRleE9mKHByZWZpeCkgPT09IDApO1xufTtcblxuLy8gUGFyc2VzIGFuIElDRSBjYW5kaWRhdGUgbGluZS4gU2FtcGxlIGlucHV0OlxuLy8gY2FuZGlkYXRlOjcwMjc4NjM1MCAyIHVkcCA0MTgxOTkwMiA4LjguOC44IDYwNzY5IHR5cCByZWxheSByYWRkciA4LjguOC44XG4vLyBycG9ydCA1NTk5NlwiXG4vLyBJbnB1dCBjYW4gYmUgcHJlZml4ZWQgd2l0aCBhPS5cblNEUFV0aWxzLnBhcnNlQ2FuZGlkYXRlID0gZnVuY3Rpb24obGluZSkge1xuICBsZXQgcGFydHM7XG4gIC8vIFBhcnNlIGJvdGggdmFyaWFudHMuXG4gIGlmIChsaW5lLmluZGV4T2YoJ2E9Y2FuZGlkYXRlOicpID09PSAwKSB7XG4gICAgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMikuc3BsaXQoJyAnKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEwKS5zcGxpdCgnICcpO1xuICB9XG5cbiAgY29uc3QgY2FuZGlkYXRlID0ge1xuICAgIGZvdW5kYXRpb246IHBhcnRzWzBdLFxuICAgIGNvbXBvbmVudDogezE6ICdydHAnLCAyOiAncnRjcCd9W3BhcnRzWzFdXSB8fCBwYXJ0c1sxXSxcbiAgICBwcm90b2NvbDogcGFydHNbMl0udG9Mb3dlckNhc2UoKSxcbiAgICBwcmlvcml0eTogcGFyc2VJbnQocGFydHNbM10sIDEwKSxcbiAgICBpcDogcGFydHNbNF0sXG4gICAgYWRkcmVzczogcGFydHNbNF0sIC8vIGFkZHJlc3MgaXMgYW4gYWxpYXMgZm9yIGlwLlxuICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzVdLCAxMCksXG4gICAgLy8gc2tpcCBwYXJ0c1s2XSA9PSAndHlwJ1xuICAgIHR5cGU6IHBhcnRzWzddLFxuICB9O1xuXG4gIGZvciAobGV0IGkgPSA4OyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBzd2l0Y2ggKHBhcnRzW2ldKSB7XG4gICAgICBjYXNlICdyYWRkcic6XG4gICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdycG9ydCc6XG4gICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCA9IHBhcnNlSW50KHBhcnRzW2kgKyAxXSwgMTApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RjcHR5cGUnOlxuICAgICAgICBjYW5kaWRhdGUudGNwVHlwZSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1ZnJhZyc6XG4gICAgICAgIGNhbmRpZGF0ZS51ZnJhZyA9IHBhcnRzW2kgKyAxXTsgLy8gZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50ID0gcGFydHNbaSArIDFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIGV4dGVuc2lvbiBoYW5kbGluZywgaW4gcGFydGljdWxhciB1ZnJhZy4gRG9uJ3Qgb3ZlcndyaXRlLlxuICAgICAgICBpZiAoY2FuZGlkYXRlW3BhcnRzW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2FuZGlkYXRlW3BhcnRzW2ldXSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZTtcbn07XG5cbi8vIFRyYW5zbGF0ZXMgYSBjYW5kaWRhdGUgb2JqZWN0IGludG8gU0RQIGNhbmRpZGF0ZSBhdHRyaWJ1dGUuXG4vLyBUaGlzIGRvZXMgbm90IGluY2x1ZGUgdGhlIGE9IHByZWZpeCFcblNEUFV0aWxzLndyaXRlQ2FuZGlkYXRlID0gZnVuY3Rpb24oY2FuZGlkYXRlKSB7XG4gIGNvbnN0IHNkcCA9IFtdO1xuICBzZHAucHVzaChjYW5kaWRhdGUuZm91bmRhdGlvbik7XG5cbiAgY29uc3QgY29tcG9uZW50ID0gY2FuZGlkYXRlLmNvbXBvbmVudDtcbiAgaWYgKGNvbXBvbmVudCA9PT0gJ3J0cCcpIHtcbiAgICBzZHAucHVzaCgxKTtcbiAgfSBlbHNlIGlmIChjb21wb25lbnQgPT09ICdydGNwJykge1xuICAgIHNkcC5wdXNoKDIpO1xuICB9IGVsc2Uge1xuICAgIHNkcC5wdXNoKGNvbXBvbmVudCk7XG4gIH1cbiAgc2RwLnB1c2goY2FuZGlkYXRlLnByb3RvY29sLnRvVXBwZXJDYXNlKCkpO1xuICBzZHAucHVzaChjYW5kaWRhdGUucHJpb3JpdHkpO1xuICBzZHAucHVzaChjYW5kaWRhdGUuYWRkcmVzcyB8fCBjYW5kaWRhdGUuaXApO1xuICBzZHAucHVzaChjYW5kaWRhdGUucG9ydCk7XG5cbiAgY29uc3QgdHlwZSA9IGNhbmRpZGF0ZS50eXBlO1xuICBzZHAucHVzaCgndHlwJyk7XG4gIHNkcC5wdXNoKHR5cGUpO1xuICBpZiAodHlwZSAhPT0gJ2hvc3QnICYmIGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyAmJlxuICAgICAgY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KSB7XG4gICAgc2RwLnB1c2goJ3JhZGRyJyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzKTtcbiAgICBzZHAucHVzaCgncnBvcnQnKTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUucmVsYXRlZFBvcnQpO1xuICB9XG4gIGlmIChjYW5kaWRhdGUudGNwVHlwZSAmJiBjYW5kaWRhdGUucHJvdG9jb2wudG9Mb3dlckNhc2UoKSA9PT0gJ3RjcCcpIHtcbiAgICBzZHAucHVzaCgndGNwdHlwZScpO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS50Y3BUeXBlKTtcbiAgfVxuICBpZiAoY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgfHwgY2FuZGlkYXRlLnVmcmFnKSB7XG4gICAgc2RwLnB1c2goJ3VmcmFnJyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgfHwgY2FuZGlkYXRlLnVmcmFnKTtcbiAgfVxuICByZXR1cm4gJ2NhbmRpZGF0ZTonICsgc2RwLmpvaW4oJyAnKTtcbn07XG5cbi8vIFBhcnNlcyBhbiBpY2Utb3B0aW9ucyBsaW5lLCByZXR1cm5zIGFuIGFycmF5IG9mIG9wdGlvbiB0YWdzLlxuLy8gU2FtcGxlIGlucHV0OlxuLy8gYT1pY2Utb3B0aW9uczpmb28gYmFyXG5TRFBVdGlscy5wYXJzZUljZU9wdGlvbnMgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHJldHVybiBsaW5lLnN1YnN0cmluZygxNCkuc3BsaXQoJyAnKTtcbn07XG5cbi8vIFBhcnNlcyBhIHJ0cG1hcCBsaW5lLCByZXR1cm5zIFJUQ1J0cENvZGRlY1BhcmFtZXRlcnMuIFNhbXBsZSBpbnB1dDpcbi8vIGE9cnRwbWFwOjExMSBvcHVzLzQ4MDAwLzJcblNEUFV0aWxzLnBhcnNlUnRwTWFwID0gZnVuY3Rpb24obGluZSkge1xuICBsZXQgcGFydHMgPSBsaW5lLnN1YnN0cmluZyg5KS5zcGxpdCgnICcpO1xuICBjb25zdCBwYXJzZWQgPSB7XG4gICAgcGF5bG9hZFR5cGU6IHBhcnNlSW50KHBhcnRzLnNoaWZ0KCksIDEwKSwgLy8gd2FzOiBpZFxuICB9O1xuXG4gIHBhcnRzID0gcGFydHNbMF0uc3BsaXQoJy8nKTtcblxuICBwYXJzZWQubmFtZSA9IHBhcnRzWzBdO1xuICBwYXJzZWQuY2xvY2tSYXRlID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTsgLy8gd2FzOiBjbG9ja3JhdGVcbiAgcGFyc2VkLmNoYW5uZWxzID0gcGFydHMubGVuZ3RoID09PSAzID8gcGFyc2VJbnQocGFydHNbMl0sIDEwKSA6IDE7XG4gIC8vIGxlZ2FjeSBhbGlhcywgZ290IHJlbmFtZWQgYmFjayB0byBjaGFubmVscyBpbiBPUlRDLlxuICBwYXJzZWQubnVtQ2hhbm5lbHMgPSBwYXJzZWQuY2hhbm5lbHM7XG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG4vLyBHZW5lcmF0ZXMgYSBydHBtYXAgbGluZSBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvclxuLy8gUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVSdHBNYXAgPSBmdW5jdGlvbihjb2RlYykge1xuICBsZXQgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICB9XG4gIGNvbnN0IGNoYW5uZWxzID0gY29kZWMuY2hhbm5lbHMgfHwgY29kZWMubnVtQ2hhbm5lbHMgfHwgMTtcbiAgcmV0dXJuICdhPXJ0cG1hcDonICsgcHQgKyAnICcgKyBjb2RlYy5uYW1lICsgJy8nICsgY29kZWMuY2xvY2tSYXRlICtcbiAgICAgIChjaGFubmVscyAhPT0gMSA/ICcvJyArIGNoYW5uZWxzIDogJycpICsgJ1xcclxcbic7XG59O1xuXG4vLyBQYXJzZXMgYSBleHRtYXAgbGluZSAoaGVhZGVyZXh0ZW5zaW9uIGZyb20gUkZDIDUyODUpLiBTYW1wbGUgaW5wdXQ6XG4vLyBhPWV4dG1hcDoyIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcbi8vIGE9ZXh0bWFwOjIvc2VuZG9ubHkgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6dG9mZnNldFxuU0RQVXRpbHMucGFyc2VFeHRtYXAgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoOSkuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICBpZDogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICBkaXJlY3Rpb246IHBhcnRzWzBdLmluZGV4T2YoJy8nKSA+IDAgPyBwYXJ0c1swXS5zcGxpdCgnLycpWzFdIDogJ3NlbmRyZWN2JyxcbiAgICB1cmk6IHBhcnRzWzFdLFxuICAgIGF0dHJpYnV0ZXM6IHBhcnRzLnNsaWNlKDIpLmpvaW4oJyAnKSxcbiAgfTtcbn07XG5cbi8vIEdlbmVyYXRlcyBhbiBleHRtYXAgbGluZSBmcm9tIFJUQ1J0cEhlYWRlckV4dGVuc2lvblBhcmFtZXRlcnMgb3Jcbi8vIFJUQ1J0cEhlYWRlckV4dGVuc2lvbi5cblNEUFV0aWxzLndyaXRlRXh0bWFwID0gZnVuY3Rpb24oaGVhZGVyRXh0ZW5zaW9uKSB7XG4gIHJldHVybiAnYT1leHRtYXA6JyArIChoZWFkZXJFeHRlbnNpb24uaWQgfHwgaGVhZGVyRXh0ZW5zaW9uLnByZWZlcnJlZElkKSArXG4gICAgICAoaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvbiAmJiBoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uICE9PSAnc2VuZHJlY3YnXG4gICAgICAgID8gJy8nICsgaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvblxuICAgICAgICA6ICcnKSArXG4gICAgICAnICcgKyBoZWFkZXJFeHRlbnNpb24udXJpICtcbiAgICAgIChoZWFkZXJFeHRlbnNpb24uYXR0cmlidXRlcyA/ICcgJyArIGhlYWRlckV4dGVuc2lvbi5hdHRyaWJ1dGVzIDogJycpICtcbiAgICAgICdcXHJcXG4nO1xufTtcblxuLy8gUGFyc2VzIGEgZm10cCBsaW5lLCByZXR1cm5zIGRpY3Rpb25hcnkuIFNhbXBsZSBpbnB1dDpcbi8vIGE9Zm10cDo5NiB2YnI9b247Y25nPW9uXG4vLyBBbHNvIGRlYWxzIHdpdGggdmJyPW9uOyBjbmc9b25cbi8vIE5vbi1rZXktdmFsdWUgc3VjaCBhcyB0ZWxlcGhvbmUtZXZlbnRzIGAwLTE1YCBnZXQgcGFyc2VkIGFzXG4vLyB7YDAtMTVgOnVuZGVmaW5lZH1cblNEUFV0aWxzLnBhcnNlRm10cCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgY29uc3QgcGFyc2VkID0ge307XG4gIGxldCBrdjtcbiAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZyhsaW5lLmluZGV4T2YoJyAnKSArIDEpLnNwbGl0KCc7Jyk7XG4gIGZvciAobGV0IGogPSAwOyBqIDwgcGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICBrdiA9IHBhcnRzW2pdLnRyaW0oKS5zcGxpdCgnPScpO1xuICAgIHBhcnNlZFtrdlswXS50cmltKCldID0ga3ZbMV07XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbi8vIEdlbmVyYXRlcyBhIGZtdHAgbGluZSBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvciBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZUZtdHAgPSBmdW5jdGlvbihjb2RlYykge1xuICBsZXQgbGluZSA9ICcnO1xuICBsZXQgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICB9XG4gIGlmIChjb2RlYy5wYXJhbWV0ZXJzICYmIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpLmxlbmd0aCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpLmZvckVhY2gocGFyYW0gPT4ge1xuICAgICAgaWYgKGNvZGVjLnBhcmFtZXRlcnNbcGFyYW1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0gKyAnPScgKyBjb2RlYy5wYXJhbWV0ZXJzW3BhcmFtXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGluZSArPSAnYT1mbXRwOicgKyBwdCArICcgJyArIHBhcmFtcy5qb2luKCc7JykgKyAnXFxyXFxuJztcbiAgfVxuICByZXR1cm4gbGluZTtcbn07XG5cbi8vIFBhcnNlcyBhIHJ0Y3AtZmIgbGluZSwgcmV0dXJucyBSVENQUnRjcEZlZWRiYWNrIG9iamVjdC4gU2FtcGxlIGlucHV0OlxuLy8gYT1ydGNwLWZiOjk4IG5hY2sgcnBzaVxuU0RQVXRpbHMucGFyc2VSdGNwRmIgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcobGluZS5pbmRleE9mKCcgJykgKyAxKS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHBhcnRzLnNoaWZ0KCksXG4gICAgcGFyYW1ldGVyOiBwYXJ0cy5qb2luKCcgJyksXG4gIH07XG59O1xuXG4vLyBHZW5lcmF0ZSBhPXJ0Y3AtZmIgbGluZXMgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3IgUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVSdGNwRmIgPSBmdW5jdGlvbihjb2RlYykge1xuICBsZXQgbGluZXMgPSAnJztcbiAgbGV0IHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XG4gIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgfVxuICBpZiAoY29kZWMucnRjcEZlZWRiYWNrICYmIGNvZGVjLnJ0Y3BGZWVkYmFjay5sZW5ndGgpIHtcbiAgICAvLyBGSVhNRTogc3BlY2lhbCBoYW5kbGluZyBmb3IgdHJyLWludD9cbiAgICBjb2RlYy5ydGNwRmVlZGJhY2suZm9yRWFjaChmYiA9PiB7XG4gICAgICBsaW5lcyArPSAnYT1ydGNwLWZiOicgKyBwdCArICcgJyArIGZiLnR5cGUgK1xuICAgICAgKGZiLnBhcmFtZXRlciAmJiBmYi5wYXJhbWV0ZXIubGVuZ3RoID8gJyAnICsgZmIucGFyYW1ldGVyIDogJycpICtcbiAgICAgICAgICAnXFxyXFxuJztcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbGluZXM7XG59O1xuXG4vLyBQYXJzZXMgYSBSRkMgNTU3NiBzc3JjIG1lZGlhIGF0dHJpYnV0ZS4gU2FtcGxlIGlucHV0OlxuLy8gYT1zc3JjOjM3MzU5Mjg1NTkgY25hbWU6c29tZXRoaW5nXG5TRFBVdGlscy5wYXJzZVNzcmNNZWRpYSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgY29uc3Qgc3AgPSBsaW5lLmluZGV4T2YoJyAnKTtcbiAgY29uc3QgcGFydHMgPSB7XG4gICAgc3NyYzogcGFyc2VJbnQobGluZS5zdWJzdHJpbmcoNywgc3ApLCAxMCksXG4gIH07XG4gIGNvbnN0IGNvbG9uID0gbGluZS5pbmRleE9mKCc6Jywgc3ApO1xuICBpZiAoY29sb24gPiAtMSkge1xuICAgIHBhcnRzLmF0dHJpYnV0ZSA9IGxpbmUuc3Vic3RyaW5nKHNwICsgMSwgY29sb24pO1xuICAgIHBhcnRzLnZhbHVlID0gbGluZS5zdWJzdHJpbmcoY29sb24gKyAxKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0cy5hdHRyaWJ1dGUgPSBsaW5lLnN1YnN0cmluZyhzcCArIDEpO1xuICB9XG4gIHJldHVybiBwYXJ0cztcbn07XG5cbi8vIFBhcnNlIGEgc3NyYy1ncm91cCBsaW5lIChzZWUgUkZDIDU1NzYpLiBTYW1wbGUgaW5wdXQ6XG4vLyBhPXNzcmMtZ3JvdXA6c2VtYW50aWNzIDEyIDM0XG5TRFBVdGlscy5wYXJzZVNzcmNHcm91cCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMykuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICBzZW1hbnRpY3M6IHBhcnRzLnNoaWZ0KCksXG4gICAgc3NyY3M6IHBhcnRzLm1hcChzc3JjID0+IHBhcnNlSW50KHNzcmMsIDEwKSksXG4gIH07XG59O1xuXG4vLyBFeHRyYWN0cyB0aGUgTUlEIChSRkMgNTg4OCkgZnJvbSBhIG1lZGlhIHNlY3Rpb24uXG4vLyBSZXR1cm5zIHRoZSBNSUQgb3IgdW5kZWZpbmVkIGlmIG5vIG1pZCBsaW5lIHdhcyBmb3VuZC5cblNEUFV0aWxzLmdldE1pZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBtaWQgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1pZDonKVswXTtcbiAgaWYgKG1pZCkge1xuICAgIHJldHVybiBtaWQuc3Vic3RyaW5nKDYpO1xuICB9XG59O1xuXG4vLyBQYXJzZXMgYSBmaW5nZXJwcmludCBsaW5lIGZvciBEVExTLVNSVFAuXG5TRFBVdGlscy5wYXJzZUZpbmdlcnByaW50ID0gZnVuY3Rpb24obGluZSkge1xuICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDE0KS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIGFsZ29yaXRobTogcGFydHNbMF0udG9Mb3dlckNhc2UoKSwgLy8gYWxnb3JpdGhtIGlzIGNhc2Utc2Vuc2l0aXZlIGluIEVkZ2UuXG4gICAgdmFsdWU6IHBhcnRzWzFdLnRvVXBwZXJDYXNlKCksIC8vIHRoZSBkZWZpbml0aW9uIGlzIHVwcGVyLWNhc2UgaW4gUkZDIDQ1NzIuXG4gIH07XG59O1xuXG4vLyBFeHRyYWN0cyBEVExTIHBhcmFtZXRlcnMgZnJvbSBTRFAgbWVkaWEgc2VjdGlvbiBvciBzZXNzaW9ucGFydC5cbi8vIEZJWE1FOiBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBmdW5jdGlvbnMgdGhpcyBzaG91bGQgb25seVxuLy8gICBnZXQgdGhlIGZpbmdlcnByaW50IGxpbmUgYXMgaW5wdXQuIFNlZSBhbHNvIGdldEljZVBhcmFtZXRlcnMuXG5TRFBVdGlscy5nZXREdGxzUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCxcbiAgICAnYT1maW5nZXJwcmludDonKTtcbiAgLy8gTm90ZTogYT1zZXR1cCBsaW5lIGlzIGlnbm9yZWQgc2luY2Ugd2UgdXNlIHRoZSAnYXV0bycgcm9sZSBpbiBFZGdlLlxuICByZXR1cm4ge1xuICAgIHJvbGU6ICdhdXRvJyxcbiAgICBmaW5nZXJwcmludHM6IGxpbmVzLm1hcChTRFBVdGlscy5wYXJzZUZpbmdlcnByaW50KSxcbiAgfTtcbn07XG5cbi8vIFNlcmlhbGl6ZXMgRFRMUyBwYXJhbWV0ZXJzIHRvIFNEUC5cblNEUFV0aWxzLndyaXRlRHRsc1BhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbXMsIHNldHVwVHlwZSkge1xuICBsZXQgc2RwID0gJ2E9c2V0dXA6JyArIHNldHVwVHlwZSArICdcXHJcXG4nO1xuICBwYXJhbXMuZmluZ2VycHJpbnRzLmZvckVhY2goZnAgPT4ge1xuICAgIHNkcCArPSAnYT1maW5nZXJwcmludDonICsgZnAuYWxnb3JpdGhtICsgJyAnICsgZnAudmFsdWUgKyAnXFxyXFxuJztcbiAgfSk7XG4gIHJldHVybiBzZHA7XG59O1xuXG4vLyBQYXJzZXMgYT1jcnlwdG8gbGluZXMgaW50b1xuLy8gICBodHRwczovL3Jhd2dpdC5jb20vYWJvYmEvZWRnZXJ0Yy9tYXN0ZXIvbXNvcnRjLXJzNC5odG1sI2RpY3Rpb25hcnktcnRjc3J0cHNkZXNwYXJhbWV0ZXJzLW1lbWJlcnNcblNEUFV0aWxzLnBhcnNlQ3J5cHRvTGluZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZyg5KS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIHRhZzogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICBjcnlwdG9TdWl0ZTogcGFydHNbMV0sXG4gICAga2V5UGFyYW1zOiBwYXJ0c1syXSxcbiAgICBzZXNzaW9uUGFyYW1zOiBwYXJ0cy5zbGljZSgzKSxcbiAgfTtcbn07XG5cblNEUFV0aWxzLndyaXRlQ3J5cHRvTGluZSA9IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcbiAgcmV0dXJuICdhPWNyeXB0bzonICsgcGFyYW1ldGVycy50YWcgKyAnICcgK1xuICAgIHBhcmFtZXRlcnMuY3J5cHRvU3VpdGUgKyAnICcgK1xuICAgICh0eXBlb2YgcGFyYW1ldGVycy5rZXlQYXJhbXMgPT09ICdvYmplY3QnXG4gICAgICA/IFNEUFV0aWxzLndyaXRlQ3J5cHRvS2V5UGFyYW1zKHBhcmFtZXRlcnMua2V5UGFyYW1zKVxuICAgICAgOiBwYXJhbWV0ZXJzLmtleVBhcmFtcykgK1xuICAgIChwYXJhbWV0ZXJzLnNlc3Npb25QYXJhbXMgPyAnICcgKyBwYXJhbWV0ZXJzLnNlc3Npb25QYXJhbXMuam9pbignICcpIDogJycpICtcbiAgICAnXFxyXFxuJztcbn07XG5cbi8vIFBhcnNlcyB0aGUgY3J5cHRvIGtleSBwYXJhbWV0ZXJzIGludG9cbi8vICAgaHR0cHM6Ly9yYXdnaXQuY29tL2Fib2JhL2VkZ2VydGMvbWFzdGVyL21zb3J0Yy1yczQuaHRtbCNydGNzcnRwa2V5cGFyYW0qXG5TRFBVdGlscy5wYXJzZUNyeXB0b0tleVBhcmFtcyA9IGZ1bmN0aW9uKGtleVBhcmFtcykge1xuICBpZiAoa2V5UGFyYW1zLmluZGV4T2YoJ2lubGluZTonKSAhPT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHBhcnRzID0ga2V5UGFyYW1zLnN1YnN0cmluZyg3KS5zcGxpdCgnfCcpO1xuICByZXR1cm4ge1xuICAgIGtleU1ldGhvZDogJ2lubGluZScsXG4gICAga2V5U2FsdDogcGFydHNbMF0sXG4gICAgbGlmZVRpbWU6IHBhcnRzWzFdLFxuICAgIG1raVZhbHVlOiBwYXJ0c1syXSA/IHBhcnRzWzJdLnNwbGl0KCc6JylbMF0gOiB1bmRlZmluZWQsXG4gICAgbWtpTGVuZ3RoOiBwYXJ0c1syXSA/IHBhcnRzWzJdLnNwbGl0KCc6JylbMV0gOiB1bmRlZmluZWQsXG4gIH07XG59O1xuXG5TRFBVdGlscy53cml0ZUNyeXB0b0tleVBhcmFtcyA9IGZ1bmN0aW9uKGtleVBhcmFtcykge1xuICByZXR1cm4ga2V5UGFyYW1zLmtleU1ldGhvZCArICc6J1xuICAgICsga2V5UGFyYW1zLmtleVNhbHQgK1xuICAgIChrZXlQYXJhbXMubGlmZVRpbWUgPyAnfCcgKyBrZXlQYXJhbXMubGlmZVRpbWUgOiAnJykgK1xuICAgIChrZXlQYXJhbXMubWtpVmFsdWUgJiYga2V5UGFyYW1zLm1raUxlbmd0aFxuICAgICAgPyAnfCcgKyBrZXlQYXJhbXMubWtpVmFsdWUgKyAnOicgKyBrZXlQYXJhbXMubWtpTGVuZ3RoXG4gICAgICA6ICcnKTtcbn07XG5cbi8vIEV4dHJhY3RzIGFsbCBTREVTIHBhcmFtZXRlcnMuXG5TRFBVdGlscy5nZXRDcnlwdG9QYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LFxuICAgICdhPWNyeXB0bzonKTtcbiAgcmV0dXJuIGxpbmVzLm1hcChTRFBVdGlscy5wYXJzZUNyeXB0b0xpbmUpO1xufTtcblxuLy8gUGFyc2VzIElDRSBpbmZvcm1hdGlvbiBmcm9tIFNEUCBtZWRpYSBzZWN0aW9uIG9yIHNlc3Npb25wYXJ0LlxuLy8gRklYTUU6IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGZ1bmN0aW9ucyB0aGlzIHNob3VsZCBvbmx5XG4vLyAgIGdldCB0aGUgaWNlLXVmcmFnIGFuZCBpY2UtcHdkIGxpbmVzIGFzIGlucHV0LlxuU0RQVXRpbHMuZ2V0SWNlUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgY29uc3QgdWZyYWcgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCxcbiAgICAnYT1pY2UtdWZyYWc6JylbMF07XG4gIGNvbnN0IHB3ZCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LFxuICAgICdhPWljZS1wd2Q6JylbMF07XG4gIGlmICghKHVmcmFnICYmIHB3ZCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHVzZXJuYW1lRnJhZ21lbnQ6IHVmcmFnLnN1YnN0cmluZygxMiksXG4gICAgcGFzc3dvcmQ6IHB3ZC5zdWJzdHJpbmcoMTApLFxuICB9O1xufTtcblxuLy8gU2VyaWFsaXplcyBJQ0UgcGFyYW1ldGVycyB0byBTRFAuXG5TRFBVdGlscy53cml0ZUljZVBhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgbGV0IHNkcCA9ICdhPWljZS11ZnJhZzonICsgcGFyYW1zLnVzZXJuYW1lRnJhZ21lbnQgKyAnXFxyXFxuJyArXG4gICAgICAnYT1pY2UtcHdkOicgKyBwYXJhbXMucGFzc3dvcmQgKyAnXFxyXFxuJztcbiAgaWYgKHBhcmFtcy5pY2VMaXRlKSB7XG4gICAgc2RwICs9ICdhPWljZS1saXRlXFxyXFxuJztcbiAgfVxuICByZXR1cm4gc2RwO1xufTtcblxuLy8gUGFyc2VzIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBhbmQgcmV0dXJucyBSVENSdHBQYXJhbWV0ZXJzLlxuU0RQVXRpbHMucGFyc2VSdHBQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0ge1xuICAgIGNvZGVjczogW10sXG4gICAgaGVhZGVyRXh0ZW5zaW9uczogW10sXG4gICAgZmVjTWVjaGFuaXNtczogW10sXG4gICAgcnRjcDogW10sXG4gIH07XG4gIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICBjb25zdCBtbGluZSA9IGxpbmVzWzBdLnNwbGl0KCcgJyk7XG4gIGRlc2NyaXB0aW9uLnByb2ZpbGUgPSBtbGluZVsyXTtcbiAgZm9yIChsZXQgaSA9IDM7IGkgPCBtbGluZS5sZW5ndGg7IGkrKykgeyAvLyBmaW5kIGFsbCBjb2RlY3MgZnJvbSBtbGluZVszLi5dXG4gICAgY29uc3QgcHQgPSBtbGluZVtpXTtcbiAgICBjb25zdCBydHBtYXBsaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoXG4gICAgICBtZWRpYVNlY3Rpb24sICdhPXJ0cG1hcDonICsgcHQgKyAnICcpWzBdO1xuICAgIGlmIChydHBtYXBsaW5lKSB7XG4gICAgICBjb25zdCBjb2RlYyA9IFNEUFV0aWxzLnBhcnNlUnRwTWFwKHJ0cG1hcGxpbmUpO1xuICAgICAgY29uc3QgZm10cHMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChcbiAgICAgICAgbWVkaWFTZWN0aW9uLCAnYT1mbXRwOicgKyBwdCArICcgJyk7XG4gICAgICAvLyBPbmx5IHRoZSBmaXJzdCBhPWZtdHA6PHB0PiBpcyBjb25zaWRlcmVkLlxuICAgICAgY29kZWMucGFyYW1ldGVycyA9IGZtdHBzLmxlbmd0aCA/IFNEUFV0aWxzLnBhcnNlRm10cChmbXRwc1swXSkgOiB7fTtcbiAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjayA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KFxuICAgICAgICBtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtZmI6JyArIHB0ICsgJyAnKVxuICAgICAgICAubWFwKFNEUFV0aWxzLnBhcnNlUnRjcEZiKTtcbiAgICAgIGRlc2NyaXB0aW9uLmNvZGVjcy5wdXNoKGNvZGVjKTtcbiAgICAgIC8vIHBhcnNlIEZFQyBtZWNoYW5pc21zIGZyb20gcnRwbWFwIGxpbmVzLlxuICAgICAgc3dpdGNoIChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnUkVEJzpcbiAgICAgICAgY2FzZSAnVUxQRkVDJzpcbiAgICAgICAgICBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLnB1c2goY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDogLy8gb25seSBSRUQgYW5kIFVMUEZFQyBhcmUgcmVjb2duaXplZCBhcyBGRUMgbWVjaGFuaXNtcy5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1leHRtYXA6JykuZm9yRWFjaChsaW5lID0+IHtcbiAgICBkZXNjcmlwdGlvbi5oZWFkZXJFeHRlbnNpb25zLnB1c2goU0RQVXRpbHMucGFyc2VFeHRtYXAobGluZSkpO1xuICB9KTtcbiAgY29uc3Qgd2lsZGNhcmRSdGNwRmIgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtZmI6KiAnKVxuICAgIC5tYXAoU0RQVXRpbHMucGFyc2VSdGNwRmIpO1xuICBkZXNjcmlwdGlvbi5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgd2lsZGNhcmRSdGNwRmIuZm9yRWFjaChmYj0+IHtcbiAgICAgIGNvbnN0IGR1cGxpY2F0ZSA9IGNvZGVjLnJ0Y3BGZWVkYmFjay5maW5kKGV4aXN0aW5nRmVlZGJhY2sgPT4ge1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdGZWVkYmFjay50eXBlID09PSBmYi50eXBlICYmXG4gICAgICAgICAgZXhpc3RpbmdGZWVkYmFjay5wYXJhbWV0ZXIgPT09IGZiLnBhcmFtZXRlcjtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFkdXBsaWNhdGUpIHtcbiAgICAgICAgY29kZWMucnRjcEZlZWRiYWNrLnB1c2goZmIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgLy8gRklYTUU6IHBhcnNlIHJ0Y3AuXG4gIHJldHVybiBkZXNjcmlwdGlvbjtcbn07XG5cbi8vIEdlbmVyYXRlcyBwYXJ0cyBvZiB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gZGVzY3JpYmluZyB0aGUgY2FwYWJpbGl0aWVzIC9cbi8vIHBhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZVJ0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24oa2luZCwgY2Fwcykge1xuICBsZXQgc2RwID0gJyc7XG5cbiAgLy8gQnVpbGQgdGhlIG1saW5lLlxuICBzZHAgKz0gJ209JyArIGtpbmQgKyAnICc7XG4gIHNkcCArPSBjYXBzLmNvZGVjcy5sZW5ndGggPiAwID8gJzknIDogJzAnOyAvLyByZWplY3QgaWYgbm8gY29kZWNzLlxuICBzZHAgKz0gJyAnICsgKGNhcHMucHJvZmlsZSB8fCAnVURQL1RMUy9SVFAvU0FWUEYnKSArICcgJztcbiAgc2RwICs9IGNhcHMuY29kZWNzLm1hcChjb2RlYyA9PiB7XG4gICAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVjLnBheWxvYWRUeXBlO1xuICB9KS5qb2luKCcgJykgKyAnXFxyXFxuJztcblxuICBzZHAgKz0gJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nO1xuICBzZHAgKz0gJ2E9cnRjcDo5IElOIElQNCAwLjAuMC4wXFxyXFxuJztcblxuICAvLyBBZGQgYT1ydHBtYXAgbGluZXMgZm9yIGVhY2ggY29kZWMuIEFsc28gZm10cCBhbmQgcnRjcC1mYi5cbiAgY2Fwcy5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgc2RwICs9IFNEUFV0aWxzLndyaXRlUnRwTWFwKGNvZGVjKTtcbiAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVGbXRwKGNvZGVjKTtcbiAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVSdGNwRmIoY29kZWMpO1xuICB9KTtcbiAgbGV0IG1heHB0aW1lID0gMDtcbiAgY2Fwcy5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgaWYgKGNvZGVjLm1heHB0aW1lID4gbWF4cHRpbWUpIHtcbiAgICAgIG1heHB0aW1lID0gY29kZWMubWF4cHRpbWU7XG4gICAgfVxuICB9KTtcbiAgaWYgKG1heHB0aW1lID4gMCkge1xuICAgIHNkcCArPSAnYT1tYXhwdGltZTonICsgbWF4cHRpbWUgKyAnXFxyXFxuJztcbiAgfVxuXG4gIGlmIChjYXBzLmhlYWRlckV4dGVuc2lvbnMpIHtcbiAgICBjYXBzLmhlYWRlckV4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgICAgc2RwICs9IFNEUFV0aWxzLndyaXRlRXh0bWFwKGV4dGVuc2lvbik7XG4gICAgfSk7XG4gIH1cbiAgLy8gRklYTUU6IHdyaXRlIGZlY01lY2hhbmlzbXMuXG4gIHJldHVybiBzZHA7XG59O1xuXG4vLyBQYXJzZXMgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mXG4vLyBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnMuXG5TRFBVdGlscy5wYXJzZVJ0cEVuY29kaW5nUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBlbmNvZGluZ1BhcmFtZXRlcnMgPSBbXTtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBTRFBVdGlscy5wYXJzZVJ0cFBhcmFtZXRlcnMobWVkaWFTZWN0aW9uKTtcbiAgY29uc3QgaGFzUmVkID0gZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5pbmRleE9mKCdSRUQnKSAhPT0gLTE7XG4gIGNvbnN0IGhhc1VscGZlYyA9IGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMuaW5kZXhPZignVUxQRkVDJykgIT09IC0xO1xuXG4gIC8vIGZpbHRlciBhPXNzcmM6Li4uIGNuYW1lOiwgaWdub3JlIFBsYW5CLW1zaWRcbiAgY29uc3Qgc3NyY3MgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JylcbiAgICAubWFwKGxpbmUgPT4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSkpXG4gICAgLmZpbHRlcihwYXJ0cyA9PiBwYXJ0cy5hdHRyaWJ1dGUgPT09ICdjbmFtZScpO1xuICBjb25zdCBwcmltYXJ5U3NyYyA9IHNzcmNzLmxlbmd0aCA+IDAgJiYgc3NyY3NbMF0uc3NyYztcbiAgbGV0IHNlY29uZGFyeVNzcmM7XG5cbiAgY29uc3QgZmxvd3MgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmMtZ3JvdXA6RklEJylcbiAgICAubWFwKGxpbmUgPT4ge1xuICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxNykuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiBwYXJ0cy5tYXAocGFydCA9PiBwYXJzZUludChwYXJ0LCAxMCkpO1xuICAgIH0pO1xuICBpZiAoZmxvd3MubGVuZ3RoID4gMCAmJiBmbG93c1swXS5sZW5ndGggPiAxICYmIGZsb3dzWzBdWzBdID09PSBwcmltYXJ5U3NyYykge1xuICAgIHNlY29uZGFyeVNzcmMgPSBmbG93c1swXVsxXTtcbiAgfVxuXG4gIGRlc2NyaXB0aW9uLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICBpZiAoY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpID09PSAnUlRYJyAmJiBjb2RlYy5wYXJhbWV0ZXJzLmFwdCkge1xuICAgICAgbGV0IGVuY1BhcmFtID0ge1xuICAgICAgICBzc3JjOiBwcmltYXJ5U3NyYyxcbiAgICAgICAgY29kZWNQYXlsb2FkVHlwZTogcGFyc2VJbnQoY29kZWMucGFyYW1ldGVycy5hcHQsIDEwKSxcbiAgICAgIH07XG4gICAgICBpZiAocHJpbWFyeVNzcmMgJiYgc2Vjb25kYXJ5U3NyYykge1xuICAgICAgICBlbmNQYXJhbS5ydHggPSB7c3NyYzogc2Vjb25kYXJ5U3NyY307XG4gICAgICB9XG4gICAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaChlbmNQYXJhbSk7XG4gICAgICBpZiAoaGFzUmVkKSB7XG4gICAgICAgIGVuY1BhcmFtID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbmNQYXJhbSkpO1xuICAgICAgICBlbmNQYXJhbS5mZWMgPSB7XG4gICAgICAgICAgc3NyYzogcHJpbWFyeVNzcmMsXG4gICAgICAgICAgbWVjaGFuaXNtOiBoYXNVbHBmZWMgPyAncmVkK3VscGZlYycgOiAncmVkJyxcbiAgICAgICAgfTtcbiAgICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goZW5jUGFyYW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmIChlbmNvZGluZ1BhcmFtZXRlcnMubGVuZ3RoID09PSAwICYmIHByaW1hcnlTc3JjKSB7XG4gICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goe1xuICAgICAgc3NyYzogcHJpbWFyeVNzcmMsXG4gICAgfSk7XG4gIH1cblxuICAvLyB3ZSBzdXBwb3J0IGJvdGggYj1BUyBhbmQgYj1USUFTIGJ1dCBpbnRlcnByZXQgQVMgYXMgVElBUy5cbiAgbGV0IGJhbmR3aWR0aCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2I9Jyk7XG4gIGlmIChiYW5kd2lkdGgubGVuZ3RoKSB7XG4gICAgaWYgKGJhbmR3aWR0aFswXS5pbmRleE9mKCdiPVRJQVM6JykgPT09IDApIHtcbiAgICAgIGJhbmR3aWR0aCA9IHBhcnNlSW50KGJhbmR3aWR0aFswXS5zdWJzdHJpbmcoNyksIDEwKTtcbiAgICB9IGVsc2UgaWYgKGJhbmR3aWR0aFswXS5pbmRleE9mKCdiPUFTOicpID09PSAwKSB7XG4gICAgICAvLyB1c2UgZm9ybXVsYSBmcm9tIEpTRVAgdG8gY29udmVydCBiPUFTIHRvIFRJQVMgdmFsdWUuXG4gICAgICBiYW5kd2lkdGggPSBwYXJzZUludChiYW5kd2lkdGhbMF0uc3Vic3RyaW5nKDUpLCAxMCkgKiAxMDAwICogMC45NVxuICAgICAgICAgIC0gKDUwICogNDAgKiA4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFuZHdpZHRoID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbmNvZGluZ1BhcmFtZXRlcnMuZm9yRWFjaChwYXJhbXMgPT4ge1xuICAgICAgcGFyYW1zLm1heEJpdHJhdGUgPSBiYW5kd2lkdGg7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGVuY29kaW5nUGFyYW1ldGVycztcbn07XG5cbi8vIHBhcnNlcyBodHRwOi8vZHJhZnQub3J0Yy5vcmcvI3J0Y3J0Y3BwYXJhbWV0ZXJzKlxuU0RQVXRpbHMucGFyc2VSdGNwUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBydGNwUGFyYW1ldGVycyA9IHt9O1xuXG4gIC8vIEdldHMgdGhlIGZpcnN0IFNTUkMuIE5vdGUgdGhhdCB3aXRoIFJUWCB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZVxuICAvLyBTU1JDcy5cbiAgY29uc3QgcmVtb3RlU3NyYyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKVxuICAgIC5tYXAobGluZSA9PiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKSlcbiAgICAuZmlsdGVyKG9iaiA9PiBvYmouYXR0cmlidXRlID09PSAnY25hbWUnKVswXTtcbiAgaWYgKHJlbW90ZVNzcmMpIHtcbiAgICBydGNwUGFyYW1ldGVycy5jbmFtZSA9IHJlbW90ZVNzcmMudmFsdWU7XG4gICAgcnRjcFBhcmFtZXRlcnMuc3NyYyA9IHJlbW90ZVNzcmMuc3NyYztcbiAgfVxuXG4gIC8vIEVkZ2UgdXNlcyB0aGUgY29tcG91bmQgYXR0cmlidXRlIGluc3RlYWQgb2YgcmVkdWNlZFNpemVcbiAgLy8gY29tcG91bmQgaXMgIXJlZHVjZWRTaXplXG4gIGNvbnN0IHJzaXplID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLXJzaXplJyk7XG4gIHJ0Y3BQYXJhbWV0ZXJzLnJlZHVjZWRTaXplID0gcnNpemUubGVuZ3RoID4gMDtcbiAgcnRjcFBhcmFtZXRlcnMuY29tcG91bmQgPSByc2l6ZS5sZW5ndGggPT09IDA7XG5cbiAgLy8gcGFyc2VzIHRoZSBydGNwLW11eCBhdHRy0ZZidXRlLlxuICAvLyBOb3RlIHRoYXQgRWRnZSBkb2VzIG5vdCBzdXBwb3J0IHVubXV4ZWQgUlRDUC5cbiAgY29uc3QgbXV4ID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLW11eCcpO1xuICBydGNwUGFyYW1ldGVycy5tdXggPSBtdXgubGVuZ3RoID4gMDtcblxuICByZXR1cm4gcnRjcFBhcmFtZXRlcnM7XG59O1xuXG5TRFBVdGlscy53cml0ZVJ0Y3BQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocnRjcFBhcmFtZXRlcnMpIHtcbiAgbGV0IHNkcCA9ICcnO1xuICBpZiAocnRjcFBhcmFtZXRlcnMucmVkdWNlZFNpemUpIHtcbiAgICBzZHAgKz0gJ2E9cnRjcC1yc2l6ZVxcclxcbic7XG4gIH1cbiAgaWYgKHJ0Y3BQYXJhbWV0ZXJzLm11eCkge1xuICAgIHNkcCArPSAnYT1ydGNwLW11eFxcclxcbic7XG4gIH1cbiAgaWYgKHJ0Y3BQYXJhbWV0ZXJzLnNzcmMgIT09IHVuZGVmaW5lZCAmJiBydGNwUGFyYW1ldGVycy5jbmFtZSkge1xuICAgIHNkcCArPSAnYT1zc3JjOicgKyBydGNwUGFyYW1ldGVycy5zc3JjICtcbiAgICAgICcgY25hbWU6JyArIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lICsgJ1xcclxcbic7XG4gIH1cbiAgcmV0dXJuIHNkcDtcbn07XG5cblxuLy8gcGFyc2VzIGVpdGhlciBhPW1zaWQ6IG9yIGE9c3NyYzouLi4gbXNpZCBsaW5lcyBhbmQgcmV0dXJuc1xuLy8gdGhlIGlkIG9mIHRoZSBNZWRpYVN0cmVhbSBhbmQgTWVkaWFTdHJlYW1UcmFjay5cblNEUFV0aWxzLnBhcnNlTXNpZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBsZXQgcGFydHM7XG4gIGNvbnN0IHNwZWMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1zaWQ6Jyk7XG4gIGlmIChzcGVjLmxlbmd0aCA9PT0gMSkge1xuICAgIHBhcnRzID0gc3BlY1swXS5zdWJzdHJpbmcoNykuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge3N0cmVhbTogcGFydHNbMF0sIHRyYWNrOiBwYXJ0c1sxXX07XG4gIH1cbiAgY29uc3QgcGxhbkIgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JylcbiAgICAubWFwKGxpbmUgPT4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSkpXG4gICAgLmZpbHRlcihtc2lkUGFydHMgPT4gbXNpZFBhcnRzLmF0dHJpYnV0ZSA9PT0gJ21zaWQnKTtcbiAgaWYgKHBsYW5CLmxlbmd0aCA+IDApIHtcbiAgICBwYXJ0cyA9IHBsYW5CWzBdLnZhbHVlLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtzdHJlYW06IHBhcnRzWzBdLCB0cmFjazogcGFydHNbMV19O1xuICB9XG59O1xuXG4vLyBTQ1RQXG4vLyBwYXJzZXMgZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYgZmlyc3QgYW5kIGZhbGxzIGJhY2tcbi8vIHRvIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTA1XG5TRFBVdGlscy5wYXJzZVNjdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBtbGluZSA9IFNEUFV0aWxzLnBhcnNlTUxpbmUobWVkaWFTZWN0aW9uKTtcbiAgY29uc3QgbWF4U2l6ZUxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1heC1tZXNzYWdlLXNpemU6Jyk7XG4gIGxldCBtYXhNZXNzYWdlU2l6ZTtcbiAgaWYgKG1heFNpemVMaW5lLmxlbmd0aCA+IDApIHtcbiAgICBtYXhNZXNzYWdlU2l6ZSA9IHBhcnNlSW50KG1heFNpemVMaW5lWzBdLnN1YnN0cmluZygxOSksIDEwKTtcbiAgfVxuICBpZiAoaXNOYU4obWF4TWVzc2FnZVNpemUpKSB7XG4gICAgbWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcbiAgfVxuICBjb25zdCBzY3RwUG9ydCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c2N0cC1wb3J0OicpO1xuICBpZiAoc2N0cFBvcnQubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBwb3J0OiBwYXJzZUludChzY3RwUG9ydFswXS5zdWJzdHJpbmcoMTIpLCAxMCksXG4gICAgICBwcm90b2NvbDogbWxpbmUuZm10LFxuICAgICAgbWF4TWVzc2FnZVNpemUsXG4gICAgfTtcbiAgfVxuICBjb25zdCBzY3RwTWFwTGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNjdHBtYXA6Jyk7XG4gIGlmIChzY3RwTWFwTGluZXMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHBhcnRzID0gc2N0cE1hcExpbmVzWzBdXG4gICAgICAuc3Vic3RyaW5nKDEwKVxuICAgICAgLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgICBwcm90b2NvbDogcGFydHNbMV0sXG4gICAgICBtYXhNZXNzYWdlU2l6ZSxcbiAgICB9O1xuICB9XG59O1xuXG4vLyBTQ1RQXG4vLyBvdXRwdXRzIHRoZSBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiB2ZXJzaW9uIHRoYXQgYWxsIGJyb3dzZXJzXG4vLyBzdXBwb3J0IGJ5IG5vdyByZWNlaXZpbmcgaW4gdGhpcyBmb3JtYXQsIHVubGVzcyB3ZSBvcmlnaW5hbGx5IHBhcnNlZFxuLy8gYXMgdGhlIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTA1IGZvcm1hdCAoaW5kaWNhdGVkIGJ5IHRoZSBtLWxpbmVcbi8vIHByb3RvY29sIG9mIERUTFMvU0NUUCAtLSB3aXRob3V0IFVEUC8gb3IgVENQLylcblNEUFV0aWxzLndyaXRlU2N0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24obWVkaWEsIHNjdHApIHtcbiAgbGV0IG91dHB1dCA9IFtdO1xuICBpZiAobWVkaWEucHJvdG9jb2wgIT09ICdEVExTL1NDVFAnKSB7XG4gICAgb3V0cHV0ID0gW1xuICAgICAgJ209JyArIG1lZGlhLmtpbmQgKyAnIDkgJyArIG1lZGlhLnByb3RvY29sICsgJyAnICsgc2N0cC5wcm90b2NvbCArICdcXHJcXG4nLFxuICAgICAgJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nLFxuICAgICAgJ2E9c2N0cC1wb3J0OicgKyBzY3RwLnBvcnQgKyAnXFxyXFxuJyxcbiAgICBdO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IFtcbiAgICAgICdtPScgKyBtZWRpYS5raW5kICsgJyA5ICcgKyBtZWRpYS5wcm90b2NvbCArICcgJyArIHNjdHAucG9ydCArICdcXHJcXG4nLFxuICAgICAgJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nLFxuICAgICAgJ2E9c2N0cG1hcDonICsgc2N0cC5wb3J0ICsgJyAnICsgc2N0cC5wcm90b2NvbCArICcgNjU1MzVcXHJcXG4nLFxuICAgIF07XG4gIH1cbiAgaWYgKHNjdHAubWF4TWVzc2FnZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgIG91dHB1dC5wdXNoKCdhPW1heC1tZXNzYWdlLXNpemU6JyArIHNjdHAubWF4TWVzc2FnZVNpemUgKyAnXFxyXFxuJyk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn07XG5cbi8vIEdlbmVyYXRlIGEgc2Vzc2lvbiBJRCBmb3IgU0RQLlxuLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtcnRjd2ViLWpzZXAtMjAjc2VjdGlvbi01LjIuMVxuLy8gcmVjb21tZW5kcyB1c2luZyBhIGNyeXB0b2dyYXBoaWNhbGx5IHJhbmRvbSArdmUgNjQtYml0IHZhbHVlXG4vLyBidXQgcmlnaHQgbm93IHRoaXMgc2hvdWxkIGJlIGFjY2VwdGFibGUgYW5kIHdpdGhpbiB0aGUgcmlnaHQgcmFuZ2VcblNEUFV0aWxzLmdlbmVyYXRlU2Vzc2lvbklkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkuc3Vic3RyKDIsIDIyKTtcbn07XG5cbi8vIFdyaXRlIGJvaWxlciBwbGF0ZSBmb3Igc3RhcnQgb2YgU0RQXG4vLyBzZXNzSWQgYXJndW1lbnQgaXMgb3B0aW9uYWwgLSBpZiBub3Qgc3VwcGxpZWQgaXQgd2lsbFxuLy8gYmUgZ2VuZXJhdGVkIHJhbmRvbWx5XG4vLyBzZXNzVmVyc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gMlxuLy8gc2Vzc1VzZXIgaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvICd0aGlzaXNhZGFwdGVyb3J0YydcblNEUFV0aWxzLndyaXRlU2Vzc2lvbkJvaWxlcnBsYXRlID0gZnVuY3Rpb24oc2Vzc0lkLCBzZXNzVmVyLCBzZXNzVXNlcikge1xuICBsZXQgc2Vzc2lvbklkO1xuICBjb25zdCB2ZXJzaW9uID0gc2Vzc1ZlciAhPT0gdW5kZWZpbmVkID8gc2Vzc1ZlciA6IDI7XG4gIGlmIChzZXNzSWQpIHtcbiAgICBzZXNzaW9uSWQgPSBzZXNzSWQ7XG4gIH0gZWxzZSB7XG4gICAgc2Vzc2lvbklkID0gU0RQVXRpbHMuZ2VuZXJhdGVTZXNzaW9uSWQoKTtcbiAgfVxuICBjb25zdCB1c2VyID0gc2Vzc1VzZXIgfHwgJ3RoaXNpc2FkYXB0ZXJvcnRjJztcbiAgLy8gRklYTUU6IHNlc3MtaWQgc2hvdWxkIGJlIGFuIE5UUCB0aW1lc3RhbXAuXG4gIHJldHVybiAndj0wXFxyXFxuJyArXG4gICAgICAnbz0nICsgdXNlciArICcgJyArIHNlc3Npb25JZCArICcgJyArIHZlcnNpb24gK1xuICAgICAgICAnIElOIElQNCAxMjcuMC4wLjFcXHJcXG4nICtcbiAgICAgICdzPS1cXHJcXG4nICtcbiAgICAgICd0PTAgMFxcclxcbic7XG59O1xuXG4vLyBHZXRzIHRoZSBkaXJlY3Rpb24gZnJvbSB0aGUgbWVkaWFTZWN0aW9uIG9yIHRoZSBzZXNzaW9ucGFydC5cblNEUFV0aWxzLmdldERpcmVjdGlvbiA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgLy8gTG9vayBmb3Igc2VuZHJlY3YsIHNlbmRvbmx5LCByZWN2b25seSwgaW5hY3RpdmUsIGRlZmF1bHQgdG8gc2VuZHJlY3YuXG4gIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3dpdGNoIChsaW5lc1tpXSkge1xuICAgICAgY2FzZSAnYT1zZW5kcmVjdic6XG4gICAgICBjYXNlICdhPXNlbmRvbmx5JzpcbiAgICAgIGNhc2UgJ2E9cmVjdm9ubHknOlxuICAgICAgY2FzZSAnYT1pbmFjdGl2ZSc6XG4gICAgICAgIHJldHVybiBsaW5lc1tpXS5zdWJzdHJpbmcoMik7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBGSVhNRTogV2hhdCBzaG91bGQgaGFwcGVuIGhlcmU/XG4gICAgfVxuICB9XG4gIGlmIChzZXNzaW9ucGFydCkge1xuICAgIHJldHVybiBTRFBVdGlscy5nZXREaXJlY3Rpb24oc2Vzc2lvbnBhcnQpO1xuICB9XG4gIHJldHVybiAnc2VuZHJlY3YnO1xufTtcblxuU0RQVXRpbHMuZ2V0S2luZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgY29uc3QgbWxpbmUgPSBsaW5lc1swXS5zcGxpdCgnICcpO1xuICByZXR1cm4gbWxpbmVbMF0uc3Vic3RyaW5nKDIpO1xufTtcblxuU0RQVXRpbHMuaXNSZWplY3RlZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICByZXR1cm4gbWVkaWFTZWN0aW9uLnNwbGl0KCcgJywgMilbMV0gPT09ICcwJztcbn07XG5cblNEUFV0aWxzLnBhcnNlTUxpbmUgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gIGNvbnN0IHBhcnRzID0gbGluZXNbMF0uc3Vic3RyaW5nKDIpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAga2luZDogcGFydHNbMF0sXG4gICAgcG9ydDogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICBwcm90b2NvbDogcGFydHNbMl0sXG4gICAgZm10OiBwYXJ0cy5zbGljZSgzKS5qb2luKCcgJyksXG4gIH07XG59O1xuXG5TRFBVdGlscy5wYXJzZU9MaW5lID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGNvbnN0IGxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdvPScpWzBdO1xuICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDIpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgdXNlcm5hbWU6IHBhcnRzWzBdLFxuICAgIHNlc3Npb25JZDogcGFydHNbMV0sXG4gICAgc2Vzc2lvblZlcnNpb246IHBhcnNlSW50KHBhcnRzWzJdLCAxMCksXG4gICAgbmV0VHlwZTogcGFydHNbM10sXG4gICAgYWRkcmVzc1R5cGU6IHBhcnRzWzRdLFxuICAgIGFkZHJlc3M6IHBhcnRzWzVdLFxuICB9O1xufTtcblxuLy8gYSB2ZXJ5IG5haXZlIGludGVycHJldGF0aW9uIG9mIGEgdmFsaWQgU0RQLlxuU0RQVXRpbHMuaXNWYWxpZFNEUCA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgaWYgKHR5cGVvZiBibG9iICE9PSAnc3RyaW5nJyB8fCBibG9iLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMoYmxvYik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobGluZXNbaV0ubGVuZ3RoIDwgMiB8fCBsaW5lc1tpXS5jaGFyQXQoMSkgIT09ICc9Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBUT0RPOiBjaGVjayB0aGUgbW9kaWZpZXIgYSBiaXQgbW9yZS5cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcy5cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICBtb2R1bGUuZXhwb3J0cyA9IFNEUFV0aWxzO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/sdp/sdp.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/webrtc-adapter/src/js/adapter_core.js":
/*!************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/adapter_core.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _adapter_factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapter_factory.js */ \"(app-pages-browser)/./node_modules/webrtc-adapter/src/js/adapter_factory.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\n\n\nconst adapter =\n  (0,_adapter_factory_js__WEBPACK_IMPORTED_MODULE_0__.adapterFactory)({window: typeof window === 'undefined' ? undefined : window});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (adapter);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvYWRhcHRlcl9jb3JlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFdUM7O0FBRXBEO0FBQ0EsRUFBRSxtRUFBYyxFQUFFLDJEQUEyRDtBQUM3RSxpRUFBZSxPQUFPLEVBQUMiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9hZGFwdGVyX2NvcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge2FkYXB0ZXJGYWN0b3J5fSBmcm9tICcuL2FkYXB0ZXJfZmFjdG9yeS5qcyc7XG5cbmNvbnN0IGFkYXB0ZXIgPVxuICBhZGFwdGVyRmFjdG9yeSh7d2luZG93OiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IHdpbmRvd30pO1xuZXhwb3J0IGRlZmF1bHQgYWRhcHRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/webrtc-adapter/src/js/adapter_core.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/webrtc-adapter/src/js/adapter_factory.js":
/*!***************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/adapter_factory.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   adapterFactory: () => (/* binding */ adapterFactory)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/webrtc-adapter/src/js/utils.js\");\n/* harmony import */ var _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chrome/chrome_shim */ \"(app-pages-browser)/./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js\");\n/* harmony import */ var _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./firefox/firefox_shim */ \"(app-pages-browser)/./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js\");\n/* harmony import */ var _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./safari/safari_shim */ \"(app-pages-browser)/./node_modules/webrtc-adapter/src/js/safari/safari_shim.js\");\n/* harmony import */ var _common_shim__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./common_shim */ \"(app-pages-browser)/./node_modules/webrtc-adapter/src/js/common_shim.js\");\n/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! sdp */ \"(app-pages-browser)/./node_modules/sdp/sdp.js\");\n/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(sdp__WEBPACK_IMPORTED_MODULE_5__);\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n\n// Browser shims.\n\n\n\n\n\n\n// Shimming starts here.\nfunction adapterFactory({window} = {}, options = {\n  shimChrome: true,\n  shimFirefox: true,\n  shimSafari: true,\n}) {\n  // Utils.\n  const logging = _utils__WEBPACK_IMPORTED_MODULE_0__.log;\n  const browserDetails = _utils__WEBPACK_IMPORTED_MODULE_0__.detectBrowser(window);\n\n  const adapter = {\n    browserDetails,\n    commonShim: _common_shim__WEBPACK_IMPORTED_MODULE_4__,\n    extractVersion: _utils__WEBPACK_IMPORTED_MODULE_0__.extractVersion,\n    disableLog: _utils__WEBPACK_IMPORTED_MODULE_0__.disableLog,\n    disableWarnings: _utils__WEBPACK_IMPORTED_MODULE_0__.disableWarnings,\n    // Expose sdp as a convenience. For production apps include directly.\n    sdp: sdp__WEBPACK_IMPORTED_MODULE_5__,\n  };\n\n  // Shim browser if found.\n  switch (browserDetails.browser) {\n    case 'chrome':\n      if (!_chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__ || !_chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimPeerConnection ||\n          !options.shimChrome) {\n        logging('Chrome shim is not included in this adapter release.');\n        return adapter;\n      }\n      if (browserDetails.version === null) {\n        logging('Chrome shim can not determine version, not shimming.');\n        return adapter;\n      }\n      logging('adapter.js shimming chrome.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__;\n\n      // Must be called before shimPeerConnection.\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimAddIceCandidateNullOrEmpty(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimParameterlessSetLocalDescription(window, browserDetails);\n\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimGetUserMedia(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimMediaStream(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimPeerConnection(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimOnTrack(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimAddTrackRemoveTrack(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimGetSendersWithDtmf(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimSenderReceiverGetStats(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.fixNegotiationNeeded(window, browserDetails);\n\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidate(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidateRelayProtocol(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimConnectionState(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimMaxMessageSize(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimSendThrowTypeError(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.removeExtmapAllowMixed(window, browserDetails);\n      break;\n    case 'firefox':\n      if (!_firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__ || !_firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimPeerConnection ||\n          !options.shimFirefox) {\n        logging('Firefox shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming firefox.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__;\n\n      // Must be called before shimPeerConnection.\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimAddIceCandidateNullOrEmpty(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimParameterlessSetLocalDescription(window, browserDetails);\n\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimGetUserMedia(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimPeerConnection(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimOnTrack(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimRemoveStream(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimSenderGetStats(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimReceiverGetStats(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimRTCDataChannel(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimAddTransceiver(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimGetParameters(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimCreateOffer(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimCreateAnswer(window, browserDetails);\n\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidate(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimConnectionState(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimMaxMessageSize(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimSendThrowTypeError(window, browserDetails);\n      break;\n    case 'safari':\n      if (!_safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__ || !options.shimSafari) {\n        logging('Safari shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming safari.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__;\n\n      // Must be called before shimCallbackAPI.\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimAddIceCandidateNullOrEmpty(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimParameterlessSetLocalDescription(window, browserDetails);\n\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimRTCIceServerUrls(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimCreateOfferLegacy(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimCallbacksAPI(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimLocalStreamsAPI(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimRemoteStreamsAPI(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimTrackEventTransceiver(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimGetUserMedia(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimAudioContext(window, browserDetails);\n\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidate(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidateRelayProtocol(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimMaxMessageSize(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimSendThrowTypeError(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.removeExtmapAllowMixed(window, browserDetails);\n      break;\n    default:\n      logging('Unsupported browser!');\n      break;\n  }\n\n  return adapter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvYWRhcHRlcl9mYWN0b3J5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDaUM7O0FBRWpDO0FBQ21EO0FBQ0c7QUFDSDtBQUNQO0FBQ2pCOztBQUUzQjtBQUNPLHlCQUF5QixRQUFRLElBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0JBQWtCLHVDQUFTO0FBQzNCLHlCQUF5QixpREFBbUI7O0FBRTVDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsb0JBQW9CLGtEQUFvQjtBQUN4QyxnQkFBZ0IsOENBQWdCO0FBQ2hDLHFCQUFxQixtREFBcUI7QUFDMUM7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnREFBVSxLQUFLLG1FQUE2QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnREFBVTs7QUFFdEM7QUFDQSxNQUFNLHdFQUF5QztBQUMvQyxNQUFNLDhFQUErQzs7QUFFckQsTUFBTSxpRUFBMkI7QUFDakMsTUFBTSxnRUFBMEI7QUFDaEMsTUFBTSxtRUFBNkI7QUFDbkMsTUFBTSw0REFBc0I7QUFDNUIsTUFBTSx3RUFBa0M7QUFDeEMsTUFBTSx1RUFBaUM7QUFDdkMsTUFBTSwyRUFBcUM7QUFDM0MsTUFBTSxxRUFBK0I7O0FBRXJDLE1BQU0sNkRBQThCO0FBQ3BDLE1BQU0sMEVBQTJDO0FBQ2pELE1BQU0sNkRBQThCO0FBQ3BDLE1BQU0sNERBQTZCO0FBQ25DLE1BQU0sZ0VBQWlDO0FBQ3ZDLE1BQU0sZ0VBQWlDO0FBQ3ZDO0FBQ0E7QUFDQSxXQUFXLGtEQUFXLEtBQUsscUVBQThCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrREFBVzs7QUFFdkM7QUFDQSxNQUFNLHdFQUF5QztBQUMvQyxNQUFNLDhFQUErQzs7QUFFckQsTUFBTSxtRUFBNEI7QUFDbEMsTUFBTSxxRUFBOEI7QUFDcEMsTUFBTSw4REFBdUI7QUFDN0IsTUFBTSxtRUFBNEI7QUFDbEMsTUFBTSxxRUFBOEI7QUFDcEMsTUFBTSx1RUFBZ0M7QUFDdEMsTUFBTSxxRUFBOEI7QUFDcEMsTUFBTSxxRUFBOEI7QUFDcEMsTUFBTSxvRUFBNkI7QUFDbkMsTUFBTSxrRUFBMkI7QUFDakMsTUFBTSxtRUFBNEI7O0FBRWxDLE1BQU0sNkRBQThCO0FBQ3BDLE1BQU0sNkRBQThCO0FBQ3BDLE1BQU0sNERBQTZCO0FBQ25DLE1BQU0sZ0VBQWlDO0FBQ3ZDO0FBQ0E7QUFDQSxXQUFXLGdEQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0RBQVU7O0FBRXRDO0FBQ0EsTUFBTSx3RUFBeUM7QUFDL0MsTUFBTSw4RUFBK0M7O0FBRXJELE1BQU0scUVBQStCO0FBQ3JDLE1BQU0sc0VBQWdDO0FBQ3RDLE1BQU0saUVBQTJCO0FBQ2pDLE1BQU0sb0VBQThCO0FBQ3BDLE1BQU0scUVBQStCO0FBQ3JDLE1BQU0sMEVBQW9DO0FBQzFDLE1BQU0saUVBQTJCO0FBQ2pDLE1BQU0saUVBQTJCOztBQUVqQyxNQUFNLDZEQUE4QjtBQUNwQyxNQUFNLDBFQUEyQztBQUNqRCxNQUFNLDREQUE2QjtBQUNuQyxNQUFNLGdFQUFpQztBQUN2QyxNQUFNLGdFQUFpQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9hZGFwdGVyX2ZhY3RvcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzJztcblxuLy8gQnJvd3NlciBzaGltcy5cbmltcG9ydCAqIGFzIGNocm9tZVNoaW0gZnJvbSAnLi9jaHJvbWUvY2hyb21lX3NoaW0nO1xuaW1wb3J0ICogYXMgZmlyZWZveFNoaW0gZnJvbSAnLi9maXJlZm94L2ZpcmVmb3hfc2hpbSc7XG5pbXBvcnQgKiBhcyBzYWZhcmlTaGltIGZyb20gJy4vc2FmYXJpL3NhZmFyaV9zaGltJztcbmltcG9ydCAqIGFzIGNvbW1vblNoaW0gZnJvbSAnLi9jb21tb25fc2hpbSc7XG5pbXBvcnQgKiBhcyBzZHAgZnJvbSAnc2RwJztcblxuLy8gU2hpbW1pbmcgc3RhcnRzIGhlcmUuXG5leHBvcnQgZnVuY3Rpb24gYWRhcHRlckZhY3Rvcnkoe3dpbmRvd30gPSB7fSwgb3B0aW9ucyA9IHtcbiAgc2hpbUNocm9tZTogdHJ1ZSxcbiAgc2hpbUZpcmVmb3g6IHRydWUsXG4gIHNoaW1TYWZhcmk6IHRydWUsXG59KSB7XG4gIC8vIFV0aWxzLlxuICBjb25zdCBsb2dnaW5nID0gdXRpbHMubG9nO1xuICBjb25zdCBicm93c2VyRGV0YWlscyA9IHV0aWxzLmRldGVjdEJyb3dzZXIod2luZG93KTtcblxuICBjb25zdCBhZGFwdGVyID0ge1xuICAgIGJyb3dzZXJEZXRhaWxzLFxuICAgIGNvbW1vblNoaW0sXG4gICAgZXh0cmFjdFZlcnNpb246IHV0aWxzLmV4dHJhY3RWZXJzaW9uLFxuICAgIGRpc2FibGVMb2c6IHV0aWxzLmRpc2FibGVMb2csXG4gICAgZGlzYWJsZVdhcm5pbmdzOiB1dGlscy5kaXNhYmxlV2FybmluZ3MsXG4gICAgLy8gRXhwb3NlIHNkcCBhcyBhIGNvbnZlbmllbmNlLiBGb3IgcHJvZHVjdGlvbiBhcHBzIGluY2x1ZGUgZGlyZWN0bHkuXG4gICAgc2RwLFxuICB9O1xuXG4gIC8vIFNoaW0gYnJvd3NlciBpZiBmb3VuZC5cbiAgc3dpdGNoIChicm93c2VyRGV0YWlscy5icm93c2VyKSB7XG4gICAgY2FzZSAnY2hyb21lJzpcbiAgICAgIGlmICghY2hyb21lU2hpbSB8fCAhY2hyb21lU2hpbS5zaGltUGVlckNvbm5lY3Rpb24gfHxcbiAgICAgICAgICAhb3B0aW9ucy5zaGltQ2hyb21lKSB7XG4gICAgICAgIGxvZ2dpbmcoJ0Nocm9tZSBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICBsb2dnaW5nKCdDaHJvbWUgc2hpbSBjYW4gbm90IGRldGVybWluZSB2ZXJzaW9uLCBub3Qgc2hpbW1pbmcuJyk7XG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xuICAgICAgfVxuICAgICAgbG9nZ2luZygnYWRhcHRlci5qcyBzaGltbWluZyBjaHJvbWUuJyk7XG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxuICAgICAgYWRhcHRlci5icm93c2VyU2hpbSA9IGNocm9tZVNoaW07XG5cbiAgICAgIC8vIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBzaGltUGVlckNvbm5lY3Rpb24uXG4gICAgICBjb21tb25TaGltLnNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuXG4gICAgICBjaHJvbWVTaGltLnNoaW1HZXRVc2VyTWVkaWEod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1NZWRpYVN0cmVhbSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbVBlZXJDb25uZWN0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY2hyb21lU2hpbS5zaGltT25UcmFjayh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2sod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1HZXRTZW5kZXJzV2l0aER0bWYod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY2hyb21lU2hpbS5maXhOZWdvdGlhdGlvbk5lZWRlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcblxuICAgICAgY29tbW9uU2hpbS5zaGltUlRDSWNlQ2FuZGlkYXRlKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY29tbW9uU2hpbS5zaGltUlRDSWNlQ2FuZGlkYXRlUmVsYXlQcm90b2NvbCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY29tbW9uU2hpbS5zaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY29tbW9uU2hpbS5yZW1vdmVFeHRtYXBBbGxvd01peGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZmlyZWZveCc6XG4gICAgICBpZiAoIWZpcmVmb3hTaGltIHx8ICFmaXJlZm94U2hpbS5zaGltUGVlckNvbm5lY3Rpb24gfHxcbiAgICAgICAgICAhb3B0aW9ucy5zaGltRmlyZWZveCkge1xuICAgICAgICBsb2dnaW5nKCdGaXJlZm94IHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgZmlyZWZveC4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gZmlyZWZveFNoaW07XG5cbiAgICAgIC8vIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBzaGltUGVlckNvbm5lY3Rpb24uXG4gICAgICBjb21tb25TaGltLnNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuXG4gICAgICBmaXJlZm94U2hpbS5zaGltR2V0VXNlck1lZGlhKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbVBlZXJDb25uZWN0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbU9uVHJhY2sod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltUmVtb3ZlU3RyZWFtKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbVNlbmRlckdldFN0YXRzKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbVJlY2VpdmVyR2V0U3RhdHMod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltUlRDRGF0YUNoYW5uZWwod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltQWRkVHJhbnNjZWl2ZXIod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltR2V0UGFyYW1ldGVycyh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1DcmVhdGVPZmZlcih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1DcmVhdGVBbnN3ZXIod2luZG93LCBicm93c2VyRGV0YWlscyk7XG5cbiAgICAgIGNvbW1vblNoaW0uc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY29tbW9uU2hpbS5zaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2FmYXJpJzpcbiAgICAgIGlmICghc2FmYXJpU2hpbSB8fCAhb3B0aW9ucy5zaGltU2FmYXJpKSB7XG4gICAgICAgIGxvZ2dpbmcoJ1NhZmFyaSBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIHNhZmFyaS4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gc2FmYXJpU2hpbTtcblxuICAgICAgLy8gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIHNoaW1DYWxsYmFja0FQSS5cbiAgICAgIGNvbW1vblNoaW0uc2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5KHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY29tbW9uU2hpbS5zaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24od2luZG93LCBicm93c2VyRGV0YWlscyk7XG5cbiAgICAgIHNhZmFyaVNoaW0uc2hpbVJUQ0ljZVNlcnZlclVybHMod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1DcmVhdGVPZmZlckxlZ2FjeSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNhZmFyaVNoaW0uc2hpbUNhbGxiYWNrc0FQSSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNhZmFyaVNoaW0uc2hpbUxvY2FsU3RyZWFtc0FQSSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNhZmFyaVNoaW0uc2hpbVJlbW90ZVN0cmVhbXNBUEkod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXIod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1HZXRVc2VyTWVkaWEod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1BdWRpb0NvbnRleHQod2luZG93LCBicm93c2VyRGV0YWlscyk7XG5cbiAgICAgIGNvbW1vblNoaW0uc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2wod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjb21tb25TaGltLnNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0ucmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBsb2dnaW5nKCdVbnN1cHBvcnRlZCBicm93c2VyIScpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gYWRhcHRlcjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/webrtc-adapter/src/js/adapter_factory.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fixNegotiationNeeded: () => (/* binding */ fixNegotiationNeeded),\n/* harmony export */   shimAddTrackRemoveTrack: () => (/* binding */ shimAddTrackRemoveTrack),\n/* harmony export */   shimAddTrackRemoveTrackWithNative: () => (/* binding */ shimAddTrackRemoveTrackWithNative),\n/* harmony export */   shimGetSendersWithDtmf: () => (/* binding */ shimGetSendersWithDtmf),\n/* harmony export */   shimGetUserMedia: () => (/* reexport safe */ _getusermedia__WEBPACK_IMPORTED_MODULE_1__.shimGetUserMedia),\n/* harmony export */   shimMediaStream: () => (/* binding */ shimMediaStream),\n/* harmony export */   shimOnTrack: () => (/* binding */ shimOnTrack),\n/* harmony export */   shimPeerConnection: () => (/* binding */ shimPeerConnection),\n/* harmony export */   shimSenderReceiverGetStats: () => (/* binding */ shimSenderReceiverGetStats)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/webrtc-adapter/src/js/utils.js\");\n/* harmony import */ var _getusermedia__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getusermedia */ \"(app-pages-browser)/./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\n\n\nfunction shimMediaStream(window) {\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\n}\n\nfunction shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n      window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n      get() {\n        return this._ontrack;\n      },\n      set(f) {\n        if (this._ontrack) {\n          this.removeEventListener('track', this._ontrack);\n        }\n        this.addEventListener('track', this._ontrack = f);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    const origSetRemoteDescription =\n        window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription =\n      function setRemoteDescription() {\n        if (!this._ontrackpoly) {\n          this._ontrackpoly = (e) => {\n            // onaddstream does not fire when a track is added to an existing\n            // stream. But stream.onaddtrack is implemented so we use that.\n            e.stream.addEventListener('addtrack', te => {\n              let receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = this.getReceivers()\n                  .find(r => r.track && r.track.id === te.track.id);\n              } else {\n                receiver = {track: te.track};\n              }\n\n              const event = new Event('track');\n              event.track = te.track;\n              event.receiver = receiver;\n              event.transceiver = {receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            });\n            e.stream.getTracks().forEach(track => {\n              let receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = this.getReceivers()\n                  .find(r => r.track && r.track.id === track.id);\n              } else {\n                receiver = {track};\n              }\n              const event = new Event('track');\n              event.track = track;\n              event.receiver = receiver;\n              event.transceiver = {receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            });\n          };\n          this.addEventListener('addstream', this._ontrackpoly);\n        }\n        return origSetRemoteDescription.apply(this, arguments);\n      };\n  } else {\n    // even if RTCRtpTransceiver is in window, it is only used and\n    // emitted in unified-plan. Unfortunately this means we need\n    // to unconditionally wrap the event.\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'track', e => {\n      if (!e.transceiver) {\n        Object.defineProperty(e, 'transceiver',\n          {value: {receiver: e.receiver}});\n      }\n      return e;\n    });\n  }\n}\n\nfunction shimGetSendersWithDtmf(window) {\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n  if (typeof window === 'object' && window.RTCPeerConnection &&\n      !('getSenders' in window.RTCPeerConnection.prototype) &&\n      'createDTMFSender' in window.RTCPeerConnection.prototype) {\n    const shimSenderWithDtmf = function(pc, track) {\n      return {\n        track,\n        get dtmf() {\n          if (this._dtmf === undefined) {\n            if (track.kind === 'audio') {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        },\n        _pc: pc\n      };\n    };\n\n    // augment addTrack when getSenders is not available.\n    if (!window.RTCPeerConnection.prototype.getSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        this._senders = this._senders || [];\n        return this._senders.slice(); // return a copy of the internal state.\n      };\n      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addTrack =\n        function addTrack(track, stream) {\n          let sender = origAddTrack.apply(this, arguments);\n          if (!sender) {\n            sender = shimSenderWithDtmf(this, track);\n            this._senders.push(sender);\n          }\n          return sender;\n        };\n\n      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n      window.RTCPeerConnection.prototype.removeTrack =\n        function removeTrack(sender) {\n          origRemoveTrack.apply(this, arguments);\n          const idx = this._senders.indexOf(sender);\n          if (idx !== -1) {\n            this._senders.splice(idx, 1);\n          }\n        };\n    }\n    const origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        this._senders.push(shimSenderWithDtmf(this, track));\n      });\n    };\n\n    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream =\n      function removeStream(stream) {\n        this._senders = this._senders || [];\n        origRemoveStream.apply(this, [stream]);\n\n        stream.getTracks().forEach(track => {\n          const sender = this._senders.find(s => s.track === track);\n          if (sender) { // remove sender\n            this._senders.splice(this._senders.indexOf(sender), 1);\n          }\n        });\n      };\n  } else if (typeof window === 'object' && window.RTCPeerConnection &&\n             'getSenders' in window.RTCPeerConnection.prototype &&\n             'createDTMFSender' in window.RTCPeerConnection.prototype &&\n             window.RTCRtpSender &&\n             !('dtmf' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n}\n\nfunction shimSenderReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection &&\n      window.RTCRtpSender && window.RTCRtpReceiver)) {\n    return;\n  }\n\n  // shim sender stats.\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        const senders = origGetSenders.apply(this, []);\n        senders.forEach(sender => sender._pc = this);\n        return senders;\n      };\n    }\n\n    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n        const sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window.RTCRtpSender.prototype.getStats = function getStats() {\n      const sender = this;\n      return this._pc.getStats().then(result =>\n        /* Note: this will include stats of all senders that\n         *   send a track with the same id as sender.track as\n         *   it is not possible to identify the RTCRtpSender.\n         */\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__.filterStats(result, sender.track, true));\n    };\n  }\n\n  // shim receiver stats.\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers =\n        function getReceivers() {\n          const receivers = origGetReceivers.apply(this, []);\n          receivers.forEach(receiver => receiver._pc = this);\n          return receivers;\n        };\n    }\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'track', e => {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window.RTCRtpReceiver.prototype.getStats = function getStats() {\n      const receiver = this;\n      return this._pc.getStats().then(result =>\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__.filterStats(result, receiver.track, false));\n    };\n  }\n\n  if (!('getStats' in window.RTCRtpSender.prototype &&\n      'getStats' in window.RTCRtpReceiver.prototype)) {\n    return;\n  }\n\n  // shim RTCPeerConnection.getStats(track).\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    if (arguments.length > 0 &&\n        arguments[0] instanceof window.MediaStreamTrack) {\n      const track = arguments[0];\n      let sender;\n      let receiver;\n      let err;\n      this.getSenders().forEach(s => {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach(r => {\n        if (r.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r;\n          }\n        }\n        return r.track === track;\n      });\n      if (err || (sender && receiver)) {\n        return Promise.reject(new DOMException(\n          'There are more than one sender or receiver for the track.',\n          'InvalidAccessError'));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n      return Promise.reject(new DOMException(\n        'There is no sender or receiver for the track.',\n        'InvalidAccessError'));\n    }\n    return origGetStats.apply(this, arguments);\n  };\n}\n\nfunction shimAddTrackRemoveTrackWithNative(window) {\n  // shim addTrack/removeTrack with native variants in order to make\n  // the interactions with legacy getLocalStreams behave as in other browsers.\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\n  window.RTCPeerConnection.prototype.getLocalStreams =\n    function getLocalStreams() {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      return Object.keys(this._shimmedLocalStreams)\n        .map(streamId => this._shimmedLocalStreams[streamId][0]);\n    };\n\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  window.RTCPeerConnection.prototype.addTrack =\n    function addTrack(track, stream) {\n      if (!stream) {\n        return origAddTrack.apply(this, arguments);\n      }\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n      const sender = origAddTrack.apply(this, arguments);\n      if (!this._shimmedLocalStreams[stream.id]) {\n        this._shimmedLocalStreams[stream.id] = [stream, sender];\n      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n        this._shimmedLocalStreams[stream.id].push(sender);\n      }\n      return sender;\n    };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n          'InvalidAccessError');\n      }\n    });\n    const existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    const newSenders = this.getSenders()\n      .filter(newSender => existingSenders.indexOf(newSender) === -1);\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      delete this._shimmedLocalStreams[stream.id];\n      return origRemoveStream.apply(this, arguments);\n    };\n\n  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n  window.RTCPeerConnection.prototype.removeTrack =\n    function removeTrack(sender) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      if (sender) {\n        Object.keys(this._shimmedLocalStreams).forEach(streamId => {\n          const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n          if (idx !== -1) {\n            this._shimmedLocalStreams[streamId].splice(idx, 1);\n          }\n          if (this._shimmedLocalStreams[streamId].length === 1) {\n            delete this._shimmedLocalStreams[streamId];\n          }\n        });\n      }\n      return origRemoveTrack.apply(this, arguments);\n    };\n}\n\nfunction shimAddTrackRemoveTrack(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  // shim addTrack and removeTrack.\n  if (window.RTCPeerConnection.prototype.addTrack &&\n      browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window);\n  }\n\n  // also shim pc.getLocalStreams when addTrack is shimmed\n  // to return the original streams.\n  const origGetLocalStreams = window.RTCPeerConnection.prototype\n    .getLocalStreams;\n  window.RTCPeerConnection.prototype.getLocalStreams =\n    function getLocalStreams() {\n      const nativeStreams = origGetLocalStreams.apply(this);\n      this._reverseStreams = this._reverseStreams || {};\n      return nativeStreams.map(stream => this._reverseStreams[stream.id]);\n    };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n          'InvalidAccessError');\n      }\n    });\n    // Add identity mapping for consistency with addTrack.\n    // Unless this is being used with a stream from addTrack.\n    if (!this._reverseStreams[stream.id]) {\n      const newStream = new window.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n    origAddStream.apply(this, [stream]);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      this._streams = this._streams || {};\n      this._reverseStreams = this._reverseStreams || {};\n\n      origRemoveStream.apply(this, [(this._streams[stream.id] || stream)]);\n      delete this._reverseStreams[(this._streams[stream.id] ?\n        this._streams[stream.id].id : stream.id)];\n      delete this._streams[stream.id];\n    };\n\n  window.RTCPeerConnection.prototype.addTrack =\n    function addTrack(track, stream) {\n      if (this.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      const streams = [].slice.call(arguments, 1);\n      if (streams.length !== 1 ||\n          !streams[0].getTracks().find(t => t === track)) {\n        // this is not fully correct but all we can manage without\n        // [[associated MediaStreams]] internal slot.\n        throw new DOMException(\n          'The adapter.js addTrack polyfill only supports a single ' +\n          ' stream which is associated with the specified track.',\n          'NotSupportedError');\n      }\n\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n          'InvalidAccessError');\n      }\n\n      this._streams = this._streams || {};\n      this._reverseStreams = this._reverseStreams || {};\n      const oldStream = this._streams[stream.id];\n      if (oldStream) {\n        // this is using odd Chrome behaviour, use with caution:\n        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n        // Note: we rely on the high-level addTrack/dtmf shim to\n        // create the sender with a dtmf sender.\n        oldStream.addTrack(track);\n\n        // Trigger ONN async.\n        Promise.resolve().then(() => {\n          this.dispatchEvent(new Event('negotiationneeded'));\n        });\n      } else {\n        const newStream = new window.MediaStream([track]);\n        this._streams[stream.id] = newStream;\n        this._reverseStreams[newStream.id] = stream;\n        this.addStream(newStream);\n      }\n      return this.getSenders().find(s => s.track === track);\n    };\n\n  // replace the internal stream id with the external one and\n  // vice versa.\n  function replaceInternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'),\n        externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  function replaceExternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'),\n        internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  ['createOffer', 'createAnswer'].forEach(function(method) {\n    const nativeMethod = window.RTCPeerConnection.prototype[method];\n    const methodObj = {[method]() {\n      const args = arguments;\n      const isLegacyCall = arguments.length &&\n          typeof arguments[0] === 'function';\n      if (isLegacyCall) {\n        return nativeMethod.apply(this, [\n          (description) => {\n            const desc = replaceInternalStreamId(this, description);\n            args[0].apply(null, [desc]);\n          },\n          (err) => {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]\n        ]);\n      }\n      return nativeMethod.apply(this, arguments)\n        .then(description => replaceInternalStreamId(this, description));\n    }};\n    window.RTCPeerConnection.prototype[method] = methodObj[method];\n  });\n\n  const origSetLocalDescription =\n      window.RTCPeerConnection.prototype.setLocalDescription;\n  window.RTCPeerConnection.prototype.setLocalDescription =\n    function setLocalDescription() {\n      if (!arguments.length || !arguments[0].type) {\n        return origSetLocalDescription.apply(this, arguments);\n      }\n      arguments[0] = replaceExternalStreamId(this, arguments[0]);\n      return origSetLocalDescription.apply(this, arguments);\n    };\n\n  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n  const origLocalDescription = Object.getOwnPropertyDescriptor(\n    window.RTCPeerConnection.prototype, 'localDescription');\n  Object.defineProperty(window.RTCPeerConnection.prototype,\n    'localDescription', {\n      get() {\n        const description = origLocalDescription.get.apply(this);\n        if (description.type === '') {\n          return description;\n        }\n        return replaceInternalStreamId(this, description);\n      }\n    });\n\n  window.RTCPeerConnection.prototype.removeTrack =\n    function removeTrack(sender) {\n      if (this.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      // We can not yet check for sender instanceof RTCRtpSender\n      // since we shim RTPSender. So we check if sender._pc is set.\n      if (!sender._pc) {\n        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +\n            'does not implement interface RTCRtpSender.', 'TypeError');\n      }\n      const isLocal = sender._pc === this;\n      if (!isLocal) {\n        throw new DOMException('Sender was not created by this connection.',\n          'InvalidAccessError');\n      }\n\n      // Search for the native stream the senders track belongs to.\n      this._streams = this._streams || {};\n      let stream;\n      Object.keys(this._streams).forEach(streamid => {\n        const hasTrack = this._streams[streamid].getTracks()\n          .find(track => sender.track === track);\n        if (hasTrack) {\n          stream = this._streams[streamid];\n        }\n      });\n\n      if (stream) {\n        if (stream.getTracks().length === 1) {\n          // if this is the last track of the stream, remove the stream. This\n          // takes care of any shimmed _senders.\n          this.removeStream(this._reverseStreams[stream.id]);\n        } else {\n          // relying on the same odd chrome behaviour as above.\n          stream.removeTrack(sender.track);\n        }\n        this.dispatchEvent(new Event('negotiationneeded'));\n      }\n    };\n}\n\nfunction shimPeerConnection(window, browserDetails) {\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\n  }\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n  if (browserDetails.version < 53) {\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n      .forEach(function(method) {\n        const nativeMethod = window.RTCPeerConnection.prototype[method];\n        const methodObj = {[method]() {\n          arguments[0] = new ((method === 'addIceCandidate') ?\n            window.RTCIceCandidate :\n            window.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        }};\n        window.RTCPeerConnection.prototype[method] = methodObj[method];\n      });\n  }\n}\n\n// Attempt to fix ONN in plan-b mode.\nfunction fixNegotiationNeeded(window, browserDetails) {\n  _utils_js__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'negotiationneeded', e => {\n    const pc = e.target;\n    if (browserDetails.version < 72 || (pc.getConfiguration &&\n        pc.getConfiguration().sdpSemantics === 'plan-b')) {\n      if (pc.signalingState !== 'stable') {\n        return;\n      }\n    }\n    return e;\n  });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvY2hyb21lL2Nocm9tZV9zaGltLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ3dCOztBQUVXOztBQUV6QztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUksOERBQTZCO0FBQ2pDO0FBQ0E7QUFDQSxXQUFXLFFBQVEsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFpQjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDhEQUE2QjtBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQWlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNPO0FBQ1AsRUFBRSw4REFBNkI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL2Nocm9tZS9jaHJvbWVfc2hpbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuXG5leHBvcnQge3NoaW1HZXRVc2VyTWVkaWF9IGZyb20gJy4vZ2V0dXNlcm1lZGlhJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1NZWRpYVN0cmVhbSh3aW5kb3cpIHtcbiAgd2luZG93Lk1lZGlhU3RyZWFtID0gd2luZG93Lk1lZGlhU3RyZWFtIHx8IHdpbmRvdy53ZWJraXRNZWRpYVN0cmVhbTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1PblRyYWNrKHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmICEoJ29udHJhY2snIGluXG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnb250cmFjaycsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29udHJhY2s7XG4gICAgICB9LFxuICAgICAgc2V0KGYpIHtcbiAgICAgICAgaWYgKHRoaXMuX29udHJhY2spIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb250cmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29udHJhY2sgPSBmKTtcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3Qgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID1cbiAgICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID1cbiAgICAgIGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX29udHJhY2twb2x5KSB7XG4gICAgICAgICAgdGhpcy5fb250cmFja3BvbHkgPSAoZSkgPT4ge1xuICAgICAgICAgICAgLy8gb25hZGRzdHJlYW0gZG9lcyBub3QgZmlyZSB3aGVuIGEgdHJhY2sgaXMgYWRkZWQgdG8gYW4gZXhpc3RpbmdcbiAgICAgICAgICAgIC8vIHN0cmVhbS4gQnV0IHN0cmVhbS5vbmFkZHRyYWNrIGlzIGltcGxlbWVudGVkIHNvIHdlIHVzZSB0aGF0LlxuICAgICAgICAgICAgZS5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB0ZSA9PiB7XG4gICAgICAgICAgICAgIGxldCByZWNlaXZlcjtcbiAgICAgICAgICAgICAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB0aGlzLmdldFJlY2VpdmVycygpXG4gICAgICAgICAgICAgICAgICAuZmluZChyID0+IHIudHJhY2sgJiYgci50cmFjay5pZCA9PT0gdGUudHJhY2suaWQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyID0ge3RyYWNrOiB0ZS50cmFja307XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgndHJhY2snKTtcbiAgICAgICAgICAgICAgZXZlbnQudHJhY2sgPSB0ZS50cmFjaztcbiAgICAgICAgICAgICAgZXZlbnQucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICAgICAgZXZlbnQudHJhbnNjZWl2ZXIgPSB7cmVjZWl2ZXJ9O1xuICAgICAgICAgICAgICBldmVudC5zdHJlYW1zID0gW2Uuc3RyZWFtXTtcbiAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZS5zdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgICAgIGxldCByZWNlaXZlcjtcbiAgICAgICAgICAgICAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB0aGlzLmdldFJlY2VpdmVycygpXG4gICAgICAgICAgICAgICAgICAuZmluZChyID0+IHIudHJhY2sgJiYgci50cmFjay5pZCA9PT0gdHJhY2suaWQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyID0ge3RyYWNrfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgndHJhY2snKTtcbiAgICAgICAgICAgICAgZXZlbnQudHJhY2sgPSB0cmFjaztcbiAgICAgICAgICAgICAgZXZlbnQucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICAgICAgZXZlbnQudHJhbnNjZWl2ZXIgPSB7cmVjZWl2ZXJ9O1xuICAgICAgICAgICAgICBldmVudC5zdHJlYW1zID0gW2Uuc3RyZWFtXTtcbiAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbnRyYWNrcG9seSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBldmVuIGlmIFJUQ1J0cFRyYW5zY2VpdmVyIGlzIGluIHdpbmRvdywgaXQgaXMgb25seSB1c2VkIGFuZFxuICAgIC8vIGVtaXR0ZWQgaW4gdW5pZmllZC1wbGFuLiBVbmZvcnR1bmF0ZWx5IHRoaXMgbWVhbnMgd2UgbmVlZFxuICAgIC8vIHRvIHVuY29uZGl0aW9uYWxseSB3cmFwIHRoZSBldmVudC5cbiAgICB1dGlscy53cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICd0cmFjaycsIGUgPT4ge1xuICAgICAgaWYgKCFlLnRyYW5zY2VpdmVyKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAndHJhbnNjZWl2ZXInLFxuICAgICAgICAgIHt2YWx1ZToge3JlY2VpdmVyOiBlLnJlY2VpdmVyfX0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1HZXRTZW5kZXJzV2l0aER0bWYod2luZG93KSB7XG4gIC8vIE92ZXJyaWRlcyBhZGRUcmFjay9yZW1vdmVUcmFjaywgZGVwZW5kcyBvbiBzaGltQWRkVHJhY2tSZW1vdmVUcmFjay5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJlxuICAgICAgISgnZ2V0U2VuZGVycycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkgJiZcbiAgICAgICdjcmVhdGVEVE1GU2VuZGVyJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSB7XG4gICAgY29uc3Qgc2hpbVNlbmRlcldpdGhEdG1mID0gZnVuY3Rpb24ocGMsIHRyYWNrKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFjayxcbiAgICAgICAgZ2V0IGR0bWYoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2R0bWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZHRtZiA9IHBjLmNyZWF0ZURUTUZTZW5kZXIodHJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fZHRtZiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9kdG1mO1xuICAgICAgICB9LFxuICAgICAgICBfcGM6IHBjXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBhdWdtZW50IGFkZFRyYWNrIHdoZW4gZ2V0U2VuZGVycyBpcyBub3QgYXZhaWxhYmxlLlxuICAgIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgICB0aGlzLl9zZW5kZXJzID0gdGhpcy5fc2VuZGVycyB8fCBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmRlcnMuc2xpY2UoKTsgLy8gcmV0dXJuIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgc3RhdGUuXG4gICAgICB9O1xuICAgICAgY29uc3Qgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPVxuICAgICAgICBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaywgc3RyZWFtKSB7XG4gICAgICAgICAgbGV0IHNlbmRlciA9IG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIGlmICghc2VuZGVyKSB7XG4gICAgICAgICAgICBzZW5kZXIgPSBzaGltU2VuZGVyV2l0aER0bWYodGhpcywgdHJhY2spO1xuICAgICAgICAgICAgdGhpcy5fc2VuZGVycy5wdXNoKHNlbmRlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgICAgIH07XG5cbiAgICAgIGNvbnN0IG9yaWdSZW1vdmVUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2s7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID1cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlVHJhY2soc2VuZGVyKSB7XG4gICAgICAgICAgb3JpZ1JlbW92ZVRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5fc2VuZGVycy5pbmRleE9mKHNlbmRlcik7XG4gICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBvcmlnQWRkU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW07XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XG4gICAgICB0aGlzLl9zZW5kZXJzID0gdGhpcy5fc2VuZGVycyB8fCBbXTtcbiAgICAgIG9yaWdBZGRTdHJlYW0uYXBwbHkodGhpcywgW3N0cmVhbV0pO1xuICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICB0aGlzLl9zZW5kZXJzLnB1c2goc2hpbVNlbmRlcldpdGhEdG1mKHRoaXMsIHRyYWNrKSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb3JpZ1JlbW92ZVN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID1cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgdGhpcy5fc2VuZGVycyA9IHRoaXMuX3NlbmRlcnMgfHwgW107XG4gICAgICAgIG9yaWdSZW1vdmVTdHJlYW0uYXBwbHkodGhpcywgW3N0cmVhbV0pO1xuXG4gICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgICBjb25zdCBzZW5kZXIgPSB0aGlzLl9zZW5kZXJzLmZpbmQocyA9PiBzLnRyYWNrID09PSB0cmFjayk7XG4gICAgICAgICAgaWYgKHNlbmRlcikgeyAvLyByZW1vdmUgc2VuZGVyXG4gICAgICAgICAgICB0aGlzLl9zZW5kZXJzLnNwbGljZSh0aGlzLl9zZW5kZXJzLmluZGV4T2Yoc2VuZGVyKSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmXG4gICAgICAgICAgICAgJ2dldFNlbmRlcnMnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgJiZcbiAgICAgICAgICAgICAnY3JlYXRlRFRNRlNlbmRlcicgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSAmJlxuICAgICAgICAgICAgIHdpbmRvdy5SVENSdHBTZW5kZXIgJiZcbiAgICAgICAgICAgICAhKCdkdG1mJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSkpIHtcbiAgICBjb25zdCBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgY29uc3Qgc2VuZGVycyA9IG9yaWdHZXRTZW5kZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgIHNlbmRlcnMuZm9yRWFjaChzZW5kZXIgPT4gc2VuZGVyLl9wYyA9IHRoaXMpO1xuICAgICAgcmV0dXJuIHNlbmRlcnM7XG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSwgJ2R0bWYnLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kdG1mID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy50cmFjay5raW5kID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICB0aGlzLl9kdG1mID0gdGhpcy5fcGMuY3JlYXRlRFRNRlNlbmRlcih0aGlzLnRyYWNrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZHRtZiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kdG1mO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltU2VuZGVyUmVjZWl2ZXJHZXRTdGF0cyh3aW5kb3cpIHtcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmXG4gICAgICB3aW5kb3cuUlRDUnRwU2VuZGVyICYmIHdpbmRvdy5SVENSdHBSZWNlaXZlcikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzaGltIHNlbmRlciBzdGF0cy5cbiAgaWYgKCEoJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSkpIHtcbiAgICBjb25zdCBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcbiAgICBpZiAob3JpZ0dldFNlbmRlcnMpIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XG4gICAgICAgIGNvbnN0IHNlbmRlcnMgPSBvcmlnR2V0U2VuZGVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICAgIHNlbmRlcnMuZm9yRWFjaChzZW5kZXIgPT4gc2VuZGVyLl9wYyA9IHRoaXMpO1xuICAgICAgICByZXR1cm4gc2VuZGVycztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3Qgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgICBpZiAob3JpZ0FkZFRyYWNrKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2soKSB7XG4gICAgICAgIGNvbnN0IHNlbmRlciA9IG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBzZW5kZXIuX3BjID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNlbmRlcjtcbiAgICAgIH07XG4gICAgfVxuICAgIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgICBjb25zdCBzZW5kZXIgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKCkudGhlbihyZXN1bHQgPT5cbiAgICAgICAgLyogTm90ZTogdGhpcyB3aWxsIGluY2x1ZGUgc3RhdHMgb2YgYWxsIHNlbmRlcnMgdGhhdFxuICAgICAgICAgKiAgIHNlbmQgYSB0cmFjayB3aXRoIHRoZSBzYW1lIGlkIGFzIHNlbmRlci50cmFjayBhc1xuICAgICAgICAgKiAgIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBpZGVudGlmeSB0aGUgUlRDUnRwU2VuZGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdXRpbHMuZmlsdGVyU3RhdHMocmVzdWx0LCBzZW5kZXIudHJhY2ssIHRydWUpKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gc2hpbSByZWNlaXZlciBzdGF0cy5cbiAgaWYgKCEoJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlKSkge1xuICAgIGNvbnN0IG9yaWdHZXRSZWNlaXZlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycztcbiAgICBpZiAob3JpZ0dldFJlY2VpdmVycykge1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMgPVxuICAgICAgICBmdW5jdGlvbiBnZXRSZWNlaXZlcnMoKSB7XG4gICAgICAgICAgY29uc3QgcmVjZWl2ZXJzID0gb3JpZ0dldFJlY2VpdmVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICAgICAgcmVjZWl2ZXJzLmZvckVhY2gocmVjZWl2ZXIgPT4gcmVjZWl2ZXIuX3BjID0gdGhpcyk7XG4gICAgICAgICAgcmV0dXJuIHJlY2VpdmVycztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdXRpbHMud3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAndHJhY2snLCBlID0+IHtcbiAgICAgIGUucmVjZWl2ZXIuX3BjID0gZS5zcmNFbGVtZW50O1xuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gICAgd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgICAgY29uc3QgcmVjZWl2ZXIgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKCkudGhlbihyZXN1bHQgPT5cbiAgICAgICAgdXRpbHMuZmlsdGVyU3RhdHMocmVzdWx0LCByZWNlaXZlci50cmFjaywgZmFsc2UpKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKCEoJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSAmJlxuICAgICAgJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNoaW0gUlRDUGVlckNvbm5lY3Rpb24uZ2V0U3RhdHModHJhY2spLlxuICBjb25zdCBvcmlnR2V0U3RhdHMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmXG4gICAgICAgIGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIHdpbmRvdy5NZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICBjb25zdCB0cmFjayA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGxldCBzZW5kZXI7XG4gICAgICBsZXQgcmVjZWl2ZXI7XG4gICAgICBsZXQgZXJyO1xuICAgICAgdGhpcy5nZXRTZW5kZXJzKCkuZm9yRWFjaChzID0+IHtcbiAgICAgICAgaWYgKHMudHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICAgICAgaWYgKHNlbmRlcikge1xuICAgICAgICAgICAgZXJyID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VuZGVyID0gcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5nZXRSZWNlaXZlcnMoKS5mb3JFYWNoKHIgPT4ge1xuICAgICAgICBpZiAoci50cmFjayA9PT0gdHJhY2spIHtcbiAgICAgICAgICBpZiAocmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGVyciA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlY2VpdmVyID0gcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHIudHJhY2sgPT09IHRyYWNrO1xuICAgICAgfSk7XG4gICAgICBpZiAoZXJyIHx8IChzZW5kZXIgJiYgcmVjZWl2ZXIpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgICAgICdUaGVyZSBhcmUgbW9yZSB0aGFuIG9uZSBzZW5kZXIgb3IgcmVjZWl2ZXIgZm9yIHRoZSB0cmFjay4nLFxuICAgICAgICAgICdJbnZhbGlkQWNjZXNzRXJyb3InKSk7XG4gICAgICB9IGVsc2UgaWYgKHNlbmRlcikge1xuICAgICAgICByZXR1cm4gc2VuZGVyLmdldFN0YXRzKCk7XG4gICAgICB9IGVsc2UgaWYgKHJlY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiByZWNlaXZlci5nZXRTdGF0cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBET01FeGNlcHRpb24oXG4gICAgICAgICdUaGVyZSBpcyBubyBzZW5kZXIgb3IgcmVjZWl2ZXIgZm9yIHRoZSB0cmFjay4nLFxuICAgICAgICAnSW52YWxpZEFjY2Vzc0Vycm9yJykpO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ0dldFN0YXRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltQWRkVHJhY2tSZW1vdmVUcmFja1dpdGhOYXRpdmUod2luZG93KSB7XG4gIC8vIHNoaW0gYWRkVHJhY2svcmVtb3ZlVHJhY2sgd2l0aCBuYXRpdmUgdmFyaWFudHMgaW4gb3JkZXIgdG8gbWFrZVxuICAvLyB0aGUgaW50ZXJhY3Rpb25zIHdpdGggbGVnYWN5IGdldExvY2FsU3RyZWFtcyBiZWhhdmUgYXMgaW4gb3RoZXIgYnJvd3NlcnMuXG4gIC8vIEtlZXBzIGEgbWFwcGluZyBzdHJlYW0uaWQgPT4gW3N0cmVhbSwgcnRwc2VuZGVycy4uLl1cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbXMgPVxuICAgIGZ1bmN0aW9uIGdldExvY2FsU3RyZWFtcygpIHtcbiAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMpXG4gICAgICAgIC5tYXAoc3RyZWFtSWQgPT4gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF1bMF0pO1xuICAgIH07XG5cbiAgY29uc3Qgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9XG4gICAgZnVuY3Rpb24gYWRkVHJhY2sodHJhY2ssIHN0cmVhbSkge1xuICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XG5cbiAgICAgIGNvbnN0IHNlbmRlciA9IG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKCF0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0pIHtcbiAgICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdID0gW3N0cmVhbSwgc2VuZGVyXTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdLmluZGV4T2Yoc2VuZGVyKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdLnB1c2goc2VuZGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgfTtcblxuICBjb25zdCBvcmlnQWRkU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHN0cmVhbSkge1xuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuXG4gICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgY29uc3QgYWxyZWFkeUV4aXN0cyA9IHRoaXMuZ2V0U2VuZGVycygpLmZpbmQocyA9PiBzLnRyYWNrID09PSB0cmFjayk7XG4gICAgICBpZiAoYWxyZWFkeUV4aXN0cykge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUcmFjayBhbHJlYWR5IGV4aXN0cy4nLFxuICAgICAgICAgICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBleGlzdGluZ1NlbmRlcnMgPSB0aGlzLmdldFNlbmRlcnMoKTtcbiAgICBvcmlnQWRkU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgY29uc3QgbmV3U2VuZGVycyA9IHRoaXMuZ2V0U2VuZGVycygpXG4gICAgICAuZmlsdGVyKG5ld1NlbmRlciA9PiBleGlzdGluZ1NlbmRlcnMuaW5kZXhPZihuZXdTZW5kZXIpID09PSAtMSk7XG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdID0gW3N0cmVhbV0uY29uY2F0KG5ld1NlbmRlcnMpO1xuICB9O1xuXG4gIGNvbnN0IG9yaWdSZW1vdmVTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPVxuICAgIGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgICAgZGVsZXRlIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXTtcbiAgICAgIHJldHVybiBvcmlnUmVtb3ZlU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICBjb25zdCBvcmlnUmVtb3ZlVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID1cbiAgICBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgICAgaWYgKHNlbmRlcikge1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zKS5mb3JFYWNoKHN0cmVhbUlkID0+IHtcbiAgICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXS5pbmRleE9mKHNlbmRlcik7XG4gICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnUmVtb3ZlVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2sod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBzaGltIGFkZFRyYWNrIGFuZCByZW1vdmVUcmFjay5cbiAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgJiZcbiAgICAgIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjUpIHtcbiAgICByZXR1cm4gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlKHdpbmRvdyk7XG4gIH1cblxuICAvLyBhbHNvIHNoaW0gcGMuZ2V0TG9jYWxTdHJlYW1zIHdoZW4gYWRkVHJhY2sgaXMgc2hpbW1lZFxuICAvLyB0byByZXR1cm4gdGhlIG9yaWdpbmFsIHN0cmVhbXMuXG4gIGNvbnN0IG9yaWdHZXRMb2NhbFN0cmVhbXMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlXG4gICAgLmdldExvY2FsU3RyZWFtcztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbXMgPVxuICAgIGZ1bmN0aW9uIGdldExvY2FsU3RyZWFtcygpIHtcbiAgICAgIGNvbnN0IG5hdGl2ZVN0cmVhbXMgPSBvcmlnR2V0TG9jYWxTdHJlYW1zLmFwcGx5KHRoaXMpO1xuICAgICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcbiAgICAgIHJldHVybiBuYXRpdmVTdHJlYW1zLm1hcChzdHJlYW0gPT4gdGhpcy5fcmV2ZXJzZVN0cmVhbXNbc3RyZWFtLmlkXSk7XG4gICAgfTtcblxuICBjb25zdCBvcmlnQWRkU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHN0cmVhbSkge1xuICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zID0gdGhpcy5fcmV2ZXJzZVN0cmVhbXMgfHwge307XG5cbiAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICBjb25zdCBhbHJlYWR5RXhpc3RzID0gdGhpcy5nZXRTZW5kZXJzKCkuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgIGlmIChhbHJlYWR5RXhpc3RzKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RyYWNrIGFscmVhZHkgZXhpc3RzLicsXG4gICAgICAgICAgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEFkZCBpZGVudGl0eSBtYXBwaW5nIGZvciBjb25zaXN0ZW5jeSB3aXRoIGFkZFRyYWNrLlxuICAgIC8vIFVubGVzcyB0aGlzIGlzIGJlaW5nIHVzZWQgd2l0aCBhIHN0cmVhbSBmcm9tIGFkZFRyYWNrLlxuICAgIGlmICghdGhpcy5fcmV2ZXJzZVN0cmVhbXNbc3RyZWFtLmlkXSkge1xuICAgICAgY29uc3QgbmV3U3RyZWFtID0gbmV3IHdpbmRvdy5NZWRpYVN0cmVhbShzdHJlYW0uZ2V0VHJhY2tzKCkpO1xuICAgICAgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdID0gbmV3U3RyZWFtO1xuICAgICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXNbbmV3U3RyZWFtLmlkXSA9IHN0cmVhbTtcbiAgICAgIHN0cmVhbSA9IG5ld1N0cmVhbTtcbiAgICB9XG4gICAgb3JpZ0FkZFN0cmVhbS5hcHBseSh0aGlzLCBbc3RyZWFtXSk7XG4gIH07XG5cbiAgY29uc3Qgb3JpZ1JlbW92ZVN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgdGhpcy5fc3RyZWFtcyA9IHRoaXMuX3N0cmVhbXMgfHwge307XG4gICAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xuXG4gICAgICBvcmlnUmVtb3ZlU3RyZWFtLmFwcGx5KHRoaXMsIFsodGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdIHx8IHN0cmVhbSldKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9yZXZlcnNlU3RyZWFtc1sodGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdID9cbiAgICAgICAgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdLmlkIDogc3RyZWFtLmlkKV07XG4gICAgICBkZWxldGUgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdO1xuICAgIH07XG5cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9XG4gICAgZnVuY3Rpb24gYWRkVHJhY2sodHJhY2ssIHN0cmVhbSkge1xuICAgICAgaWYgKHRoaXMuc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXG4gICAgICAgICAgJ1RoZSBSVENQZWVyQ29ubmVjdGlvblxcJ3Mgc2lnbmFsaW5nU3RhdGUgaXMgXFwnY2xvc2VkXFwnLicsXG4gICAgICAgICAgJ0ludmFsaWRTdGF0ZUVycm9yJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHJlYW1zID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgaWYgKHN0cmVhbXMubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgICAgIXN0cmVhbXNbMF0uZ2V0VHJhY2tzKCkuZmluZCh0ID0+IHQgPT09IHRyYWNrKSkge1xuICAgICAgICAvLyB0aGlzIGlzIG5vdCBmdWxseSBjb3JyZWN0IGJ1dCBhbGwgd2UgY2FuIG1hbmFnZSB3aXRob3V0XG4gICAgICAgIC8vIFtbYXNzb2NpYXRlZCBNZWRpYVN0cmVhbXNdXSBpbnRlcm5hbCBzbG90LlxuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgICAgICdUaGUgYWRhcHRlci5qcyBhZGRUcmFjayBwb2x5ZmlsbCBvbmx5IHN1cHBvcnRzIGEgc2luZ2xlICcgK1xuICAgICAgICAgICcgc3RyZWFtIHdoaWNoIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIHRyYWNrLicsXG4gICAgICAgICAgJ05vdFN1cHBvcnRlZEVycm9yJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFscmVhZHlFeGlzdHMgPSB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgICAgaWYgKGFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJyxcbiAgICAgICAgICAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcbiAgICAgIGNvbnN0IG9sZFN0cmVhbSA9IHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXTtcbiAgICAgIGlmIChvbGRTdHJlYW0pIHtcbiAgICAgICAgLy8gdGhpcyBpcyB1c2luZyBvZGQgQ2hyb21lIGJlaGF2aW91ciwgdXNlIHdpdGggY2F1dGlvbjpcbiAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3dlYnJ0Yy9pc3N1ZXMvZGV0YWlsP2lkPTc4MTVcbiAgICAgICAgLy8gTm90ZTogd2UgcmVseSBvbiB0aGUgaGlnaC1sZXZlbCBhZGRUcmFjay9kdG1mIHNoaW0gdG9cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBzZW5kZXIgd2l0aCBhIGR0bWYgc2VuZGVyLlxuICAgICAgICBvbGRTdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuXG4gICAgICAgIC8vIFRyaWdnZXIgT05OIGFzeW5jLlxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCduZWdvdGlhdGlvbm5lZWRlZCcpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXdTdHJlYW0gPSBuZXcgd2luZG93Lk1lZGlhU3RyZWFtKFt0cmFja10pO1xuICAgICAgICB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0gPSBuZXdTdHJlYW07XG4gICAgICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zW25ld1N0cmVhbS5pZF0gPSBzdHJlYW07XG4gICAgICAgIHRoaXMuYWRkU3RyZWFtKG5ld1N0cmVhbSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5nZXRTZW5kZXJzKCkuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgICB9O1xuXG4gIC8vIHJlcGxhY2UgdGhlIGludGVybmFsIHN0cmVhbSBpZCB3aXRoIHRoZSBleHRlcm5hbCBvbmUgYW5kXG4gIC8vIHZpY2UgdmVyc2EuXG4gIGZ1bmN0aW9uIHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHBjLCBkZXNjcmlwdGlvbikge1xuICAgIGxldCBzZHAgPSBkZXNjcmlwdGlvbi5zZHA7XG4gICAgT2JqZWN0LmtleXMocGMuX3JldmVyc2VTdHJlYW1zIHx8IFtdKS5mb3JFYWNoKGludGVybmFsSWQgPT4ge1xuICAgICAgY29uc3QgZXh0ZXJuYWxTdHJlYW0gPSBwYy5fcmV2ZXJzZVN0cmVhbXNbaW50ZXJuYWxJZF07XG4gICAgICBjb25zdCBpbnRlcm5hbFN0cmVhbSA9IHBjLl9zdHJlYW1zW2V4dGVybmFsU3RyZWFtLmlkXTtcbiAgICAgIHNkcCA9IHNkcC5yZXBsYWNlKG5ldyBSZWdFeHAoaW50ZXJuYWxTdHJlYW0uaWQsICdnJyksXG4gICAgICAgIGV4dGVybmFsU3RyZWFtLmlkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICB0eXBlOiBkZXNjcmlwdGlvbi50eXBlLFxuICAgICAgc2RwXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVwbGFjZUV4dGVybmFsU3RyZWFtSWQocGMsIGRlc2NyaXB0aW9uKSB7XG4gICAgbGV0IHNkcCA9IGRlc2NyaXB0aW9uLnNkcDtcbiAgICBPYmplY3Qua2V5cyhwYy5fcmV2ZXJzZVN0cmVhbXMgfHwgW10pLmZvckVhY2goaW50ZXJuYWxJZCA9PiB7XG4gICAgICBjb25zdCBleHRlcm5hbFN0cmVhbSA9IHBjLl9yZXZlcnNlU3RyZWFtc1tpbnRlcm5hbElkXTtcbiAgICAgIGNvbnN0IGludGVybmFsU3RyZWFtID0gcGMuX3N0cmVhbXNbZXh0ZXJuYWxTdHJlYW0uaWRdO1xuICAgICAgc2RwID0gc2RwLnJlcGxhY2UobmV3IFJlZ0V4cChleHRlcm5hbFN0cmVhbS5pZCwgJ2cnKSxcbiAgICAgICAgaW50ZXJuYWxTdHJlYW0uaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgIHR5cGU6IGRlc2NyaXB0aW9uLnR5cGUsXG4gICAgICBzZHBcbiAgICB9KTtcbiAgfVxuICBbJ2NyZWF0ZU9mZmVyJywgJ2NyZWF0ZUFuc3dlciddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgY29uc3QgbmF0aXZlTWV0aG9kID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgIGNvbnN0IG1ldGhvZE9iaiA9IHtbbWV0aG9kXSgpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBjb25zdCBpc0xlZ2FjeUNhbGwgPSBhcmd1bWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIGlmIChpc0xlZ2FjeUNhbGwpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBbXG4gICAgICAgICAgKGRlc2NyaXB0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZXNjID0gcmVwbGFjZUludGVybmFsU3RyZWFtSWQodGhpcywgZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgYXJnc1swXS5hcHBseShudWxsLCBbZGVzY10pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGFyZ3NbMV0pIHtcbiAgICAgICAgICAgICAgYXJnc1sxXS5hcHBseShudWxsLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGFyZ3VtZW50c1syXVxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAudGhlbihkZXNjcmlwdGlvbiA9PiByZXBsYWNlSW50ZXJuYWxTdHJlYW1JZCh0aGlzLCBkZXNjcmlwdGlvbikpO1xuICAgIH19O1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG1ldGhvZE9ialttZXRob2RdO1xuICB9KTtcblxuICBjb25zdCBvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbiA9XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb247XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbiA9XG4gICAgZnVuY3Rpb24gc2V0TG9jYWxEZXNjcmlwdGlvbigpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCB8fCAhYXJndW1lbnRzWzBdLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBhcmd1bWVudHNbMF0gPSByZXBsYWNlRXh0ZXJuYWxTdHJlYW1JZCh0aGlzLCBhcmd1bWVudHNbMF0pO1xuICAgICAgcmV0dXJuIG9yaWdTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAvLyBUT0RPOiBtYW5nbGUgZ2V0U3RhdHM6IGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJydGMtc3RhdHMvI2RvbS1ydGNtZWRpYXN0cmVhbXN0YXRzLXN0cmVhbWlkZW50aWZpZXJcblxuICBjb25zdCBvcmlnTG9jYWxEZXNjcmlwdGlvbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ2xvY2FsRGVzY3JpcHRpb24nKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsXG4gICAgJ2xvY2FsRGVzY3JpcHRpb24nLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gb3JpZ0xvY2FsRGVzY3JpcHRpb24uZ2V0LmFwcGx5KHRoaXMpO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJycpIHtcbiAgICAgICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHRoaXMsIGRlc2NyaXB0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID1cbiAgICBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICAgIGlmICh0aGlzLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgICAgICdUaGUgUlRDUGVlckNvbm5lY3Rpb25cXCdzIHNpZ25hbGluZ1N0YXRlIGlzIFxcJ2Nsb3NlZFxcJy4nLFxuICAgICAgICAgICdJbnZhbGlkU3RhdGVFcnJvcicpO1xuICAgICAgfVxuICAgICAgLy8gV2UgY2FuIG5vdCB5ZXQgY2hlY2sgZm9yIHNlbmRlciBpbnN0YW5jZW9mIFJUQ1J0cFNlbmRlclxuICAgICAgLy8gc2luY2Ugd2Ugc2hpbSBSVFBTZW5kZXIuIFNvIHdlIGNoZWNrIGlmIHNlbmRlci5fcGMgaXMgc2V0LlxuICAgICAgaWYgKCFzZW5kZXIuX3BjKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0FyZ3VtZW50IDEgb2YgUlRDUGVlckNvbm5lY3Rpb24ucmVtb3ZlVHJhY2sgJyArXG4gICAgICAgICAgICAnZG9lcyBub3QgaW1wbGVtZW50IGludGVyZmFjZSBSVENSdHBTZW5kZXIuJywgJ1R5cGVFcnJvcicpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNMb2NhbCA9IHNlbmRlci5fcGMgPT09IHRoaXM7XG4gICAgICBpZiAoIWlzTG9jYWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignU2VuZGVyIHdhcyBub3QgY3JlYXRlZCBieSB0aGlzIGNvbm5lY3Rpb24uJyxcbiAgICAgICAgICAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlYXJjaCBmb3IgdGhlIG5hdGl2ZSBzdHJlYW0gdGhlIHNlbmRlcnMgdHJhY2sgYmVsb25ncyB0by5cbiAgICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgICAgbGV0IHN0cmVhbTtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3N0cmVhbXMpLmZvckVhY2goc3RyZWFtaWQgPT4ge1xuICAgICAgICBjb25zdCBoYXNUcmFjayA9IHRoaXMuX3N0cmVhbXNbc3RyZWFtaWRdLmdldFRyYWNrcygpXG4gICAgICAgICAgLmZpbmQodHJhY2sgPT4gc2VuZGVyLnRyYWNrID09PSB0cmFjayk7XG4gICAgICAgIGlmIChoYXNUcmFjaykge1xuICAgICAgICAgIHN0cmVhbSA9IHRoaXMuX3N0cmVhbXNbc3RyZWFtaWRdO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICBpZiAoc3RyZWFtLmdldFRyYWNrcygpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIC8vIGlmIHRoaXMgaXMgdGhlIGxhc3QgdHJhY2sgb2YgdGhlIHN0cmVhbSwgcmVtb3ZlIHRoZSBzdHJlYW0uIFRoaXNcbiAgICAgICAgICAvLyB0YWtlcyBjYXJlIG9mIGFueSBzaGltbWVkIF9zZW5kZXJzLlxuICAgICAgICAgIHRoaXMucmVtb3ZlU3RyZWFtKHRoaXMuX3JldmVyc2VTdHJlYW1zW3N0cmVhbS5pZF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHJlbHlpbmcgb24gdGhlIHNhbWUgb2RkIGNocm9tZSBiZWhhdmlvdXIgYXMgYWJvdmUuXG4gICAgICAgICAgc3RyZWFtLnJlbW92ZVRyYWNrKHNlbmRlci50cmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbmVnb3RpYXRpb25uZWVkZWQnKSk7XG4gICAgICB9XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbikge1xuICAgIC8vIHZlcnkgYmFzaWMgc3VwcG9ydCBmb3Igb2xkIHZlcnNpb25zLlxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbjtcbiAgfVxuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNoaW0gaW1wbGljaXQgY3JlYXRpb24gb2YgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uL1JUQ0ljZUNhbmRpZGF0ZVxuICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDUzKSB7XG4gICAgWydzZXRMb2NhbERlc2NyaXB0aW9uJywgJ3NldFJlbW90ZURlc2NyaXB0aW9uJywgJ2FkZEljZUNhbmRpZGF0ZSddXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgY29uc3QgbmF0aXZlTWV0aG9kID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgICBjb25zdCBtZXRob2RPYmogPSB7W21ldGhvZF0oKSB7XG4gICAgICAgICAgYXJndW1lbnRzWzBdID0gbmV3ICgobWV0aG9kID09PSAnYWRkSWNlQ2FuZGlkYXRlJykgP1xuICAgICAgICAgICAgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA6XG4gICAgICAgICAgICB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShhcmd1bWVudHNbMF0pO1xuICAgICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfX07XG4gICAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG1ldGhvZE9ialttZXRob2RdO1xuICAgICAgfSk7XG4gIH1cbn1cblxuLy8gQXR0ZW1wdCB0byBmaXggT05OIGluIHBsYW4tYiBtb2RlLlxuZXhwb3J0IGZ1bmN0aW9uIGZpeE5lZ290aWF0aW9uTmVlZGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgdXRpbHMud3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAnbmVnb3RpYXRpb25uZWVkZWQnLCBlID0+IHtcbiAgICBjb25zdCBwYyA9IGUudGFyZ2V0O1xuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNzIgfHwgKHBjLmdldENvbmZpZ3VyYXRpb24gJiZcbiAgICAgICAgcGMuZ2V0Q29uZmlndXJhdGlvbigpLnNkcFNlbWFudGljcyA9PT0gJ3BsYW4tYicpKSB7XG4gICAgICBpZiAocGMuc2lnbmFsaW5nU3RhdGUgIT09ICdzdGFibGUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js":
/*!*******************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shimGetUserMedia: () => (/* binding */ shimGetUserMedia)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/webrtc-adapter/src/js/utils.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\nconst logging = _utils_js__WEBPACK_IMPORTED_MODULE_0__.log;\n\nfunction shimGetUserMedia(window, browserDetails) {\n  const navigator = window && window.navigator;\n\n  if (!navigator.mediaDevices) {\n    return;\n  }\n\n  const constraintsToChrome_ = function(c) {\n    if (typeof c !== 'object' || c.mandatory || c.optional) {\n      return c;\n    }\n    const cc = {};\n    Object.keys(c).forEach(key => {\n      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n        return;\n      }\n      const r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};\n      if (r.exact !== undefined && typeof r.exact === 'number') {\n        r.min = r.max = r.exact;\n      }\n      const oldname_ = function(prefix, name) {\n        if (prefix) {\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n        }\n        return (name === 'deviceId') ? 'sourceId' : name;\n      };\n      if (r.ideal !== undefined) {\n        cc.optional = cc.optional || [];\n        let oc = {};\n        if (typeof r.ideal === 'number') {\n          oc[oldname_('min', key)] = r.ideal;\n          cc.optional.push(oc);\n          oc = {};\n          oc[oldname_('max', key)] = r.ideal;\n          cc.optional.push(oc);\n        } else {\n          oc[oldname_('', key)] = r.ideal;\n          cc.optional.push(oc);\n        }\n      }\n      if (r.exact !== undefined && typeof r.exact !== 'number') {\n        cc.mandatory = cc.mandatory || {};\n        cc.mandatory[oldname_('', key)] = r.exact;\n      } else {\n        ['min', 'max'].forEach(mix => {\n          if (r[mix] !== undefined) {\n            cc.mandatory = cc.mandatory || {};\n            cc.mandatory[oldname_(mix, key)] = r[mix];\n          }\n        });\n      }\n    });\n    if (c.advanced) {\n      cc.optional = (cc.optional || []).concat(c.advanced);\n    }\n    return cc;\n  };\n\n  const shimConstraints_ = function(constraints, func) {\n    if (browserDetails.version >= 61) {\n      return func(constraints);\n    }\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (constraints && typeof constraints.audio === 'object') {\n      const remap = function(obj, a, b) {\n        if (a in obj && !(b in obj)) {\n          obj[b] = obj[a];\n          delete obj[a];\n        }\n      };\n      constraints = JSON.parse(JSON.stringify(constraints));\n      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\n      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\n      constraints.audio = constraintsToChrome_(constraints.audio);\n    }\n    if (constraints && typeof constraints.video === 'object') {\n      // Shim facingMode for mobile & surface pro.\n      let face = constraints.video.facingMode;\n      face = face && ((typeof face === 'object') ? face : {ideal: face});\n      const getSupportedFacingModeLies = browserDetails.version < 66;\n\n      if ((face && (face.exact === 'user' || face.exact === 'environment' ||\n                    face.ideal === 'user' || face.ideal === 'environment')) &&\n          !(navigator.mediaDevices.getSupportedConstraints &&\n            navigator.mediaDevices.getSupportedConstraints().facingMode &&\n            !getSupportedFacingModeLies)) {\n        delete constraints.video.facingMode;\n        let matches;\n        if (face.exact === 'environment' || face.ideal === 'environment') {\n          matches = ['back', 'rear'];\n        } else if (face.exact === 'user' || face.ideal === 'user') {\n          matches = ['front'];\n        }\n        if (matches) {\n          // Look for matches in label, or use last cam for back (typical).\n          return navigator.mediaDevices.enumerateDevices()\n            .then(devices => {\n              devices = devices.filter(d => d.kind === 'videoinput');\n              let dev = devices.find(d => matches.some(match =>\n                d.label.toLowerCase().includes(match)));\n              if (!dev && devices.length && matches.includes('back')) {\n                dev = devices[devices.length - 1]; // more likely the back cam\n              }\n              if (dev) {\n                constraints.video.deviceId = face.exact\n                  ? {exact: dev.deviceId}\n                  : {ideal: dev.deviceId};\n              }\n              constraints.video = constraintsToChrome_(constraints.video);\n              logging('chrome: ' + JSON.stringify(constraints));\n              return func(constraints);\n            });\n        }\n      }\n      constraints.video = constraintsToChrome_(constraints.video);\n    }\n    logging('chrome: ' + JSON.stringify(constraints));\n    return func(constraints);\n  };\n\n  const shimError_ = function(e) {\n    if (browserDetails.version >= 64) {\n      return e;\n    }\n    return {\n      name: {\n        PermissionDeniedError: 'NotAllowedError',\n        PermissionDismissedError: 'NotAllowedError',\n        InvalidStateError: 'NotAllowedError',\n        DevicesNotFoundError: 'NotFoundError',\n        ConstraintNotSatisfiedError: 'OverconstrainedError',\n        TrackStartError: 'NotReadableError',\n        MediaDeviceFailedDueToShutdown: 'NotAllowedError',\n        MediaDeviceKillSwitchOn: 'NotAllowedError',\n        TabCaptureError: 'AbortError',\n        ScreenCaptureError: 'AbortError',\n        DeviceCaptureError: 'AbortError'\n      }[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint || e.constraintName,\n      toString() {\n        return this.name + (this.message && ': ') + this.message;\n      }\n    };\n  };\n\n  const getUserMedia_ = function(constraints, onSuccess, onError) {\n    shimConstraints_(constraints, c => {\n      navigator.webkitGetUserMedia(c, onSuccess, e => {\n        if (onError) {\n          onError(shimError_(e));\n        }\n      });\n    });\n  };\n  navigator.getUserMedia = getUserMedia_.bind(navigator);\n\n  // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n  // function which returns a Promise, it does not accept spec-style\n  // constraints.\n  if (navigator.mediaDevices.getUserMedia) {\n    const origGetUserMedia = navigator.mediaDevices.getUserMedia.\n      bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(cs) {\n      return shimConstraints_(cs, c => origGetUserMedia(c).then(stream => {\n        if (c.audio && !stream.getAudioTracks().length ||\n            c.video && !stream.getVideoTracks().length) {\n          stream.getTracks().forEach(track => {\n            track.stop();\n          });\n          throw new DOMException('', 'NotFoundError');\n        }\n        return stream;\n      }, e => Promise.reject(shimError_(e))));\n    };\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvY2hyb21lL2dldHVzZXJtZWRpYS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUN3QjtBQUNyQyxnQkFBZ0IsMENBQVM7O0FBRWxCO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsWUFBWTtBQUN2RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL2Nocm9tZS9nZXR1c2VybWVkaWEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmNvbnN0IGxvZ2dpbmcgPSB1dGlscy5sb2c7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltR2V0VXNlck1lZGlhKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgY29uc3QgbmF2aWdhdG9yID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XG5cbiAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgY29uc3RyYWludHNUb0Nocm9tZV8gPSBmdW5jdGlvbihjKSB7XG4gICAgaWYgKHR5cGVvZiBjICE9PSAnb2JqZWN0JyB8fCBjLm1hbmRhdG9yeSB8fCBjLm9wdGlvbmFsKSB7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgY29uc3QgY2MgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhjKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoa2V5ID09PSAncmVxdWlyZScgfHwga2V5ID09PSAnYWR2YW5jZWQnIHx8IGtleSA9PT0gJ21lZGlhU291cmNlJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByID0gKHR5cGVvZiBjW2tleV0gPT09ICdvYmplY3QnKSA/IGNba2V5XSA6IHtpZGVhbDogY1trZXldfTtcbiAgICAgIGlmIChyLmV4YWN0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHIuZXhhY3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHIubWluID0gci5tYXggPSByLmV4YWN0O1xuICAgICAgfVxuICAgICAgY29uc3Qgb2xkbmFtZV8gPSBmdW5jdGlvbihwcmVmaXgsIG5hbWUpIHtcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgIHJldHVybiBwcmVmaXggKyBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG5hbWUgPT09ICdkZXZpY2VJZCcpID8gJ3NvdXJjZUlkJyA6IG5hbWU7XG4gICAgICB9O1xuICAgICAgaWYgKHIuaWRlYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYy5vcHRpb25hbCA9IGNjLm9wdGlvbmFsIHx8IFtdO1xuICAgICAgICBsZXQgb2MgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiByLmlkZWFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIG9jW29sZG5hbWVfKCdtaW4nLCBrZXkpXSA9IHIuaWRlYWw7XG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XG4gICAgICAgICAgb2MgPSB7fTtcbiAgICAgICAgICBvY1tvbGRuYW1lXygnbWF4Jywga2V5KV0gPSByLmlkZWFsO1xuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9jW29sZG5hbWVfKCcnLCBrZXkpXSA9IHIuaWRlYWw7XG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyLmV4YWN0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHIuZXhhY3QgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGNjLm1hbmRhdG9yeSA9IGNjLm1hbmRhdG9yeSB8fCB7fTtcbiAgICAgICAgY2MubWFuZGF0b3J5W29sZG5hbWVfKCcnLCBrZXkpXSA9IHIuZXhhY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbJ21pbicsICdtYXgnXS5mb3JFYWNoKG1peCA9PiB7XG4gICAgICAgICAgaWYgKHJbbWl4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYy5tYW5kYXRvcnkgPSBjYy5tYW5kYXRvcnkgfHwge307XG4gICAgICAgICAgICBjYy5tYW5kYXRvcnlbb2xkbmFtZV8obWl4LCBrZXkpXSA9IHJbbWl4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjLmFkdmFuY2VkKSB7XG4gICAgICBjYy5vcHRpb25hbCA9IChjYy5vcHRpb25hbCB8fCBbXSkuY29uY2F0KGMuYWR2YW5jZWQpO1xuICAgIH1cbiAgICByZXR1cm4gY2M7XG4gIH07XG5cbiAgY29uc3Qgc2hpbUNvbnN0cmFpbnRzXyA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzLCBmdW5jKSB7XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjEpIHtcbiAgICAgIHJldHVybiBmdW5jKGNvbnN0cmFpbnRzKTtcbiAgICB9XG4gICAgY29uc3RyYWludHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgaWYgKGNvbnN0cmFpbnRzICYmIHR5cGVvZiBjb25zdHJhaW50cy5hdWRpbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IHJlbWFwID0gZnVuY3Rpb24ob2JqLCBhLCBiKSB7XG4gICAgICAgIGlmIChhIGluIG9iaiAmJiAhKGIgaW4gb2JqKSkge1xuICAgICAgICAgIG9ialtiXSA9IG9ialthXTtcbiAgICAgICAgICBkZWxldGUgb2JqW2FdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3RyYWludHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgICByZW1hcChjb25zdHJhaW50cy5hdWRpbywgJ2F1dG9HYWluQ29udHJvbCcsICdnb29nQXV0b0dhaW5Db250cm9sJyk7XG4gICAgICByZW1hcChjb25zdHJhaW50cy5hdWRpbywgJ25vaXNlU3VwcHJlc3Npb24nLCAnZ29vZ05vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMuYXVkaW8pO1xuICAgIH1cbiAgICBpZiAoY29uc3RyYWludHMgJiYgdHlwZW9mIGNvbnN0cmFpbnRzLnZpZGVvID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gU2hpbSBmYWNpbmdNb2RlIGZvciBtb2JpbGUgJiBzdXJmYWNlIHByby5cbiAgICAgIGxldCBmYWNlID0gY29uc3RyYWludHMudmlkZW8uZmFjaW5nTW9kZTtcbiAgICAgIGZhY2UgPSBmYWNlICYmICgodHlwZW9mIGZhY2UgPT09ICdvYmplY3QnKSA/IGZhY2UgOiB7aWRlYWw6IGZhY2V9KTtcbiAgICAgIGNvbnN0IGdldFN1cHBvcnRlZEZhY2luZ01vZGVMaWVzID0gYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDY2O1xuXG4gICAgICBpZiAoKGZhY2UgJiYgKGZhY2UuZXhhY3QgPT09ICd1c2VyJyB8fCBmYWNlLmV4YWN0ID09PSAnZW52aXJvbm1lbnQnIHx8XG4gICAgICAgICAgICAgICAgICAgIGZhY2UuaWRlYWwgPT09ICd1c2VyJyB8fCBmYWNlLmlkZWFsID09PSAnZW52aXJvbm1lbnQnKSkgJiZcbiAgICAgICAgICAhKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMgJiZcbiAgICAgICAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMoKS5mYWNpbmdNb2RlICYmXG4gICAgICAgICAgICAhZ2V0U3VwcG9ydGVkRmFjaW5nTW9kZUxpZXMpKSB7XG4gICAgICAgIGRlbGV0ZSBjb25zdHJhaW50cy52aWRlby5mYWNpbmdNb2RlO1xuICAgICAgICBsZXQgbWF0Y2hlcztcbiAgICAgICAgaWYgKGZhY2UuZXhhY3QgPT09ICdlbnZpcm9ubWVudCcgfHwgZmFjZS5pZGVhbCA9PT0gJ2Vudmlyb25tZW50Jykge1xuICAgICAgICAgIG1hdGNoZXMgPSBbJ2JhY2snLCAncmVhciddO1xuICAgICAgICB9IGVsc2UgaWYgKGZhY2UuZXhhY3QgPT09ICd1c2VyJyB8fCBmYWNlLmlkZWFsID09PSAndXNlcicpIHtcbiAgICAgICAgICBtYXRjaGVzID0gWydmcm9udCddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgLy8gTG9vayBmb3IgbWF0Y2hlcyBpbiBsYWJlbCwgb3IgdXNlIGxhc3QgY2FtIGZvciBiYWNrICh0eXBpY2FsKS5cbiAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKClcbiAgICAgICAgICAgIC50aGVuKGRldmljZXMgPT4ge1xuICAgICAgICAgICAgICBkZXZpY2VzID0gZGV2aWNlcy5maWx0ZXIoZCA9PiBkLmtpbmQgPT09ICd2aWRlb2lucHV0Jyk7XG4gICAgICAgICAgICAgIGxldCBkZXYgPSBkZXZpY2VzLmZpbmQoZCA9PiBtYXRjaGVzLnNvbWUobWF0Y2ggPT5cbiAgICAgICAgICAgICAgICBkLmxhYmVsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMobWF0Y2gpKSk7XG4gICAgICAgICAgICAgIGlmICghZGV2ICYmIGRldmljZXMubGVuZ3RoICYmIG1hdGNoZXMuaW5jbHVkZXMoJ2JhY2snKSkge1xuICAgICAgICAgICAgICAgIGRldiA9IGRldmljZXNbZGV2aWNlcy5sZW5ndGggLSAxXTsgLy8gbW9yZSBsaWtlbHkgdGhlIGJhY2sgY2FtXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGRldikge1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvLmRldmljZUlkID0gZmFjZS5leGFjdFxuICAgICAgICAgICAgICAgICAgPyB7ZXhhY3Q6IGRldi5kZXZpY2VJZH1cbiAgICAgICAgICAgICAgICAgIDoge2lkZWFsOiBkZXYuZGV2aWNlSWR9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMudmlkZW8pO1xuICAgICAgICAgICAgICBsb2dnaW5nKCdjaHJvbWU6ICcgKyBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgICAgICAgICAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3RyYWludHMudmlkZW8gPSBjb25zdHJhaW50c1RvQ2hyb21lXyhjb25zdHJhaW50cy52aWRlbyk7XG4gICAgfVxuICAgIGxvZ2dpbmcoJ2Nocm9tZTogJyArIEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgcmV0dXJuIGZ1bmMoY29uc3RyYWludHMpO1xuICB9O1xuXG4gIGNvbnN0IHNoaW1FcnJvcl8gPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjQpIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZToge1xuICAgICAgICBQZXJtaXNzaW9uRGVuaWVkRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBQZXJtaXNzaW9uRGlzbWlzc2VkRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBJbnZhbGlkU3RhdGVFcnJvcjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIERldmljZXNOb3RGb3VuZEVycm9yOiAnTm90Rm91bmRFcnJvcicsXG4gICAgICAgIENvbnN0cmFpbnROb3RTYXRpc2ZpZWRFcnJvcjogJ092ZXJjb25zdHJhaW5lZEVycm9yJyxcbiAgICAgICAgVHJhY2tTdGFydEVycm9yOiAnTm90UmVhZGFibGVFcnJvcicsXG4gICAgICAgIE1lZGlhRGV2aWNlRmFpbGVkRHVlVG9TaHV0ZG93bjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIE1lZGlhRGV2aWNlS2lsbFN3aXRjaE9uOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgVGFiQ2FwdHVyZUVycm9yOiAnQWJvcnRFcnJvcicsXG4gICAgICAgIFNjcmVlbkNhcHR1cmVFcnJvcjogJ0Fib3J0RXJyb3InLFxuICAgICAgICBEZXZpY2VDYXB0dXJlRXJyb3I6ICdBYm9ydEVycm9yJ1xuICAgICAgfVtlLm5hbWVdIHx8IGUubmFtZSxcbiAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICAgIGNvbnN0cmFpbnQ6IGUuY29uc3RyYWludCB8fCBlLmNvbnN0cmFpbnROYW1lLFxuICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyAodGhpcy5tZXNzYWdlICYmICc6ICcpICsgdGhpcy5tZXNzYWdlO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgY29uc3QgZ2V0VXNlck1lZGlhXyA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICBzaGltQ29uc3RyYWludHNfKGNvbnN0cmFpbnRzLCBjID0+IHtcbiAgICAgIG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEoYywgb25TdWNjZXNzLCBlID0+IHtcbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICBvbkVycm9yKHNoaW1FcnJvcl8oZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IGdldFVzZXJNZWRpYV8uYmluZChuYXZpZ2F0b3IpO1xuXG4gIC8vIEV2ZW4gdGhvdWdoIENocm9tZSA0NSBoYXMgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyBhbmQgYSBnZXRVc2VyTWVkaWFcbiAgLy8gZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIFByb21pc2UsIGl0IGRvZXMgbm90IGFjY2VwdCBzcGVjLXN0eWxlXG4gIC8vIGNvbnN0cmFpbnRzLlxuICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICBjb25zdCBvcmlnR2V0VXNlck1lZGlhID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEuXG4gICAgICBiaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24oY3MpIHtcbiAgICAgIHJldHVybiBzaGltQ29uc3RyYWludHNfKGNzLCBjID0+IG9yaWdHZXRVc2VyTWVkaWEoYykudGhlbihzdHJlYW0gPT4ge1xuICAgICAgICBpZiAoYy5hdWRpbyAmJiAhc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoIHx8XG4gICAgICAgICAgICBjLnZpZGVvICYmICFzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGgpIHtcbiAgICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignJywgJ05vdEZvdW5kRXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSwgZSA9PiBQcm9taXNlLnJlamVjdChzaGltRXJyb3JfKGUpKSkpO1xuICAgIH07XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/webrtc-adapter/src/js/common_shim.js":
/*!***********************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/common_shim.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   removeExtmapAllowMixed: () => (/* binding */ removeExtmapAllowMixed),\n/* harmony export */   shimAddIceCandidateNullOrEmpty: () => (/* binding */ shimAddIceCandidateNullOrEmpty),\n/* harmony export */   shimConnectionState: () => (/* binding */ shimConnectionState),\n/* harmony export */   shimMaxMessageSize: () => (/* binding */ shimMaxMessageSize),\n/* harmony export */   shimParameterlessSetLocalDescription: () => (/* binding */ shimParameterlessSetLocalDescription),\n/* harmony export */   shimRTCIceCandidate: () => (/* binding */ shimRTCIceCandidate),\n/* harmony export */   shimRTCIceCandidateRelayProtocol: () => (/* binding */ shimRTCIceCandidateRelayProtocol),\n/* harmony export */   shimSendThrowTypeError: () => (/* binding */ shimSendThrowTypeError)\n/* harmony export */ });\n/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sdp */ \"(app-pages-browser)/./node_modules/sdp/sdp.js\");\n/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sdp__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/webrtc-adapter/src/js/utils.js\");\n/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\n\n\nfunction shimRTCIceCandidate(window) {\n  // foundation is arbitrarily chosen as an indicator for full support for\n  // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n  if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'foundation' in\n      window.RTCIceCandidate.prototype)) {\n    return;\n  }\n\n  const NativeRTCIceCandidate = window.RTCIceCandidate;\n  window.RTCIceCandidate = function RTCIceCandidate(args) {\n    // Remove the a= which shouldn't be part of the candidate string.\n    if (typeof args === 'object' && args.candidate &&\n        args.candidate.indexOf('a=') === 0) {\n      args = JSON.parse(JSON.stringify(args));\n      args.candidate = args.candidate.substring(2);\n    }\n\n    if (args.candidate && args.candidate.length) {\n      // Augment the native candidate with the parsed fields.\n      const nativeCandidate = new NativeRTCIceCandidate(args);\n      const parsedCandidate = sdp__WEBPACK_IMPORTED_MODULE_0___default().parseCandidate(args.candidate);\n      for (const key in parsedCandidate) {\n        if (!(key in nativeCandidate)) {\n          Object.defineProperty(nativeCandidate, key,\n            {value: parsedCandidate[key]});\n        }\n      }\n\n      // Override serializer to not serialize the extra attributes.\n      nativeCandidate.toJSON = function toJSON() {\n        return {\n          candidate: nativeCandidate.candidate,\n          sdpMid: nativeCandidate.sdpMid,\n          sdpMLineIndex: nativeCandidate.sdpMLineIndex,\n          usernameFragment: nativeCandidate.usernameFragment,\n        };\n      };\n      return nativeCandidate;\n    }\n    return new NativeRTCIceCandidate(args);\n  };\n  window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n\n  // Hook up the augmented candidate in onicecandidate and\n  // addEventListener('icecandidate', ...)\n  _utils__WEBPACK_IMPORTED_MODULE_1__.wrapPeerConnectionEvent(window, 'icecandidate', e => {\n    if (e.candidate) {\n      Object.defineProperty(e, 'candidate', {\n        value: new window.RTCIceCandidate(e.candidate),\n        writable: 'false'\n      });\n    }\n    return e;\n  });\n}\n\nfunction shimRTCIceCandidateRelayProtocol(window) {\n  if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'relayProtocol' in\n      window.RTCIceCandidate.prototype)) {\n    return;\n  }\n\n  // Hook up the augmented candidate in onicecandidate and\n  // addEventListener('icecandidate', ...)\n  _utils__WEBPACK_IMPORTED_MODULE_1__.wrapPeerConnectionEvent(window, 'icecandidate', e => {\n    if (e.candidate) {\n      const parsedCandidate = sdp__WEBPACK_IMPORTED_MODULE_0___default().parseCandidate(e.candidate.candidate);\n      if (parsedCandidate.type === 'relay') {\n        // This is a libwebrtc-specific mapping of local type preference\n        // to relayProtocol.\n        e.candidate.relayProtocol = {\n          0: 'tls',\n          1: 'tcp',\n          2: 'udp',\n        }[parsedCandidate.priority >> 24];\n      }\n    }\n    return e;\n  });\n}\n\nfunction shimMaxMessageSize(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  if (!('sctp' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {\n      get() {\n        return typeof this._sctp === 'undefined' ? null : this._sctp;\n      }\n    });\n  }\n\n  const sctpInDescription = function(description) {\n    if (!description || !description.sdp) {\n      return false;\n    }\n    const sections = sdp__WEBPACK_IMPORTED_MODULE_0___default().splitSections(description.sdp);\n    sections.shift();\n    return sections.some(mediaSection => {\n      const mLine = sdp__WEBPACK_IMPORTED_MODULE_0___default().parseMLine(mediaSection);\n      return mLine && mLine.kind === 'application'\n          && mLine.protocol.indexOf('SCTP') !== -1;\n    });\n  };\n\n  const getRemoteFirefoxVersion = function(description) {\n    // TODO: Is there a better solution for detecting Firefox?\n    const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n    if (match === null || match.length < 2) {\n      return -1;\n    }\n    const version = parseInt(match[1], 10);\n    // Test for NaN (yes, this is ugly)\n    return version !== version ? -1 : version;\n  };\n\n  const getCanSendMaxMessageSize = function(remoteIsFirefox) {\n    // Every implementation we know can send at least 64 KiB.\n    // Note: Although Chrome is technically able to send up to 256 KiB, the\n    //       data does not reach the other peer reliably.\n    //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n    let canSendMaxMessageSize = 65536;\n    if (browserDetails.browser === 'firefox') {\n      if (browserDetails.version < 57) {\n        if (remoteIsFirefox === -1) {\n          // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n          // fragmentation.\n          canSendMaxMessageSize = 16384;\n        } else {\n          // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n          // messages. Thus, supporting ~2 GiB when sending.\n          canSendMaxMessageSize = 2147483637;\n        }\n      } else if (browserDetails.version < 60) {\n        // Currently, all FF >= 57 will reset the remote maximum message size\n        // to the default value when a data channel is created at a later\n        // stage. :(\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n        canSendMaxMessageSize =\n          browserDetails.version === 57 ? 65535 : 65536;\n      } else {\n        // FF >= 60 supports sending ~2 GiB\n        canSendMaxMessageSize = 2147483637;\n      }\n    }\n    return canSendMaxMessageSize;\n  };\n\n  const getMaxMessageSize = function(description, remoteIsFirefox) {\n    // Note: 65536 bytes is the default value from the SDP spec. Also,\n    //       every implementation we know supports receiving 65536 bytes.\n    let maxMessageSize = 65536;\n\n    // FF 57 has a slightly incorrect default remote max message size, so\n    // we need to adjust it here to avoid a failure when sending.\n    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n    if (browserDetails.browser === 'firefox'\n         && browserDetails.version === 57) {\n      maxMessageSize = 65535;\n    }\n\n    const match = sdp__WEBPACK_IMPORTED_MODULE_0___default().matchPrefix(description.sdp,\n      'a=max-message-size:');\n    if (match.length > 0) {\n      maxMessageSize = parseInt(match[0].substring(19), 10);\n    } else if (browserDetails.browser === 'firefox' &&\n                remoteIsFirefox !== -1) {\n      // If the maximum message size is not present in the remote SDP and\n      // both local and remote are Firefox, the remote peer can receive\n      // ~2 GiB.\n      maxMessageSize = 2147483637;\n    }\n    return maxMessageSize;\n  };\n\n  const origSetRemoteDescription =\n      window.RTCPeerConnection.prototype.setRemoteDescription;\n  window.RTCPeerConnection.prototype.setRemoteDescription =\n    function setRemoteDescription() {\n      this._sctp = null;\n      // Chrome decided to not expose .sctp in plan-b mode.\n      // As usual, adapter.js has to do an 'ugly worakaround'\n      // to cover up the mess.\n      if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {\n        const {sdpSemantics} = this.getConfiguration();\n        if (sdpSemantics === 'plan-b') {\n          Object.defineProperty(this, 'sctp', {\n            get() {\n              return typeof this._sctp === 'undefined' ? null : this._sctp;\n            },\n            enumerable: true,\n            configurable: true,\n          });\n        }\n      }\n\n      if (sctpInDescription(arguments[0])) {\n        // Check if the remote is FF.\n        const isFirefox = getRemoteFirefoxVersion(arguments[0]);\n\n        // Get the maximum message size the local peer is capable of sending\n        const canSendMMS = getCanSendMaxMessageSize(isFirefox);\n\n        // Get the maximum message size of the remote peer.\n        const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n\n        // Determine final maximum message size\n        let maxMessageSize;\n        if (canSendMMS === 0 && remoteMMS === 0) {\n          maxMessageSize = Number.POSITIVE_INFINITY;\n        } else if (canSendMMS === 0 || remoteMMS === 0) {\n          maxMessageSize = Math.max(canSendMMS, remoteMMS);\n        } else {\n          maxMessageSize = Math.min(canSendMMS, remoteMMS);\n        }\n\n        // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\n        // attribute.\n        const sctp = {};\n        Object.defineProperty(sctp, 'maxMessageSize', {\n          get() {\n            return maxMessageSize;\n          }\n        });\n        this._sctp = sctp;\n      }\n\n      return origSetRemoteDescription.apply(this, arguments);\n    };\n}\n\nfunction shimSendThrowTypeError(window) {\n  if (!(window.RTCPeerConnection &&\n      'createDataChannel' in window.RTCPeerConnection.prototype)) {\n    return;\n  }\n\n  // Note: Although Firefox >= 57 has a native implementation, the maximum\n  //       message size can be reset for all data channels at a later stage.\n  //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n\n  function wrapDcSend(dc, pc) {\n    const origDataChannelSend = dc.send;\n    dc.send = function send() {\n      const data = arguments[0];\n      const length = data.length || data.size || data.byteLength;\n      if (dc.readyState === 'open' &&\n          pc.sctp && length > pc.sctp.maxMessageSize) {\n        throw new TypeError('Message too large (can send a maximum of ' +\n          pc.sctp.maxMessageSize + ' bytes)');\n      }\n      return origDataChannelSend.apply(dc, arguments);\n    };\n  }\n  const origCreateDataChannel =\n    window.RTCPeerConnection.prototype.createDataChannel;\n  window.RTCPeerConnection.prototype.createDataChannel =\n    function createDataChannel() {\n      const dataChannel = origCreateDataChannel.apply(this, arguments);\n      wrapDcSend(dataChannel, this);\n      return dataChannel;\n    };\n  _utils__WEBPACK_IMPORTED_MODULE_1__.wrapPeerConnectionEvent(window, 'datachannel', e => {\n    wrapDcSend(e.channel, e.target);\n    return e;\n  });\n}\n\n\n/* shims RTCConnectionState by pretending it is the same as iceConnectionState.\n * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12\n * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect\n * since DTLS failures would be hidden. See\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827\n * for the Firefox tracking bug.\n */\nfunction shimConnectionState(window) {\n  if (!window.RTCPeerConnection ||\n      'connectionState' in window.RTCPeerConnection.prototype) {\n    return;\n  }\n  const proto = window.RTCPeerConnection.prototype;\n  Object.defineProperty(proto, 'connectionState', {\n    get() {\n      return {\n        completed: 'connected',\n        checking: 'connecting'\n      }[this.iceConnectionState] || this.iceConnectionState;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(proto, 'onconnectionstatechange', {\n    get() {\n      return this._onconnectionstatechange || null;\n    },\n    set(cb) {\n      if (this._onconnectionstatechange) {\n        this.removeEventListener('connectionstatechange',\n          this._onconnectionstatechange);\n        delete this._onconnectionstatechange;\n      }\n      if (cb) {\n        this.addEventListener('connectionstatechange',\n          this._onconnectionstatechange = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ['setLocalDescription', 'setRemoteDescription'].forEach((method) => {\n    const origMethod = proto[method];\n    proto[method] = function() {\n      if (!this._connectionstatechangepoly) {\n        this._connectionstatechangepoly = e => {\n          const pc = e.target;\n          if (pc._lastConnectionState !== pc.connectionState) {\n            pc._lastConnectionState = pc.connectionState;\n            const newEvent = new Event('connectionstatechange', e);\n            pc.dispatchEvent(newEvent);\n          }\n          return e;\n        };\n        this.addEventListener('iceconnectionstatechange',\n          this._connectionstatechangepoly);\n      }\n      return origMethod.apply(this, arguments);\n    };\n  });\n}\n\nfunction removeExtmapAllowMixed(window, browserDetails) {\n  /* remove a=extmap-allow-mixed for webrtc.org < M71 */\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {\n    return;\n  }\n  if (browserDetails.browser === 'safari' &&\n      browserDetails._safariVersion >= 13.1) {\n    return;\n  }\n  const nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;\n  window.RTCPeerConnection.prototype.setRemoteDescription =\n  function setRemoteDescription(desc) {\n    if (desc && desc.sdp && desc.sdp.indexOf('\\na=extmap-allow-mixed') !== -1) {\n      const sdp = desc.sdp.split('\\n').filter((line) => {\n        return line.trim() !== 'a=extmap-allow-mixed';\n      }).join('\\n');\n      // Safari enforces read-only-ness of RTCSessionDescription fields.\n      if (window.RTCSessionDescription &&\n          desc instanceof window.RTCSessionDescription) {\n        arguments[0] = new window.RTCSessionDescription({\n          type: desc.type,\n          sdp,\n        });\n      } else {\n        desc.sdp = sdp;\n      }\n    }\n    return nativeSRD.apply(this, arguments);\n  };\n}\n\nfunction shimAddIceCandidateNullOrEmpty(window, browserDetails) {\n  // Support for addIceCandidate(null or undefined)\n  // as well as addIceCandidate({candidate: \"\", ...})\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n  // Note: must be called before other polyfills which change the signature.\n  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {\n    return;\n  }\n  const nativeAddIceCandidate =\n      window.RTCPeerConnection.prototype.addIceCandidate;\n  if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {\n    return;\n  }\n  window.RTCPeerConnection.prototype.addIceCandidate =\n    function addIceCandidate() {\n      if (!arguments[0]) {\n        if (arguments[1]) {\n          arguments[1].apply(null);\n        }\n        return Promise.resolve();\n      }\n      // Firefox 68+ emits and processes {candidate: \"\", ...}, ignore\n      // in older versions.\n      // Native support for ignoring exists for Chrome M77+.\n      // Safari ignores as well, exact version unknown but works in the same\n      // version that also ignores addIceCandidate(null).\n      if (((browserDetails.browser === 'chrome' && browserDetails.version < 78)\n           || (browserDetails.browser === 'firefox'\n               && browserDetails.version < 68)\n           || (browserDetails.browser === 'safari'))\n          && arguments[0] && arguments[0].candidate === '') {\n        return Promise.resolve();\n      }\n      return nativeAddIceCandidate.apply(this, arguments);\n    };\n}\n\n// Note: Make sure to call this ahead of APIs that modify\n// setLocalDescription.length\nfunction shimParameterlessSetLocalDescription(window, browserDetails) {\n  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {\n    return;\n  }\n  const nativeSetLocalDescription =\n      window.RTCPeerConnection.prototype.setLocalDescription;\n  if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {\n    return;\n  }\n  window.RTCPeerConnection.prototype.setLocalDescription =\n    function setLocalDescription() {\n      let desc = arguments[0] || {};\n      if (typeof desc !== 'object' || (desc.type && desc.sdp)) {\n        return nativeSetLocalDescription.apply(this, arguments);\n      }\n      // The remaining steps should technically happen when SLD comes off the\n      // RTCPeerConnection's operations chain (not ahead of going on it), but\n      // this is too difficult to shim. Instead, this shim only covers the\n      // common case where the operations chain is empty. This is imperfect, but\n      // should cover many cases. Rationale: Even if we can't reduce the glare\n      // window to zero on imperfect implementations, there's value in tapping\n      // into the perfect negotiation pattern that several browsers support.\n      desc = {type: desc.type, sdp: desc.sdp};\n      if (!desc.type) {\n        switch (this.signalingState) {\n          case 'stable':\n          case 'have-local-offer':\n          case 'have-remote-pranswer':\n            desc.type = 'offer';\n            break;\n          default:\n            desc.type = 'answer';\n            break;\n        }\n      }\n      if (desc.sdp || (desc.type !== 'offer' && desc.type !== 'answer')) {\n        return nativeSetLocalDescription.apply(this, [desc]);\n      }\n      const func = desc.type === 'offer' ? this.createOffer : this.createAnswer;\n      return func.apply(this)\n        .then(d => nativeSetLocalDescription.apply(this, [d]));\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvY29tbW9uX3NoaW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWM7QUFDTTs7QUFFMUI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseURBQXVCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRSwyREFBNkI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFLDJEQUE2QjtBQUMvQjtBQUNBLDhCQUE4Qix5REFBdUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQXNCO0FBQzNDO0FBQ0E7QUFDQSxvQkFBb0IscURBQW1CO0FBQ3ZDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNEQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDJEQUE2QjtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGlDQUFpQyxtQkFBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1CQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvY29tbW9uX3NoaW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFNEUFV0aWxzIGZyb20gJ3NkcCc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1SVENJY2VDYW5kaWRhdGUod2luZG93KSB7XG4gIC8vIGZvdW5kYXRpb24gaXMgYXJiaXRyYXJpbHkgY2hvc2VuIGFzIGFuIGluZGljYXRvciBmb3IgZnVsbCBzdXBwb3J0IGZvclxuICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLXBjLyNydGNpY2VjYW5kaWRhdGUtaW50ZXJmYWNlXG4gIGlmICghd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSB8fCAod2luZG93LlJUQ0ljZUNhbmRpZGF0ZSAmJiAnZm91bmRhdGlvbicgaW5cbiAgICAgIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUucHJvdG90eXBlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZSA9IHdpbmRvdy5SVENJY2VDYW5kaWRhdGU7XG4gIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgPSBmdW5jdGlvbiBSVENJY2VDYW5kaWRhdGUoYXJncykge1xuICAgIC8vIFJlbW92ZSB0aGUgYT0gd2hpY2ggc2hvdWxkbid0IGJlIHBhcnQgb2YgdGhlIGNhbmRpZGF0ZSBzdHJpbmcuXG4gICAgaWYgKHR5cGVvZiBhcmdzID09PSAnb2JqZWN0JyAmJiBhcmdzLmNhbmRpZGF0ZSAmJlxuICAgICAgICBhcmdzLmNhbmRpZGF0ZS5pbmRleE9mKCdhPScpID09PSAwKSB7XG4gICAgICBhcmdzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhcmdzKSk7XG4gICAgICBhcmdzLmNhbmRpZGF0ZSA9IGFyZ3MuY2FuZGlkYXRlLnN1YnN0cmluZygyKTtcbiAgICB9XG5cbiAgICBpZiAoYXJncy5jYW5kaWRhdGUgJiYgYXJncy5jYW5kaWRhdGUubGVuZ3RoKSB7XG4gICAgICAvLyBBdWdtZW50IHRoZSBuYXRpdmUgY2FuZGlkYXRlIHdpdGggdGhlIHBhcnNlZCBmaWVsZHMuXG4gICAgICBjb25zdCBuYXRpdmVDYW5kaWRhdGUgPSBuZXcgTmF0aXZlUlRDSWNlQ2FuZGlkYXRlKGFyZ3MpO1xuICAgICAgY29uc3QgcGFyc2VkQ2FuZGlkYXRlID0gU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUoYXJncy5jYW5kaWRhdGUpO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyc2VkQ2FuZGlkYXRlKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBuYXRpdmVDYW5kaWRhdGUpKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdGl2ZUNhbmRpZGF0ZSwga2V5LFxuICAgICAgICAgICAge3ZhbHVlOiBwYXJzZWRDYW5kaWRhdGVba2V5XX0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE92ZXJyaWRlIHNlcmlhbGl6ZXIgdG8gbm90IHNlcmlhbGl6ZSB0aGUgZXh0cmEgYXR0cmlidXRlcy5cbiAgICAgIG5hdGl2ZUNhbmRpZGF0ZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FuZGlkYXRlOiBuYXRpdmVDYW5kaWRhdGUuY2FuZGlkYXRlLFxuICAgICAgICAgIHNkcE1pZDogbmF0aXZlQ2FuZGlkYXRlLnNkcE1pZCxcbiAgICAgICAgICBzZHBNTGluZUluZGV4OiBuYXRpdmVDYW5kaWRhdGUuc2RwTUxpbmVJbmRleCxcbiAgICAgICAgICB1c2VybmFtZUZyYWdtZW50OiBuYXRpdmVDYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudCxcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gbmF0aXZlQ2FuZGlkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZShhcmdzKTtcbiAgfTtcbiAgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGUgPSBOYXRpdmVSVENJY2VDYW5kaWRhdGUucHJvdG90eXBlO1xuXG4gIC8vIEhvb2sgdXAgdGhlIGF1Z21lbnRlZCBjYW5kaWRhdGUgaW4gb25pY2VjYW5kaWRhdGUgYW5kXG4gIC8vIGFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIC4uLilcbiAgdXRpbHMud3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAnaWNlY2FuZGlkYXRlJywgZSA9PiB7XG4gICAgaWYgKGUuY2FuZGlkYXRlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ2NhbmRpZGF0ZScsIHtcbiAgICAgICAgdmFsdWU6IG5ldyB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlKGUuY2FuZGlkYXRlKSxcbiAgICAgICAgd3JpdGFibGU6ICdmYWxzZSdcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltUlRDSWNlQ2FuZGlkYXRlUmVsYXlQcm90b2NvbCh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIHx8ICh3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlICYmICdyZWxheVByb3RvY29sJyBpblxuICAgICAgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSG9vayB1cCB0aGUgYXVnbWVudGVkIGNhbmRpZGF0ZSBpbiBvbmljZWNhbmRpZGF0ZSBhbmRcbiAgLy8gYWRkRXZlbnRMaXN0ZW5lcignaWNlY2FuZGlkYXRlJywgLi4uKVxuICB1dGlscy53cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICdpY2VjYW5kaWRhdGUnLCBlID0+IHtcbiAgICBpZiAoZS5jYW5kaWRhdGUpIHtcbiAgICAgIGNvbnN0IHBhcnNlZENhbmRpZGF0ZSA9IFNEUFV0aWxzLnBhcnNlQ2FuZGlkYXRlKGUuY2FuZGlkYXRlLmNhbmRpZGF0ZSk7XG4gICAgICBpZiAocGFyc2VkQ2FuZGlkYXRlLnR5cGUgPT09ICdyZWxheScpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGxpYndlYnJ0Yy1zcGVjaWZpYyBtYXBwaW5nIG9mIGxvY2FsIHR5cGUgcHJlZmVyZW5jZVxuICAgICAgICAvLyB0byByZWxheVByb3RvY29sLlxuICAgICAgICBlLmNhbmRpZGF0ZS5yZWxheVByb3RvY29sID0ge1xuICAgICAgICAgIDA6ICd0bHMnLFxuICAgICAgICAgIDE6ICd0Y3AnLFxuICAgICAgICAgIDI6ICd1ZHAnLFxuICAgICAgICB9W3BhcnNlZENhbmRpZGF0ZS5wcmlvcml0eSA+PiAyNF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCEoJ3NjdHAnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdzY3RwJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX3NjdHAgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHRoaXMuX3NjdHA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBzY3RwSW5EZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgaWYgKCFkZXNjcmlwdGlvbiB8fCAhZGVzY3JpcHRpb24uc2RwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhkZXNjcmlwdGlvbi5zZHApO1xuICAgIHNlY3Rpb25zLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHNlY3Rpb25zLnNvbWUobWVkaWFTZWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IG1MaW5lID0gU0RQVXRpbHMucGFyc2VNTGluZShtZWRpYVNlY3Rpb24pO1xuICAgICAgcmV0dXJuIG1MaW5lICYmIG1MaW5lLmtpbmQgPT09ICdhcHBsaWNhdGlvbidcbiAgICAgICAgICAmJiBtTGluZS5wcm90b2NvbC5pbmRleE9mKCdTQ1RQJykgIT09IC0xO1xuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IGdldFJlbW90ZUZpcmVmb3hWZXJzaW9uID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICAvLyBUT0RPOiBJcyB0aGVyZSBhIGJldHRlciBzb2x1dGlvbiBmb3IgZGV0ZWN0aW5nIEZpcmVmb3g/XG4gICAgY29uc3QgbWF0Y2ggPSBkZXNjcmlwdGlvbi5zZHAubWF0Y2goL21vemlsbGEuLi5USElTX0lTX1NEUEFSVEEtKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoID09PSBudWxsIHx8IG1hdGNoLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgY29uc3QgdmVyc2lvbiA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgLy8gVGVzdCBmb3IgTmFOICh5ZXMsIHRoaXMgaXMgdWdseSlcbiAgICByZXR1cm4gdmVyc2lvbiAhPT0gdmVyc2lvbiA/IC0xIDogdmVyc2lvbjtcbiAgfTtcblxuICBjb25zdCBnZXRDYW5TZW5kTWF4TWVzc2FnZVNpemUgPSBmdW5jdGlvbihyZW1vdGVJc0ZpcmVmb3gpIHtcbiAgICAvLyBFdmVyeSBpbXBsZW1lbnRhdGlvbiB3ZSBrbm93IGNhbiBzZW5kIGF0IGxlYXN0IDY0IEtpQi5cbiAgICAvLyBOb3RlOiBBbHRob3VnaCBDaHJvbWUgaXMgdGVjaG5pY2FsbHkgYWJsZSB0byBzZW5kIHVwIHRvIDI1NiBLaUIsIHRoZVxuICAgIC8vICAgICAgIGRhdGEgZG9lcyBub3QgcmVhY2ggdGhlIG90aGVyIHBlZXIgcmVsaWFibHkuXG4gICAgLy8gICAgICAgU2VlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9ODQxOVxuICAgIGxldCBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcbiAgICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnKSB7XG4gICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDU3KSB7XG4gICAgICAgIGlmIChyZW1vdGVJc0ZpcmVmb3ggPT09IC0xKSB7XG4gICAgICAgICAgLy8gRkYgPCA1NyB3aWxsIHNlbmQgaW4gMTYgS2lCIGNodW5rcyB1c2luZyB0aGUgZGVwcmVjYXRlZCBQUElEXG4gICAgICAgICAgLy8gZnJhZ21lbnRhdGlvbi5cbiAgICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAxNjM4NDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBIb3dldmVyLCBvdGhlciBGRiAoYW5kIFJBV1JUQykgY2FuIHJlYXNzZW1ibGUgUFBJRC1mcmFnbWVudGVkXG4gICAgICAgICAgLy8gbWVzc2FnZXMuIFRodXMsIHN1cHBvcnRpbmcgfjIgR2lCIHdoZW4gc2VuZGluZy5cbiAgICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAyMTQ3NDgzNjM3O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA2MCkge1xuICAgICAgICAvLyBDdXJyZW50bHksIGFsbCBGRiA+PSA1NyB3aWxsIHJlc2V0IHRoZSByZW1vdGUgbWF4aW11bSBtZXNzYWdlIHNpemVcbiAgICAgICAgLy8gdG8gdGhlIGRlZmF1bHQgdmFsdWUgd2hlbiBhIGRhdGEgY2hhbm5lbCBpcyBjcmVhdGVkIGF0IGEgbGF0ZXJcbiAgICAgICAgLy8gc3RhZ2UuIDooXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNjgzMVxuICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPVxuICAgICAgICAgIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPT09IDU3ID8gNjU1MzUgOiA2NTUzNjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZGID49IDYwIHN1cHBvcnRzIHNlbmRpbmcgfjIgR2lCXG4gICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDIxNDc0ODM2Mzc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYW5TZW5kTWF4TWVzc2FnZVNpemU7XG4gIH07XG5cbiAgY29uc3QgZ2V0TWF4TWVzc2FnZVNpemUgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgcmVtb3RlSXNGaXJlZm94KSB7XG4gICAgLy8gTm90ZTogNjU1MzYgYnl0ZXMgaXMgdGhlIGRlZmF1bHQgdmFsdWUgZnJvbSB0aGUgU0RQIHNwZWMuIEFsc28sXG4gICAgLy8gICAgICAgZXZlcnkgaW1wbGVtZW50YXRpb24gd2Uga25vdyBzdXBwb3J0cyByZWNlaXZpbmcgNjU1MzYgYnl0ZXMuXG4gICAgbGV0IG1heE1lc3NhZ2VTaXplID0gNjU1MzY7XG5cbiAgICAvLyBGRiA1NyBoYXMgYSBzbGlnaHRseSBpbmNvcnJlY3QgZGVmYXVsdCByZW1vdGUgbWF4IG1lc3NhZ2Ugc2l6ZSwgc29cbiAgICAvLyB3ZSBuZWVkIHRvIGFkanVzdCBpdCBoZXJlIHRvIGF2b2lkIGEgZmFpbHVyZSB3aGVuIHNlbmRpbmcuXG4gICAgLy8gU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI1Njk3XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdmaXJlZm94J1xuICAgICAgICAgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA9PT0gNTcpIHtcbiAgICAgIG1heE1lc3NhZ2VTaXplID0gNjU1MzU7XG4gICAgfVxuXG4gICAgY29uc3QgbWF0Y2ggPSBTRFBVdGlscy5tYXRjaFByZWZpeChkZXNjcmlwdGlvbi5zZHAsXG4gICAgICAnYT1tYXgtbWVzc2FnZS1zaXplOicpO1xuICAgIGlmIChtYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICBtYXhNZXNzYWdlU2l6ZSA9IHBhcnNlSW50KG1hdGNoWzBdLnN1YnN0cmluZygxOSksIDEwKTtcbiAgICB9IGVsc2UgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdmaXJlZm94JyAmJlxuICAgICAgICAgICAgICAgIHJlbW90ZUlzRmlyZWZveCAhPT0gLTEpIHtcbiAgICAgIC8vIElmIHRoZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZSBpcyBub3QgcHJlc2VudCBpbiB0aGUgcmVtb3RlIFNEUCBhbmRcbiAgICAgIC8vIGJvdGggbG9jYWwgYW5kIHJlbW90ZSBhcmUgRmlyZWZveCwgdGhlIHJlbW90ZSBwZWVyIGNhbiByZWNlaXZlXG4gICAgICAvLyB+MiBHaUIuXG4gICAgICBtYXhNZXNzYWdlU2l6ZSA9IDIxNDc0ODM2Mzc7XG4gICAgfVxuICAgIHJldHVybiBtYXhNZXNzYWdlU2l6ZTtcbiAgfTtcblxuICBjb25zdCBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24gPVxuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9XG4gICAgZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XG4gICAgICB0aGlzLl9zY3RwID0gbnVsbDtcbiAgICAgIC8vIENocm9tZSBkZWNpZGVkIHRvIG5vdCBleHBvc2UgLnNjdHAgaW4gcGxhbi1iIG1vZGUuXG4gICAgICAvLyBBcyB1c3VhbCwgYWRhcHRlci5qcyBoYXMgdG8gZG8gYW4gJ3VnbHkgd29yYWthcm91bmQnXG4gICAgICAvLyB0byBjb3ZlciB1cCB0aGUgbWVzcy5cbiAgICAgIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnY2hyb21lJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDc2KSB7XG4gICAgICAgIGNvbnN0IHtzZHBTZW1hbnRpY3N9ID0gdGhpcy5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgICAgIGlmIChzZHBTZW1hbnRpY3MgPT09ICdwbGFuLWInKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY3RwJywge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX3NjdHAgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHRoaXMuX3NjdHA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2N0cEluRGVzY3JpcHRpb24oYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgcmVtb3RlIGlzIEZGLlxuICAgICAgICBjb25zdCBpc0ZpcmVmb3ggPSBnZXRSZW1vdGVGaXJlZm94VmVyc2lvbihhcmd1bWVudHNbMF0pO1xuXG4gICAgICAgIC8vIEdldCB0aGUgbWF4aW11bSBtZXNzYWdlIHNpemUgdGhlIGxvY2FsIHBlZXIgaXMgY2FwYWJsZSBvZiBzZW5kaW5nXG4gICAgICAgIGNvbnN0IGNhblNlbmRNTVMgPSBnZXRDYW5TZW5kTWF4TWVzc2FnZVNpemUoaXNGaXJlZm94KTtcblxuICAgICAgICAvLyBHZXQgdGhlIG1heGltdW0gbWVzc2FnZSBzaXplIG9mIHRoZSByZW1vdGUgcGVlci5cbiAgICAgICAgY29uc3QgcmVtb3RlTU1TID0gZ2V0TWF4TWVzc2FnZVNpemUoYXJndW1lbnRzWzBdLCBpc0ZpcmVmb3gpO1xuXG4gICAgICAgIC8vIERldGVybWluZSBmaW5hbCBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZVxuICAgICAgICBsZXQgbWF4TWVzc2FnZVNpemU7XG4gICAgICAgIGlmIChjYW5TZW5kTU1TID09PSAwICYmIHJlbW90ZU1NUyA9PT0gMCkge1xuICAgICAgICAgIG1heE1lc3NhZ2VTaXplID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB9IGVsc2UgaWYgKGNhblNlbmRNTVMgPT09IDAgfHwgcmVtb3RlTU1TID09PSAwKSB7XG4gICAgICAgICAgbWF4TWVzc2FnZVNpemUgPSBNYXRoLm1heChjYW5TZW5kTU1TLCByZW1vdGVNTVMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1heE1lc3NhZ2VTaXplID0gTWF0aC5taW4oY2FuU2VuZE1NUywgcmVtb3RlTU1TKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhIGR1bW15IFJUQ1NjdHBUcmFuc3BvcnQgb2JqZWN0IGFuZCB0aGUgJ21heE1lc3NhZ2VTaXplJ1xuICAgICAgICAvLyBhdHRyaWJ1dGUuXG4gICAgICAgIGNvbnN0IHNjdHAgPSB7fTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNjdHAsICdtYXhNZXNzYWdlU2l6ZScsIHtcbiAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF4TWVzc2FnZVNpemU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2N0cCA9IHNjdHA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3cpIHtcbiAgaWYgKCEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmXG4gICAgICAnY3JlYXRlRGF0YUNoYW5uZWwnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gTm90ZTogQWx0aG91Z2ggRmlyZWZveCA+PSA1NyBoYXMgYSBuYXRpdmUgaW1wbGVtZW50YXRpb24sIHRoZSBtYXhpbXVtXG4gIC8vICAgICAgIG1lc3NhZ2Ugc2l6ZSBjYW4gYmUgcmVzZXQgZm9yIGFsbCBkYXRhIGNoYW5uZWxzIGF0IGEgbGF0ZXIgc3RhZ2UuXG4gIC8vICAgICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNjgzMVxuXG4gIGZ1bmN0aW9uIHdyYXBEY1NlbmQoZGMsIHBjKSB7XG4gICAgY29uc3Qgb3JpZ0RhdGFDaGFubmVsU2VuZCA9IGRjLnNlbmQ7XG4gICAgZGMuc2VuZCA9IGZ1bmN0aW9uIHNlbmQoKSB7XG4gICAgICBjb25zdCBkYXRhID0gYXJndW1lbnRzWzBdO1xuICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGggfHwgZGF0YS5zaXplIHx8IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIGlmIChkYy5yZWFkeVN0YXRlID09PSAnb3BlbicgJiZcbiAgICAgICAgICBwYy5zY3RwICYmIGxlbmd0aCA+IHBjLnNjdHAubWF4TWVzc2FnZVNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWVzc2FnZSB0b28gbGFyZ2UgKGNhbiBzZW5kIGEgbWF4aW11bSBvZiAnICtcbiAgICAgICAgICBwYy5zY3RwLm1heE1lc3NhZ2VTaXplICsgJyBieXRlcyknKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnRGF0YUNoYW5uZWxTZW5kLmFwcGx5KGRjLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbiAgY29uc3Qgb3JpZ0NyZWF0ZURhdGFDaGFubmVsID1cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZURhdGFDaGFubmVsO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZURhdGFDaGFubmVsID1cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRhQ2hhbm5lbCgpIHtcbiAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gb3JpZ0NyZWF0ZURhdGFDaGFubmVsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB3cmFwRGNTZW5kKGRhdGFDaGFubmVsLCB0aGlzKTtcbiAgICAgIHJldHVybiBkYXRhQ2hhbm5lbDtcbiAgICB9O1xuICB1dGlscy53cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICdkYXRhY2hhbm5lbCcsIGUgPT4ge1xuICAgIHdyYXBEY1NlbmQoZS5jaGFubmVsLCBlLnRhcmdldCk7XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xufVxuXG5cbi8qIHNoaW1zIFJUQ0Nvbm5lY3Rpb25TdGF0ZSBieSBwcmV0ZW5kaW5nIGl0IGlzIHRoZSBzYW1lIGFzIGljZUNvbm5lY3Rpb25TdGF0ZS5cbiAqIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NjE0NSNjMTJcbiAqIGZvciB3aHkgdGhpcyBpcyBhIHZhbGlkIGhhY2sgaW4gQ2hyb21lLiBJbiBGaXJlZm94IGl0IGlzIHNsaWdodGx5IGluY29ycmVjdFxuICogc2luY2UgRFRMUyBmYWlsdXJlcyB3b3VsZCBiZSBoaWRkZW4uIFNlZVxuICogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI2NTgyN1xuICogZm9yIHRoZSBGaXJlZm94IHRyYWNraW5nIGJ1Zy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNoaW1Db25uZWN0aW9uU3RhdGUod2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8XG4gICAgICAnY29ubmVjdGlvblN0YXRlJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByb3RvID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnY29ubmVjdGlvblN0YXRlJywge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBsZXRlZDogJ2Nvbm5lY3RlZCcsXG4gICAgICAgIGNoZWNraW5nOiAnY29ubmVjdGluZydcbiAgICAgIH1bdGhpcy5pY2VDb25uZWN0aW9uU3RhdGVdIHx8IHRoaXMuaWNlQ29ubmVjdGlvblN0YXRlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ29uY29ubmVjdGlvbnN0YXRlY2hhbmdlJywge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSB8fCBudWxsO1xuICAgIH0sXG4gICAgc2V0KGNiKSB7XG4gICAgICBpZiAodGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLFxuICAgICAgICAgIHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlO1xuICAgICAgfVxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJyxcbiAgICAgICAgICB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IGNiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbiddLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICAgIGNvbnN0IG9yaWdNZXRob2QgPSBwcm90b1ttZXRob2RdO1xuICAgIHByb3RvW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGlvbnN0YXRlY2hhbmdlcG9seSkge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5ID0gZSA9PiB7XG4gICAgICAgICAgY29uc3QgcGMgPSBlLnRhcmdldDtcbiAgICAgICAgICBpZiAocGMuX2xhc3RDb25uZWN0aW9uU3RhdGUgIT09IHBjLmNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgcGMuX2xhc3RDb25uZWN0aW9uU3RhdGUgPSBwYy5jb25uZWN0aW9uU3RhdGU7XG4gICAgICAgICAgICBjb25zdCBuZXdFdmVudCA9IG5ldyBFdmVudCgnY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgZSk7XG4gICAgICAgICAgICBwYy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJyxcbiAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVFeHRtYXBBbGxvd01peGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgLyogcmVtb3ZlIGE9ZXh0bWFwLWFsbG93LW1peGVkIGZvciB3ZWJydGMub3JnIDwgTTcxICovXG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnY2hyb21lJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDcxKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnc2FmYXJpJyAmJlxuICAgICAgYnJvd3NlckRldGFpbHMuX3NhZmFyaVZlcnNpb24gPj0gMTMuMSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuYXRpdmVTUkQgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID1cbiAgZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oZGVzYykge1xuICAgIGlmIChkZXNjICYmIGRlc2Muc2RwICYmIGRlc2Muc2RwLmluZGV4T2YoJ1xcbmE9ZXh0bWFwLWFsbG93LW1peGVkJykgIT09IC0xKSB7XG4gICAgICBjb25zdCBzZHAgPSBkZXNjLnNkcC5zcGxpdCgnXFxuJykuZmlsdGVyKChsaW5lKSA9PiB7XG4gICAgICAgIHJldHVybiBsaW5lLnRyaW0oKSAhPT0gJ2E9ZXh0bWFwLWFsbG93LW1peGVkJztcbiAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgLy8gU2FmYXJpIGVuZm9yY2VzIHJlYWQtb25seS1uZXNzIG9mIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiBmaWVsZHMuXG4gICAgICBpZiAod2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiAmJlxuICAgICAgICAgIGRlc2MgaW5zdGFuY2VvZiB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgICB0eXBlOiBkZXNjLnR5cGUsXG4gICAgICAgICAgc2RwLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlc2Muc2RwID0gc2RwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlU1JELmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHkod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICAvLyBTdXBwb3J0IGZvciBhZGRJY2VDYW5kaWRhdGUobnVsbCBvciB1bmRlZmluZWQpXG4gIC8vIGFzIHdlbGwgYXMgYWRkSWNlQ2FuZGlkYXRlKHtjYW5kaWRhdGU6IFwiXCIsIC4uLn0pXG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTk3ODU4MlxuICAvLyBOb3RlOiBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgb3RoZXIgcG9seWZpbGxzIHdoaWNoIGNoYW5nZSB0aGUgc2lnbmF0dXJlLlxuICBpZiAoISh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbmF0aXZlQWRkSWNlQ2FuZGlkYXRlID1cbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlO1xuICBpZiAoIW5hdGl2ZUFkZEljZUNhbmRpZGF0ZSB8fCBuYXRpdmVBZGRJY2VDYW5kaWRhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlID1cbiAgICBmdW5jdGlvbiBhZGRJY2VDYW5kaWRhdGUoKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50c1swXSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzWzFdKSB7XG4gICAgICAgICAgYXJndW1lbnRzWzFdLmFwcGx5KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIC8vIEZpcmVmb3ggNjgrIGVtaXRzIGFuZCBwcm9jZXNzZXMge2NhbmRpZGF0ZTogXCJcIiwgLi4ufSwgaWdub3JlXG4gICAgICAvLyBpbiBvbGRlciB2ZXJzaW9ucy5cbiAgICAgIC8vIE5hdGl2ZSBzdXBwb3J0IGZvciBpZ25vcmluZyBleGlzdHMgZm9yIENocm9tZSBNNzcrLlxuICAgICAgLy8gU2FmYXJpIGlnbm9yZXMgYXMgd2VsbCwgZXhhY3QgdmVyc2lvbiB1bmtub3duIGJ1dCB3b3JrcyBpbiB0aGUgc2FtZVxuICAgICAgLy8gdmVyc2lvbiB0aGF0IGFsc28gaWdub3JlcyBhZGRJY2VDYW5kaWRhdGUobnVsbCkuXG4gICAgICBpZiAoKChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnY2hyb21lJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNzgpXG4gICAgICAgICAgIHx8IChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnZmlyZWZveCdcbiAgICAgICAgICAgICAgICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA2OClcbiAgICAgICAgICAgfHwgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdzYWZhcmknKSlcbiAgICAgICAgICAmJiBhcmd1bWVudHNbMF0gJiYgYXJndW1lbnRzWzBdLmNhbmRpZGF0ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZUFkZEljZUNhbmRpZGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8vIE5vdGU6IE1ha2Ugc3VyZSB0byBjYWxsIHRoaXMgYWhlYWQgb2YgQVBJcyB0aGF0IG1vZGlmeVxuLy8gc2V0TG9jYWxEZXNjcmlwdGlvbi5sZW5ndGhcbmV4cG9ydCBmdW5jdGlvbiBzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24od2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAoISh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbiA9XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb247XG4gIGlmICghbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbiB8fCBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPVxuICAgIGZ1bmN0aW9uIHNldExvY2FsRGVzY3JpcHRpb24oKSB7XG4gICAgICBsZXQgZGVzYyA9IGFyZ3VtZW50c1swXSB8fCB7fTtcbiAgICAgIGlmICh0eXBlb2YgZGVzYyAhPT0gJ29iamVjdCcgfHwgKGRlc2MudHlwZSAmJiBkZXNjLnNkcCkpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSByZW1haW5pbmcgc3RlcHMgc2hvdWxkIHRlY2huaWNhbGx5IGhhcHBlbiB3aGVuIFNMRCBjb21lcyBvZmYgdGhlXG4gICAgICAvLyBSVENQZWVyQ29ubmVjdGlvbidzIG9wZXJhdGlvbnMgY2hhaW4gKG5vdCBhaGVhZCBvZiBnb2luZyBvbiBpdCksIGJ1dFxuICAgICAgLy8gdGhpcyBpcyB0b28gZGlmZmljdWx0IHRvIHNoaW0uIEluc3RlYWQsIHRoaXMgc2hpbSBvbmx5IGNvdmVycyB0aGVcbiAgICAgIC8vIGNvbW1vbiBjYXNlIHdoZXJlIHRoZSBvcGVyYXRpb25zIGNoYWluIGlzIGVtcHR5LiBUaGlzIGlzIGltcGVyZmVjdCwgYnV0XG4gICAgICAvLyBzaG91bGQgY292ZXIgbWFueSBjYXNlcy4gUmF0aW9uYWxlOiBFdmVuIGlmIHdlIGNhbid0IHJlZHVjZSB0aGUgZ2xhcmVcbiAgICAgIC8vIHdpbmRvdyB0byB6ZXJvIG9uIGltcGVyZmVjdCBpbXBsZW1lbnRhdGlvbnMsIHRoZXJlJ3MgdmFsdWUgaW4gdGFwcGluZ1xuICAgICAgLy8gaW50byB0aGUgcGVyZmVjdCBuZWdvdGlhdGlvbiBwYXR0ZXJuIHRoYXQgc2V2ZXJhbCBicm93c2VycyBzdXBwb3J0LlxuICAgICAgZGVzYyA9IHt0eXBlOiBkZXNjLnR5cGUsIHNkcDogZGVzYy5zZHB9O1xuICAgICAgaWYgKCFkZXNjLnR5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNpZ25hbGluZ1N0YXRlKSB7XG4gICAgICAgICAgY2FzZSAnc3RhYmxlJzpcbiAgICAgICAgICBjYXNlICdoYXZlLWxvY2FsLW9mZmVyJzpcbiAgICAgICAgICBjYXNlICdoYXZlLXJlbW90ZS1wcmFuc3dlcic6XG4gICAgICAgICAgICBkZXNjLnR5cGUgPSAnb2ZmZXInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGRlc2MudHlwZSA9ICdhbnN3ZXInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkZXNjLnNkcCB8fCAoZGVzYy50eXBlICE9PSAnb2ZmZXInICYmIGRlc2MudHlwZSAhPT0gJ2Fuc3dlcicpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkZXNjXSk7XG4gICAgICB9XG4gICAgICBjb25zdCBmdW5jID0gZGVzYy50eXBlID09PSAnb2ZmZXInID8gdGhpcy5jcmVhdGVPZmZlciA6IHRoaXMuY3JlYXRlQW5zd2VyO1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcylcbiAgICAgICAgLnRoZW4oZCA9PiBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkXSkpO1xuICAgIH07XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/webrtc-adapter/src/js/common_shim.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js":
/*!********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shimAddTransceiver: () => (/* binding */ shimAddTransceiver),\n/* harmony export */   shimCreateAnswer: () => (/* binding */ shimCreateAnswer),\n/* harmony export */   shimCreateOffer: () => (/* binding */ shimCreateOffer),\n/* harmony export */   shimGetDisplayMedia: () => (/* reexport safe */ _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__.shimGetDisplayMedia),\n/* harmony export */   shimGetParameters: () => (/* binding */ shimGetParameters),\n/* harmony export */   shimGetUserMedia: () => (/* reexport safe */ _getusermedia__WEBPACK_IMPORTED_MODULE_1__.shimGetUserMedia),\n/* harmony export */   shimOnTrack: () => (/* binding */ shimOnTrack),\n/* harmony export */   shimPeerConnection: () => (/* binding */ shimPeerConnection),\n/* harmony export */   shimRTCDataChannel: () => (/* binding */ shimRTCDataChannel),\n/* harmony export */   shimReceiverGetStats: () => (/* binding */ shimReceiverGetStats),\n/* harmony export */   shimRemoveStream: () => (/* binding */ shimRemoveStream),\n/* harmony export */   shimSenderGetStats: () => (/* binding */ shimSenderGetStats)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"(app-pages-browser)/./node_modules/webrtc-adapter/src/js/utils.js\");\n/* harmony import */ var _getusermedia__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getusermedia */ \"(app-pages-browser)/./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js\");\n/* harmony import */ var _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getdisplaymedia */ \"(app-pages-browser)/./node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\n\n\n\nfunction shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCTrackEvent &&\n      ('receiver' in window.RTCTrackEvent.prototype) &&\n      !('transceiver' in window.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n      get() {\n        return {receiver: this.receiver};\n      }\n    });\n  }\n}\n\nfunction shimPeerConnection(window, browserDetails) {\n  if (typeof window !== 'object' ||\n      !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {\n    return; // probably media.peerconnection.enabled=false in about:config\n  }\n  if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.mozRTCPeerConnection;\n  }\n\n  if (browserDetails.version < 53) {\n    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n      .forEach(function(method) {\n        const nativeMethod = window.RTCPeerConnection.prototype[method];\n        const methodObj = {[method]() {\n          arguments[0] = new ((method === 'addIceCandidate') ?\n            window.RTCIceCandidate :\n            window.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        }};\n        window.RTCPeerConnection.prototype[method] = methodObj[method];\n      });\n  }\n\n  const modernStatsTypes = {\n    inboundrtp: 'inbound-rtp',\n    outboundrtp: 'outbound-rtp',\n    candidatepair: 'candidate-pair',\n    localcandidate: 'local-candidate',\n    remotecandidate: 'remote-candidate'\n  };\n\n  const nativeGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments;\n    return nativeGetStats.apply(this, [selector || null])\n      .then(stats => {\n        if (browserDetails.version < 53 && !onSucc) {\n          // Shim only promise getStats with spec-hyphens in type names\n          // Leave callback version alone; misc old uses of forEach before Map\n          try {\n            stats.forEach(stat => {\n              stat.type = modernStatsTypes[stat.type] || stat.type;\n            });\n          } catch (e) {\n            if (e.name !== 'TypeError') {\n              throw e;\n            }\n            // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n            stats.forEach((stat, i) => {\n              stats.set(i, Object.assign({}, stat, {\n                type: modernStatsTypes[stat.type] || stat.type\n              }));\n            });\n          }\n        }\n        return stats;\n      })\n      .then(onSucc, onErr);\n  };\n}\n\nfunction shimSenderGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection &&\n      window.RTCRtpSender)) {\n    return;\n  }\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {\n    return;\n  }\n  const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n  if (origGetSenders) {\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n  }\n\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  if (origAddTrack) {\n    window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n      const sender = origAddTrack.apply(this, arguments);\n      sender._pc = this;\n      return sender;\n    };\n  }\n  window.RTCRtpSender.prototype.getStats = function getStats() {\n    return this.track ? this._pc.getStats(this.track) :\n      Promise.resolve(new Map());\n  };\n}\n\nfunction shimReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection &&\n      window.RTCRtpSender)) {\n    return;\n  }\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {\n    return;\n  }\n  const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n  if (origGetReceivers) {\n    window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n      const receivers = origGetReceivers.apply(this, []);\n      receivers.forEach(receiver => receiver._pc = this);\n      return receivers;\n    };\n  }\n  _utils__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'track', e => {\n    e.receiver._pc = e.srcElement;\n    return e;\n  });\n  window.RTCRtpReceiver.prototype.getStats = function getStats() {\n    return this._pc.getStats(this.track);\n  };\n}\n\nfunction shimRemoveStream(window) {\n  if (!window.RTCPeerConnection ||\n      'removeStream' in window.RTCPeerConnection.prototype) {\n    return;\n  }\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      _utils__WEBPACK_IMPORTED_MODULE_0__.deprecated('removeStream', 'removeTrack');\n      this.getSenders().forEach(sender => {\n        if (sender.track && stream.getTracks().includes(sender.track)) {\n          this.removeTrack(sender);\n        }\n      });\n    };\n}\n\nfunction shimRTCDataChannel(window) {\n  // rename DataChannel to RTCDataChannel (native fix in FF60):\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\n  if (window.DataChannel && !window.RTCDataChannel) {\n    window.RTCDataChannel = window.DataChannel;\n  }\n}\n\nfunction shimAddTransceiver(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n  const origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;\n  if (origAddTransceiver) {\n    window.RTCPeerConnection.prototype.addTransceiver =\n      function addTransceiver() {\n        this.setParametersPromises = [];\n        // WebIDL input coercion and validation\n        let sendEncodings = arguments[1] && arguments[1].sendEncodings;\n        if (sendEncodings === undefined) {\n          sendEncodings = [];\n        }\n        sendEncodings = [...sendEncodings];\n        const shouldPerformCheck = sendEncodings.length > 0;\n        if (shouldPerformCheck) {\n          // If sendEncodings params are provided, validate grammar\n          sendEncodings.forEach((encodingParam) => {\n            if ('rid' in encodingParam) {\n              const ridRegex = /^[a-z0-9]{0,16}$/i;\n              if (!ridRegex.test(encodingParam.rid)) {\n                throw new TypeError('Invalid RID value provided.');\n              }\n            }\n            if ('scaleResolutionDownBy' in encodingParam) {\n              if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {\n                throw new RangeError('scale_resolution_down_by must be >= 1.0');\n              }\n            }\n            if ('maxFramerate' in encodingParam) {\n              if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {\n                throw new RangeError('max_framerate must be >= 0.0');\n              }\n            }\n          });\n        }\n        const transceiver = origAddTransceiver.apply(this, arguments);\n        if (shouldPerformCheck) {\n          // Check if the init options were applied. If not we do this in an\n          // asynchronous way and save the promise reference in a global object.\n          // This is an ugly hack, but at the same time is way more robust than\n          // checking the sender parameters before and after the createOffer\n          // Also note that after the createoffer we are not 100% sure that\n          // the params were asynchronously applied so we might miss the\n          // opportunity to recreate offer.\n          const {sender} = transceiver;\n          const params = sender.getParameters();\n          if (!('encodings' in params) ||\n              // Avoid being fooled by patched getParameters() below.\n              (params.encodings.length === 1 &&\n               Object.keys(params.encodings[0]).length === 0)) {\n            params.encodings = sendEncodings;\n            sender.sendEncodings = sendEncodings;\n            this.setParametersPromises.push(sender.setParameters(params)\n              .then(() => {\n                delete sender.sendEncodings;\n              }).catch(() => {\n                delete sender.sendEncodings;\n              })\n            );\n          }\n        }\n        return transceiver;\n      };\n  }\n}\n\nfunction shimGetParameters(window) {\n  if (!(typeof window === 'object' && window.RTCRtpSender)) {\n    return;\n  }\n  const origGetParameters = window.RTCRtpSender.prototype.getParameters;\n  if (origGetParameters) {\n    window.RTCRtpSender.prototype.getParameters =\n      function getParameters() {\n        const params = origGetParameters.apply(this, arguments);\n        if (!('encodings' in params)) {\n          params.encodings = [].concat(this.sendEncodings || [{}]);\n        }\n        return params;\n      };\n  }\n}\n\nfunction shimCreateOffer(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n  window.RTCPeerConnection.prototype.createOffer = function createOffer() {\n    if (this.setParametersPromises && this.setParametersPromises.length) {\n      return Promise.all(this.setParametersPromises)\n        .then(() => {\n          return origCreateOffer.apply(this, arguments);\n        })\n        .finally(() => {\n          this.setParametersPromises = [];\n        });\n    }\n    return origCreateOffer.apply(this, arguments);\n  };\n}\n\nfunction shimCreateAnswer(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n  const origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;\n  window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {\n    if (this.setParametersPromises && this.setParametersPromises.length) {\n      return Promise.all(this.setParametersPromises)\n        .then(() => {\n          return origCreateAnswer.apply(this, arguments);\n        })\n        .finally(() => {\n          this.setParametersPromises = [];\n        });\n    }\n    return origCreateAnswer.apply(this, arguments);\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvZmlyZWZveC9maXJlZm94X3NoaW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUVxQjtBQUNjO0FBQ007O0FBRS9DO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMkRBQTZCO0FBQy9CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDhDQUFnQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9maXJlZm94L2ZpcmVmb3hfc2hpbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscyc7XG5leHBvcnQge3NoaW1HZXRVc2VyTWVkaWF9IGZyb20gJy4vZ2V0dXNlcm1lZGlhJztcbmV4cG9ydCB7c2hpbUdldERpc3BsYXlNZWRpYX0gZnJvbSAnLi9nZXRkaXNwbGF5bWVkaWEnO1xuXG5leHBvcnQgZnVuY3Rpb24gc2hpbU9uVHJhY2sod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDVHJhY2tFdmVudCAmJlxuICAgICAgKCdyZWNlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlKSAmJlxuICAgICAgISgndHJhbnNjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlLCAndHJhbnNjZWl2ZXInLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB7cmVjZWl2ZXI6IHRoaXMucmVjZWl2ZXJ9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltUGVlckNvbm5lY3Rpb24od2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8IHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICByZXR1cm47IC8vIHByb2JhYmx5IG1lZGlhLnBlZXJjb25uZWN0aW9uLmVuYWJsZWQ9ZmFsc2UgaW4gYWJvdXQ6Y29uZmlnXG4gIH1cbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgLy8gdmVyeSBiYXNpYyBzdXBwb3J0IGZvciBvbGQgdmVyc2lvbnMuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uO1xuICB9XG5cbiAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1Mykge1xuICAgIC8vIHNoaW0gYXdheSBuZWVkIGZvciBvYnNvbGV0ZSBSVENJY2VDYW5kaWRhdGUvUlRDU2Vzc2lvbkRlc2NyaXB0aW9uLlxuICAgIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbicsICdhZGRJY2VDYW5kaWRhdGUnXVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZU1ldGhvZCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICAgICAgY29uc3QgbWV0aG9kT2JqID0ge1ttZXRob2RdKCkge1xuICAgICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyAoKG1ldGhvZCA9PT0gJ2FkZEljZUNhbmRpZGF0ZScpID9cbiAgICAgICAgICAgIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgOlxuICAgICAgICAgICAgd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbikoYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH19O1xuICAgICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBtZXRob2RPYmpbbWV0aG9kXTtcbiAgICAgIH0pO1xuICB9XG5cbiAgY29uc3QgbW9kZXJuU3RhdHNUeXBlcyA9IHtcbiAgICBpbmJvdW5kcnRwOiAnaW5ib3VuZC1ydHAnLFxuICAgIG91dGJvdW5kcnRwOiAnb3V0Ym91bmQtcnRwJyxcbiAgICBjYW5kaWRhdGVwYWlyOiAnY2FuZGlkYXRlLXBhaXInLFxuICAgIGxvY2FsY2FuZGlkYXRlOiAnbG9jYWwtY2FuZGlkYXRlJyxcbiAgICByZW1vdGVjYW5kaWRhdGU6ICdyZW1vdGUtY2FuZGlkYXRlJ1xuICB9O1xuXG4gIGNvbnN0IG5hdGl2ZUdldFN0YXRzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIGNvbnN0IFtzZWxlY3Rvciwgb25TdWNjLCBvbkVycl0gPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5hdGl2ZUdldFN0YXRzLmFwcGx5KHRoaXMsIFtzZWxlY3RvciB8fCBudWxsXSlcbiAgICAgIC50aGVuKHN0YXRzID0+IHtcbiAgICAgICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1MyAmJiAhb25TdWNjKSB7XG4gICAgICAgICAgLy8gU2hpbSBvbmx5IHByb21pc2UgZ2V0U3RhdHMgd2l0aCBzcGVjLWh5cGhlbnMgaW4gdHlwZSBuYW1lc1xuICAgICAgICAgIC8vIExlYXZlIGNhbGxiYWNrIHZlcnNpb24gYWxvbmU7IG1pc2Mgb2xkIHVzZXMgb2YgZm9yRWFjaCBiZWZvcmUgTWFwXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0YXRzLmZvckVhY2goc3RhdCA9PiB7XG4gICAgICAgICAgICAgIHN0YXQudHlwZSA9IG1vZGVyblN0YXRzVHlwZXNbc3RhdC50eXBlXSB8fCBzdGF0LnR5cGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5uYW1lICE9PSAnVHlwZUVycm9yJykge1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXZvaWQgVHlwZUVycm9yOiBcInR5cGVcIiBpcyByZWFkLW9ubHksIGluIG9sZCB2ZXJzaW9ucy4gMzQtNDNpc2hcbiAgICAgICAgICAgIHN0YXRzLmZvckVhY2goKHN0YXQsIGkpID0+IHtcbiAgICAgICAgICAgICAgc3RhdHMuc2V0KGksIE9iamVjdC5hc3NpZ24oe30sIHN0YXQsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBtb2Rlcm5TdGF0c1R5cGVzW3N0YXQudHlwZV0gfHwgc3RhdC50eXBlXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdHM7XG4gICAgICB9KVxuICAgICAgLnRoZW4ob25TdWNjLCBvbkVycik7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltU2VuZGVyR2V0U3RhdHMod2luZG93KSB7XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJlxuICAgICAgd2luZG93LlJUQ1J0cFNlbmRlcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHdpbmRvdy5SVENSdHBTZW5kZXIgJiYgJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcbiAgaWYgKG9yaWdHZXRTZW5kZXJzKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzID0gZnVuY3Rpb24gZ2V0U2VuZGVycygpIHtcbiAgICAgIGNvbnN0IHNlbmRlcnMgPSBvcmlnR2V0U2VuZGVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICBzZW5kZXJzLmZvckVhY2goc2VuZGVyID0+IHNlbmRlci5fcGMgPSB0aGlzKTtcbiAgICAgIHJldHVybiBzZW5kZXJzO1xuICAgIH07XG4gIH1cblxuICBjb25zdCBvcmlnQWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICBpZiAob3JpZ0FkZFRyYWNrKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKCkge1xuICAgICAgY29uc3Qgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBzZW5kZXIuX3BjID0gdGhpcztcbiAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgfTtcbiAgfVxuICB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrID8gdGhpcy5fcGMuZ2V0U3RhdHModGhpcy50cmFjaykgOlxuICAgICAgUHJvbWlzZS5yZXNvbHZlKG5ldyBNYXAoKSk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltUmVjZWl2ZXJHZXRTdGF0cyh3aW5kb3cpIHtcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmXG4gICAgICB3aW5kb3cuUlRDUnRwU2VuZGVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAod2luZG93LlJUQ1J0cFNlbmRlciAmJiAnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0dldFJlY2VpdmVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzO1xuICBpZiAob3JpZ0dldFJlY2VpdmVycykge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzID0gZnVuY3Rpb24gZ2V0UmVjZWl2ZXJzKCkge1xuICAgICAgY29uc3QgcmVjZWl2ZXJzID0gb3JpZ0dldFJlY2VpdmVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICByZWNlaXZlcnMuZm9yRWFjaChyZWNlaXZlciA9PiByZWNlaXZlci5fcGMgPSB0aGlzKTtcbiAgICAgIHJldHVybiByZWNlaXZlcnM7XG4gICAgfTtcbiAgfVxuICB1dGlscy53cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICd0cmFjaycsIGUgPT4ge1xuICAgIGUucmVjZWl2ZXIuX3BjID0gZS5zcmNFbGVtZW50O1xuICAgIHJldHVybiBlO1xuICB9KTtcbiAgd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cyh0aGlzLnRyYWNrKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1SZW1vdmVTdHJlYW0od2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8XG4gICAgICAncmVtb3ZlU3RyZWFtJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID1cbiAgICBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICB1dGlscy5kZXByZWNhdGVkKCdyZW1vdmVTdHJlYW0nLCAncmVtb3ZlVHJhY2snKTtcbiAgICAgIHRoaXMuZ2V0U2VuZGVycygpLmZvckVhY2goc2VuZGVyID0+IHtcbiAgICAgICAgaWYgKHNlbmRlci50cmFjayAmJiBzdHJlYW0uZ2V0VHJhY2tzKCkuaW5jbHVkZXMoc2VuZGVyLnRyYWNrKSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1SVENEYXRhQ2hhbm5lbCh3aW5kb3cpIHtcbiAgLy8gcmVuYW1lIERhdGFDaGFubmVsIHRvIFJUQ0RhdGFDaGFubmVsIChuYXRpdmUgZml4IGluIEZGNjApOlxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTczODUxXG4gIGlmICh3aW5kb3cuRGF0YUNoYW5uZWwgJiYgIXdpbmRvdy5SVENEYXRhQ2hhbm5lbCkge1xuICAgIHdpbmRvdy5SVENEYXRhQ2hhbm5lbCA9IHdpbmRvdy5EYXRhQ2hhbm5lbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUFkZFRyYW5zY2VpdmVyKHdpbmRvdykge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicnRjSGFja3MvYWRhcHRlci9pc3N1ZXMvOTk4I2lzc3VlY29tbWVudC01MTY5MjE2NDdcbiAgLy8gRmlyZWZveCBpZ25vcmVzIHRoZSBpbml0IHNlbmRFbmNvZGluZ3Mgb3B0aW9ucyBwYXNzZWQgdG8gYWRkVHJhbnNjZWl2ZXJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM5NjkxOFxuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdBZGRUcmFuc2NlaXZlciA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhbnNjZWl2ZXI7XG4gIGlmIChvcmlnQWRkVHJhbnNjZWl2ZXIpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYW5zY2VpdmVyID1cbiAgICAgIGZ1bmN0aW9uIGFkZFRyYW5zY2VpdmVyKCkge1xuICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyA9IFtdO1xuICAgICAgICAvLyBXZWJJREwgaW5wdXQgY29lcmNpb24gYW5kIHZhbGlkYXRpb25cbiAgICAgICAgbGV0IHNlbmRFbmNvZGluZ3MgPSBhcmd1bWVudHNbMV0gJiYgYXJndW1lbnRzWzFdLnNlbmRFbmNvZGluZ3M7XG4gICAgICAgIGlmIChzZW5kRW5jb2RpbmdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZW5kRW5jb2RpbmdzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgc2VuZEVuY29kaW5ncyA9IFsuLi5zZW5kRW5jb2RpbmdzXTtcbiAgICAgICAgY29uc3Qgc2hvdWxkUGVyZm9ybUNoZWNrID0gc2VuZEVuY29kaW5ncy5sZW5ndGggPiAwO1xuICAgICAgICBpZiAoc2hvdWxkUGVyZm9ybUNoZWNrKSB7XG4gICAgICAgICAgLy8gSWYgc2VuZEVuY29kaW5ncyBwYXJhbXMgYXJlIHByb3ZpZGVkLCB2YWxpZGF0ZSBncmFtbWFyXG4gICAgICAgICAgc2VuZEVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZ1BhcmFtKSA9PiB7XG4gICAgICAgICAgICBpZiAoJ3JpZCcgaW4gZW5jb2RpbmdQYXJhbSkge1xuICAgICAgICAgICAgICBjb25zdCByaWRSZWdleCA9IC9eW2EtejAtOV17MCwxNn0kL2k7XG4gICAgICAgICAgICAgIGlmICghcmlkUmVnZXgudGVzdChlbmNvZGluZ1BhcmFtLnJpZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFJJRCB2YWx1ZSBwcm92aWRlZC4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdzY2FsZVJlc29sdXRpb25Eb3duQnknIGluIGVuY29kaW5nUGFyYW0pIHtcbiAgICAgICAgICAgICAgaWYgKCEocGFyc2VGbG9hdChlbmNvZGluZ1BhcmFtLnNjYWxlUmVzb2x1dGlvbkRvd25CeSkgPj0gMS4wKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzY2FsZV9yZXNvbHV0aW9uX2Rvd25fYnkgbXVzdCBiZSA+PSAxLjAnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdtYXhGcmFtZXJhdGUnIGluIGVuY29kaW5nUGFyYW0pIHtcbiAgICAgICAgICAgICAgaWYgKCEocGFyc2VGbG9hdChlbmNvZGluZ1BhcmFtLm1heEZyYW1lcmF0ZSkgPj0gMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbWF4X2ZyYW1lcmF0ZSBtdXN0IGJlID49IDAuMCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSBvcmlnQWRkVHJhbnNjZWl2ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHNob3VsZFBlcmZvcm1DaGVjaykge1xuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBpbml0IG9wdGlvbnMgd2VyZSBhcHBsaWVkLiBJZiBub3Qgd2UgZG8gdGhpcyBpbiBhblxuICAgICAgICAgIC8vIGFzeW5jaHJvbm91cyB3YXkgYW5kIHNhdmUgdGhlIHByb21pc2UgcmVmZXJlbmNlIGluIGEgZ2xvYmFsIG9iamVjdC5cbiAgICAgICAgICAvLyBUaGlzIGlzIGFuIHVnbHkgaGFjaywgYnV0IGF0IHRoZSBzYW1lIHRpbWUgaXMgd2F5IG1vcmUgcm9idXN0IHRoYW5cbiAgICAgICAgICAvLyBjaGVja2luZyB0aGUgc2VuZGVyIHBhcmFtZXRlcnMgYmVmb3JlIGFuZCBhZnRlciB0aGUgY3JlYXRlT2ZmZXJcbiAgICAgICAgICAvLyBBbHNvIG5vdGUgdGhhdCBhZnRlciB0aGUgY3JlYXRlb2ZmZXIgd2UgYXJlIG5vdCAxMDAlIHN1cmUgdGhhdFxuICAgICAgICAgIC8vIHRoZSBwYXJhbXMgd2VyZSBhc3luY2hyb25vdXNseSBhcHBsaWVkIHNvIHdlIG1pZ2h0IG1pc3MgdGhlXG4gICAgICAgICAgLy8gb3Bwb3J0dW5pdHkgdG8gcmVjcmVhdGUgb2ZmZXIuXG4gICAgICAgICAgY29uc3Qge3NlbmRlcn0gPSB0cmFuc2NlaXZlcjtcbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSBzZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICAgIGlmICghKCdlbmNvZGluZ3MnIGluIHBhcmFtcykgfHxcbiAgICAgICAgICAgICAgLy8gQXZvaWQgYmVpbmcgZm9vbGVkIGJ5IHBhdGNoZWQgZ2V0UGFyYW1ldGVycygpIGJlbG93LlxuICAgICAgICAgICAgICAocGFyYW1zLmVuY29kaW5ncy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcy5lbmNvZGluZ3NbMF0pLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHBhcmFtcy5lbmNvZGluZ3MgPSBzZW5kRW5jb2RpbmdzO1xuICAgICAgICAgICAgc2VuZGVyLnNlbmRFbmNvZGluZ3MgPSBzZW5kRW5jb2RpbmdzO1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMucHVzaChzZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbXMpXG4gICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2VuZGVyLnNlbmRFbmNvZGluZ3M7XG4gICAgICAgICAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2VuZGVyLnNlbmRFbmNvZGluZ3M7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXI7XG4gICAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltR2V0UGFyYW1ldGVycyh3aW5kb3cpIHtcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1J0cFNlbmRlcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0dldFBhcmFtZXRlcnMgPSB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRQYXJhbWV0ZXJzO1xuICBpZiAob3JpZ0dldFBhcmFtZXRlcnMpIHtcbiAgICB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRQYXJhbWV0ZXJzID1cbiAgICAgIGZ1bmN0aW9uIGdldFBhcmFtZXRlcnMoKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG9yaWdHZXRQYXJhbWV0ZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICghKCdlbmNvZGluZ3MnIGluIHBhcmFtcykpIHtcbiAgICAgICAgICBwYXJhbXMuZW5jb2RpbmdzID0gW10uY29uY2F0KHRoaXMuc2VuZEVuY29kaW5ncyB8fCBbe31dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUNyZWF0ZU9mZmVyKHdpbmRvdykge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicnRjSGFja3MvYWRhcHRlci9pc3N1ZXMvOTk4I2lzc3VlY29tbWVudC01MTY5MjE2NDdcbiAgLy8gRmlyZWZveCBpZ25vcmVzIHRoZSBpbml0IHNlbmRFbmNvZGluZ3Mgb3B0aW9ucyBwYXNzZWQgdG8gYWRkVHJhbnNjZWl2ZXJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM5NjkxOFxuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdDcmVhdGVPZmZlciA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXI7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbiBjcmVhdGVPZmZlcigpIHtcbiAgICBpZiAodGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgJiYgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyA9IFtdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdDcmVhdGVPZmZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUNyZWF0ZUFuc3dlcih3aW5kb3cpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Y0hhY2tzL2FkYXB0ZXIvaXNzdWVzLzk5OCNpc3N1ZWNvbW1lbnQtNTE2OTIxNjQ3XG4gIC8vIEZpcmVmb3ggaWdub3JlcyB0aGUgaW5pdCBzZW5kRW5jb2RpbmdzIG9wdGlvbnMgcGFzc2VkIHRvIGFkZFRyYW5zY2VpdmVyXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzOTY5MThcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnQ3JlYXRlQW5zd2VyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVBbnN3ZXI7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQW5zd2VyID0gZnVuY3Rpb24gY3JlYXRlQW5zd2VyKCkge1xuICAgIGlmICh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyAmJiB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcylcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBvcmlnQ3JlYXRlQW5zd2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyA9IFtdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdDcmVhdGVBbnN3ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js":
/*!***********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shimGetDisplayMedia: () => (/* binding */ shimGetDisplayMedia)\n/* harmony export */ });\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\nfunction shimGetDisplayMedia(window, preferredMediaSource) {\n  if (window.navigator.mediaDevices &&\n    'getDisplayMedia' in window.navigator.mediaDevices) {\n    return;\n  }\n  if (!(window.navigator.mediaDevices)) {\n    return;\n  }\n  window.navigator.mediaDevices.getDisplayMedia =\n    function getDisplayMedia(constraints) {\n      if (!(constraints && constraints.video)) {\n        const err = new DOMException('getDisplayMedia without video ' +\n            'constraints is undefined');\n        err.name = 'NotFoundError';\n        // from https://heycam.github.io/webidl/#idl-DOMException-error-names\n        err.code = 8;\n        return Promise.reject(err);\n      }\n      if (constraints.video === true) {\n        constraints.video = {mediaSource: preferredMediaSource};\n      } else {\n        constraints.video.mediaSource = preferredMediaSource;\n      }\n      return window.navigator.mediaDevices.getUserMedia(constraints);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvZmlyZWZveC9nZXRkaXNwbGF5bWVkaWEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFTjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL2ZpcmVmb3gvZ2V0ZGlzcGxheW1lZGlhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBhZGFwdGVyLmpzIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUdldERpc3BsYXlNZWRpYSh3aW5kb3csIHByZWZlcnJlZE1lZGlhU291cmNlKSB7XG4gIGlmICh3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJlxuICAgICdnZXREaXNwbGF5TWVkaWEnIGluIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPVxuICAgIGZ1bmN0aW9uIGdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cykge1xuICAgICAgaWYgKCEoY29uc3RyYWludHMgJiYgY29uc3RyYWludHMudmlkZW8pKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBET01FeGNlcHRpb24oJ2dldERpc3BsYXlNZWRpYSB3aXRob3V0IHZpZGVvICcgK1xuICAgICAgICAgICAgJ2NvbnN0cmFpbnRzIGlzIHVuZGVmaW5lZCcpO1xuICAgICAgICBlcnIubmFtZSA9ICdOb3RGb3VuZEVycm9yJztcbiAgICAgICAgLy8gZnJvbSBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtRE9NRXhjZXB0aW9uLWVycm9yLW5hbWVzXG4gICAgICAgIGVyci5jb2RlID0gODtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICBpZiAoY29uc3RyYWludHMudmlkZW8gPT09IHRydWUpIHtcbiAgICAgICAgY29uc3RyYWludHMudmlkZW8gPSB7bWVkaWFTb3VyY2U6IHByZWZlcnJlZE1lZGlhU291cmNlfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvLm1lZGlhU291cmNlID0gcHJlZmVycmVkTWVkaWFTb3VyY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js":
/*!********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shimGetUserMedia: () => (/* binding */ shimGetUserMedia)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"(app-pages-browser)/./node_modules/webrtc-adapter/src/js/utils.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\n\nfunction shimGetUserMedia(window, browserDetails) {\n  const navigator = window && window.navigator;\n  const MediaStreamTrack = window && window.MediaStreamTrack;\n\n  navigator.getUserMedia = function(constraints, onSuccess, onError) {\n    // Replace Firefox 44+'s deprecation warning with unprefixed version.\n    _utils__WEBPACK_IMPORTED_MODULE_0__.deprecated('navigator.getUserMedia',\n      'navigator.mediaDevices.getUserMedia');\n    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n  };\n\n  if (!(browserDetails.version > 55 &&\n      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {\n    const remap = function(obj, a, b) {\n      if (a in obj && !(b in obj)) {\n        obj[b] = obj[a];\n        delete obj[a];\n      }\n    };\n\n    const nativeGetUserMedia = navigator.mediaDevices.getUserMedia.\n      bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(c) {\n      if (typeof c === 'object' && typeof c.audio === 'object') {\n        c = JSON.parse(JSON.stringify(c));\n        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\n        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\n      }\n      return nativeGetUserMedia(c);\n    };\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {\n      const nativeGetSettings = MediaStreamTrack.prototype.getSettings;\n      MediaStreamTrack.prototype.getSettings = function() {\n        const obj = nativeGetSettings.apply(this, arguments);\n        remap(obj, 'mozAutoGainControl', 'autoGainControl');\n        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\n        return obj;\n      };\n    }\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {\n      const nativeApplyConstraints =\n        MediaStreamTrack.prototype.applyConstraints;\n      MediaStreamTrack.prototype.applyConstraints = function(c) {\n        if (this.kind === 'audio' && typeof c === 'object') {\n          c = JSON.parse(JSON.stringify(c));\n          remap(c, 'autoGainControl', 'mozAutoGainControl');\n          remap(c, 'noiseSuppression', 'mozNoiseSuppression');\n        }\n        return nativeApplyConstraints.apply(this, [c]);\n      };\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvZmlyZWZveC9nZXR1c2VybWVkaWEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRXFCOztBQUUzQjtBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksOENBQWdCO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvZmlyZWZveC9nZXR1c2VybWVkaWEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUdldFVzZXJNZWRpYSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yO1xuICBjb25zdCBNZWRpYVN0cmVhbVRyYWNrID0gd2luZG93ICYmIHdpbmRvdy5NZWRpYVN0cmVhbVRyYWNrO1xuXG4gIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbihjb25zdHJhaW50cywgb25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgLy8gUmVwbGFjZSBGaXJlZm94IDQ0KydzIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2l0aCB1bnByZWZpeGVkIHZlcnNpb24uXG4gICAgdXRpbHMuZGVwcmVjYXRlZCgnbmF2aWdhdG9yLmdldFVzZXJNZWRpYScsXG4gICAgICAnbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEnKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cykudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICB9O1xuXG4gIGlmICghKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPiA1NSAmJlxuICAgICAgJ2F1dG9HYWluQ29udHJvbCcgaW4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRTdXBwb3J0ZWRDb25zdHJhaW50cygpKSkge1xuICAgIGNvbnN0IHJlbWFwID0gZnVuY3Rpb24ob2JqLCBhLCBiKSB7XG4gICAgICBpZiAoYSBpbiBvYmogJiYgIShiIGluIG9iaikpIHtcbiAgICAgICAgb2JqW2JdID0gb2JqW2FdO1xuICAgICAgICBkZWxldGUgb2JqW2FdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBuYXRpdmVHZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5cbiAgICAgIGJpbmQobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbihjKSB7XG4gICAgICBpZiAodHlwZW9mIGMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjLmF1ZGlvID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjKSk7XG4gICAgICAgIHJlbWFwKGMuYXVkaW8sICdhdXRvR2FpbkNvbnRyb2wnLCAnbW96QXV0b0dhaW5Db250cm9sJyk7XG4gICAgICAgIHJlbWFwKGMuYXVkaW8sICdub2lzZVN1cHByZXNzaW9uJywgJ21vek5vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVHZXRVc2VyTWVkaWEoYyk7XG4gICAgfTtcblxuICAgIGlmIChNZWRpYVN0cmVhbVRyYWNrICYmIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmdldFNldHRpbmdzKSB7XG4gICAgICBjb25zdCBuYXRpdmVHZXRTZXR0aW5ncyA9IE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmdldFNldHRpbmdzO1xuICAgICAgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuZ2V0U2V0dGluZ3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gbmF0aXZlR2V0U2V0dGluZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmVtYXAob2JqLCAnbW96QXV0b0dhaW5Db250cm9sJywgJ2F1dG9HYWluQ29udHJvbCcpO1xuICAgICAgICByZW1hcChvYmosICdtb3pOb2lzZVN1cHByZXNzaW9uJywgJ25vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKE1lZGlhU3RyZWFtVHJhY2sgJiYgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuYXBwbHlDb25zdHJhaW50cykge1xuICAgICAgY29uc3QgbmF0aXZlQXBwbHlDb25zdHJhaW50cyA9XG4gICAgICAgIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmFwcGx5Q29uc3RyYWludHM7XG4gICAgICBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5hcHBseUNvbnN0cmFpbnRzID0gZnVuY3Rpb24oYykge1xuICAgICAgICBpZiAodGhpcy5raW5kID09PSAnYXVkaW8nICYmIHR5cGVvZiBjID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGMpKTtcbiAgICAgICAgICByZW1hcChjLCAnYXV0b0dhaW5Db250cm9sJywgJ21vekF1dG9HYWluQ29udHJvbCcpO1xuICAgICAgICAgIHJlbWFwKGMsICdub2lzZVN1cHByZXNzaW9uJywgJ21vek5vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmF0aXZlQXBwbHlDb25zdHJhaW50cy5hcHBseSh0aGlzLCBbY10pO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/webrtc-adapter/src/js/safari/safari_shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/safari/safari_shim.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shimAudioContext: () => (/* binding */ shimAudioContext),\n/* harmony export */   shimCallbacksAPI: () => (/* binding */ shimCallbacksAPI),\n/* harmony export */   shimConstraints: () => (/* binding */ shimConstraints),\n/* harmony export */   shimCreateOfferLegacy: () => (/* binding */ shimCreateOfferLegacy),\n/* harmony export */   shimGetUserMedia: () => (/* binding */ shimGetUserMedia),\n/* harmony export */   shimLocalStreamsAPI: () => (/* binding */ shimLocalStreamsAPI),\n/* harmony export */   shimRTCIceServerUrls: () => (/* binding */ shimRTCIceServerUrls),\n/* harmony export */   shimRemoteStreamsAPI: () => (/* binding */ shimRemoteStreamsAPI),\n/* harmony export */   shimTrackEventTransceiver: () => (/* binding */ shimTrackEventTransceiver)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"(app-pages-browser)/./node_modules/webrtc-adapter/src/js/utils.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n\n\nfunction shimLocalStreamsAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.getLocalStreams =\n      function getLocalStreams() {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        return this._localStreams;\n      };\n  }\n  if (!('addStream' in window.RTCPeerConnection.prototype)) {\n    const _addTrack = window.RTCPeerConnection.prototype.addTrack;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      if (!this._localStreams.includes(stream)) {\n        this._localStreams.push(stream);\n      }\n      // Try to emulate Chrome's behaviour of adding in audio-video order.\n      // Safari orders by track id.\n      stream.getAudioTracks().forEach(track => _addTrack.call(this, track,\n        stream));\n      stream.getVideoTracks().forEach(track => _addTrack.call(this, track,\n        stream));\n    };\n\n    window.RTCPeerConnection.prototype.addTrack =\n      function addTrack(track, ...streams) {\n        if (streams) {\n          streams.forEach((stream) => {\n            if (!this._localStreams) {\n              this._localStreams = [stream];\n            } else if (!this._localStreams.includes(stream)) {\n              this._localStreams.push(stream);\n            }\n          });\n        }\n        return _addTrack.apply(this, arguments);\n      };\n  }\n  if (!('removeStream' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.removeStream =\n      function removeStream(stream) {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        const index = this._localStreams.indexOf(stream);\n        if (index === -1) {\n          return;\n        }\n        this._localStreams.splice(index, 1);\n        const tracks = stream.getTracks();\n        this.getSenders().forEach(sender => {\n          if (tracks.includes(sender.track)) {\n            this.removeTrack(sender);\n          }\n        });\n      };\n  }\n}\n\nfunction shimRemoteStreamsAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.getRemoteStreams =\n      function getRemoteStreams() {\n        return this._remoteStreams ? this._remoteStreams : [];\n      };\n  }\n  if (!('onaddstream' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {\n      get() {\n        return this._onaddstream;\n      },\n      set(f) {\n        if (this._onaddstream) {\n          this.removeEventListener('addstream', this._onaddstream);\n          this.removeEventListener('track', this._onaddstreampoly);\n        }\n        this.addEventListener('addstream', this._onaddstream = f);\n        this.addEventListener('track', this._onaddstreampoly = (e) => {\n          e.streams.forEach(stream => {\n            if (!this._remoteStreams) {\n              this._remoteStreams = [];\n            }\n            if (this._remoteStreams.includes(stream)) {\n              return;\n            }\n            this._remoteStreams.push(stream);\n            const event = new Event('addstream');\n            event.stream = stream;\n            this.dispatchEvent(event);\n          });\n        });\n      }\n    });\n    const origSetRemoteDescription =\n      window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription =\n      function setRemoteDescription() {\n        const pc = this;\n        if (!this._onaddstreampoly) {\n          this.addEventListener('track', this._onaddstreampoly = function(e) {\n            e.streams.forEach(stream => {\n              if (!pc._remoteStreams) {\n                pc._remoteStreams = [];\n              }\n              if (pc._remoteStreams.indexOf(stream) >= 0) {\n                return;\n              }\n              pc._remoteStreams.push(stream);\n              const event = new Event('addstream');\n              event.stream = stream;\n              pc.dispatchEvent(event);\n            });\n          });\n        }\n        return origSetRemoteDescription.apply(pc, arguments);\n      };\n  }\n}\n\nfunction shimCallbacksAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  const prototype = window.RTCPeerConnection.prototype;\n  const origCreateOffer = prototype.createOffer;\n  const origCreateAnswer = prototype.createAnswer;\n  const setLocalDescription = prototype.setLocalDescription;\n  const setRemoteDescription = prototype.setRemoteDescription;\n  const addIceCandidate = prototype.addIceCandidate;\n\n  prototype.createOffer =\n    function createOffer(successCallback, failureCallback) {\n      const options = (arguments.length >= 2) ? arguments[2] : arguments[0];\n      const promise = origCreateOffer.apply(this, [options]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n\n  prototype.createAnswer =\n    function createAnswer(successCallback, failureCallback) {\n      const options = (arguments.length >= 2) ? arguments[2] : arguments[0];\n      const promise = origCreateAnswer.apply(this, [options]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n\n  let withCallback = function(description, successCallback, failureCallback) {\n    const promise = setLocalDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setLocalDescription = withCallback;\n\n  withCallback = function(description, successCallback, failureCallback) {\n    const promise = setRemoteDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setRemoteDescription = withCallback;\n\n  withCallback = function(candidate, successCallback, failureCallback) {\n    const promise = addIceCandidate.apply(this, [candidate]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.addIceCandidate = withCallback;\n}\n\nfunction shimGetUserMedia(window) {\n  const navigator = window && window.navigator;\n\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    // shim not needed in Safari 12.1\n    const mediaDevices = navigator.mediaDevices;\n    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\n    navigator.mediaDevices.getUserMedia = (constraints) => {\n      return _getUserMedia(shimConstraints(constraints));\n    };\n  }\n\n  if (!navigator.getUserMedia && navigator.mediaDevices &&\n    navigator.mediaDevices.getUserMedia) {\n    navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {\n      navigator.mediaDevices.getUserMedia(constraints)\n        .then(cb, errcb);\n    }.bind(navigator);\n  }\n}\n\nfunction shimConstraints(constraints) {\n  if (constraints && constraints.video !== undefined) {\n    return Object.assign({},\n      constraints,\n      {video: _utils__WEBPACK_IMPORTED_MODULE_0__.compactObject(constraints.video)}\n    );\n  }\n\n  return constraints;\n}\n\nfunction shimRTCIceServerUrls(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n  const OrigPeerConnection = window.RTCPeerConnection;\n  window.RTCPeerConnection =\n    function RTCPeerConnection(pcConfig, pcConstraints) {\n      if (pcConfig && pcConfig.iceServers) {\n        const newIceServers = [];\n        for (let i = 0; i < pcConfig.iceServers.length; i++) {\n          let server = pcConfig.iceServers[i];\n          if (server.urls === undefined && server.url) {\n            _utils__WEBPACK_IMPORTED_MODULE_0__.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n            server = JSON.parse(JSON.stringify(server));\n            server.urls = server.url;\n            delete server.url;\n            newIceServers.push(server);\n          } else {\n            newIceServers.push(pcConfig.iceServers[i]);\n          }\n        }\n        pcConfig.iceServers = newIceServers;\n      }\n      return new OrigPeerConnection(pcConfig, pcConstraints);\n    };\n  window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n  // wrap static methods. Currently just generateCertificate.\n  if ('generateCertificate' in OrigPeerConnection) {\n    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n      get() {\n        return OrigPeerConnection.generateCertificate;\n      }\n    });\n  }\n}\n\nfunction shimTrackEventTransceiver(window) {\n  // Add event.transceiver member over deprecated event.receiver\n  if (typeof window === 'object' && window.RTCTrackEvent &&\n      'receiver' in window.RTCTrackEvent.prototype &&\n      !('transceiver' in window.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n      get() {\n        return {receiver: this.receiver};\n      }\n    });\n  }\n}\n\nfunction shimCreateOfferLegacy(window) {\n  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n  window.RTCPeerConnection.prototype.createOffer =\n    function createOffer(offerOptions) {\n      if (offerOptions) {\n        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {\n          // support bit values\n          offerOptions.offerToReceiveAudio =\n            !!offerOptions.offerToReceiveAudio;\n        }\n        const audioTransceiver = this.getTransceivers().find(transceiver =>\n          transceiver.receiver.track.kind === 'audio');\n        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n          if (audioTransceiver.direction === 'sendrecv') {\n            if (audioTransceiver.setDirection) {\n              audioTransceiver.setDirection('sendonly');\n            } else {\n              audioTransceiver.direction = 'sendonly';\n            }\n          } else if (audioTransceiver.direction === 'recvonly') {\n            if (audioTransceiver.setDirection) {\n              audioTransceiver.setDirection('inactive');\n            } else {\n              audioTransceiver.direction = 'inactive';\n            }\n          }\n        } else if (offerOptions.offerToReceiveAudio === true &&\n            !audioTransceiver) {\n          this.addTransceiver('audio', {direction: 'recvonly'});\n        }\n\n        if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {\n          // support bit values\n          offerOptions.offerToReceiveVideo =\n            !!offerOptions.offerToReceiveVideo;\n        }\n        const videoTransceiver = this.getTransceivers().find(transceiver =>\n          transceiver.receiver.track.kind === 'video');\n        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n          if (videoTransceiver.direction === 'sendrecv') {\n            if (videoTransceiver.setDirection) {\n              videoTransceiver.setDirection('sendonly');\n            } else {\n              videoTransceiver.direction = 'sendonly';\n            }\n          } else if (videoTransceiver.direction === 'recvonly') {\n            if (videoTransceiver.setDirection) {\n              videoTransceiver.setDirection('inactive');\n            } else {\n              videoTransceiver.direction = 'inactive';\n            }\n          }\n        } else if (offerOptions.offerToReceiveVideo === true &&\n            !videoTransceiver) {\n          this.addTransceiver('video', {direction: 'recvonly'});\n        }\n      }\n      return origCreateOffer.apply(this, arguments);\n    };\n}\n\nfunction shimAudioContext(window) {\n  if (typeof window !== 'object' || window.AudioContext) {\n    return;\n  }\n  window.AudioContext = window.webkitAudioContext;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvc2FmYXJpL3NhZmFyaV9zaGltLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ3FCOztBQUUzQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxPQUFPLE9BQU8saURBQW1CO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBLFlBQVksOENBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx3Q0FBd0Msc0JBQXNCO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9zYWZhcmkvc2FmYXJpX3NoaW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltTG9jYWxTdHJlYW1zQVBJKHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISgnZ2V0TG9jYWxTdHJlYW1zJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zID1cbiAgICAgIGZ1bmN0aW9uIGdldExvY2FsU3RyZWFtcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxTdHJlYW1zO1xuICAgICAgfTtcbiAgfVxuICBpZiAoISgnYWRkU3RyZWFtJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIGNvbnN0IF9hZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XG4gICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xuICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zLmluY2x1ZGVzKHN0cmVhbSkpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgICAgIH1cbiAgICAgIC8vIFRyeSB0byBlbXVsYXRlIENocm9tZSdzIGJlaGF2aW91ciBvZiBhZGRpbmcgaW4gYXVkaW8tdmlkZW8gb3JkZXIuXG4gICAgICAvLyBTYWZhcmkgb3JkZXJzIGJ5IHRyYWNrIGlkLlxuICAgICAgc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiBfYWRkVHJhY2suY2FsbCh0aGlzLCB0cmFjayxcbiAgICAgICAgc3RyZWFtKSk7XG4gICAgICBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IF9hZGRUcmFjay5jYWxsKHRoaXMsIHRyYWNrLFxuICAgICAgICBzdHJlYW0pKTtcbiAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9XG4gICAgICBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaywgLi4uc3RyZWFtcykge1xuICAgICAgICBpZiAoc3RyZWFtcykge1xuICAgICAgICAgIHN0cmVhbXMuZm9yRWFjaCgoc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xuICAgICAgICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbc3RyZWFtXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcy5pbmNsdWRlcyhzdHJlYW0pKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9hZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgfVxuICBpZiAoISgncmVtb3ZlU3RyZWFtJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID1cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2xvY2FsU3RyZWFtcy5pbmRleE9mKHN0cmVhbSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IHN0cmVhbS5nZXRUcmFja3MoKTtcbiAgICAgICAgdGhpcy5nZXRTZW5kZXJzKCkuZm9yRWFjaChzZW5kZXIgPT4ge1xuICAgICAgICAgIGlmICh0cmFja3MuaW5jbHVkZXMoc2VuZGVyLnRyYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltUmVtb3RlU3RyZWFtc0FQSSh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8ICF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCEoJ2dldFJlbW90ZVN0cmVhbXMnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZW1vdGVTdHJlYW1zID1cbiAgICAgIGZ1bmN0aW9uIGdldFJlbW90ZVN0cmVhbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdGVTdHJlYW1zID8gdGhpcy5fcmVtb3RlU3RyZWFtcyA6IFtdO1xuICAgICAgfTtcbiAgfVxuICBpZiAoISgnb25hZGRzdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdvbmFkZHN0cmVhbScsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uYWRkc3RyZWFtO1xuICAgICAgfSxcbiAgICAgIHNldChmKSB7XG4gICAgICAgIGlmICh0aGlzLl9vbmFkZHN0cmVhbSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb25hZGRzdHJlYW0pO1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbmFkZHN0cmVhbXBvbHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb25hZGRzdHJlYW0gPSBmKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29uYWRkc3RyZWFtcG9seSA9IChlKSA9PiB7XG4gICAgICAgICAgZS5zdHJlYW1zLmZvckVhY2goc3RyZWFtID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVtb3RlU3RyZWFtcykge1xuICAgICAgICAgICAgICB0aGlzLl9yZW1vdGVTdHJlYW1zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVtb3RlU3RyZWFtcy5pbmNsdWRlcyhzdHJlYW0pKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZHN0cmVhbScpO1xuICAgICAgICAgICAgZXZlbnQuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID1cbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9XG4gICAgICBmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvbigpIHtcbiAgICAgICAgY29uc3QgcGMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuX29uYWRkc3RyZWFtcG9seSkge1xuICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbmFkZHN0cmVhbXBvbHkgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnN0cmVhbXMuZm9yRWFjaChzdHJlYW0gPT4ge1xuICAgICAgICAgICAgICBpZiAoIXBjLl9yZW1vdGVTdHJlYW1zKSB7XG4gICAgICAgICAgICAgICAgcGMuX3JlbW90ZVN0cmVhbXMgPSBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocGMuX3JlbW90ZVN0cmVhbXMuaW5kZXhPZihzdHJlYW0pID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGMuX3JlbW90ZVN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgnYWRkc3RyZWFtJyk7XG4gICAgICAgICAgICAgIGV2ZW50LnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgICAgcGMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHBjLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUNhbGxiYWNrc0FQSSh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8ICF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJvdG90eXBlID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgY29uc3Qgb3JpZ0NyZWF0ZU9mZmVyID0gcHJvdG90eXBlLmNyZWF0ZU9mZmVyO1xuICBjb25zdCBvcmlnQ3JlYXRlQW5zd2VyID0gcHJvdG90eXBlLmNyZWF0ZUFuc3dlcjtcbiAgY29uc3Qgc2V0TG9jYWxEZXNjcmlwdGlvbiA9IHByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uO1xuICBjb25zdCBzZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgY29uc3QgYWRkSWNlQ2FuZGlkYXRlID0gcHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZTtcblxuICBwcm90b3R5cGUuY3JlYXRlT2ZmZXIgPVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU9mZmVyKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gKGFyZ3VtZW50cy5sZW5ndGggPj0gMikgPyBhcmd1bWVudHNbMl0gOiBhcmd1bWVudHNbMF07XG4gICAgICBjb25zdCBwcm9taXNlID0gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG4gICAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH1cbiAgICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcblxuICBwcm90b3R5cGUuY3JlYXRlQW5zd2VyID1cbiAgICBmdW5jdGlvbiBjcmVhdGVBbnN3ZXIoc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSA/IGFyZ3VtZW50c1syXSA6IGFyZ3VtZW50c1swXTtcbiAgICAgIGNvbnN0IHByb21pc2UgPSBvcmlnQ3JlYXRlQW5zd2VyLmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG4gICAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH1cbiAgICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcblxuICBsZXQgd2l0aENhbGxiYWNrID0gZnVuY3Rpb24oZGVzY3JpcHRpb24sIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IHNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2Rlc2NyaXB0aW9uXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPSB3aXRoQ2FsbGJhY2s7XG5cbiAgd2l0aENhbGxiYWNrID0gZnVuY3Rpb24oZGVzY3JpcHRpb24sIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IHNldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkZXNjcmlwdGlvbl0pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIHByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHdpdGhDYWxsYmFjaztcblxuICB3aXRoQ2FsbGJhY2sgPSBmdW5jdGlvbihjYW5kaWRhdGUsIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IGFkZEljZUNhbmRpZGF0ZS5hcHBseSh0aGlzLCBbY2FuZGlkYXRlXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZSA9IHdpdGhDYWxsYmFjaztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1HZXRVc2VyTWVkaWEod2luZG93KSB7XG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yO1xuXG4gIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgLy8gc2hpbSBub3QgbmVlZGVkIGluIFNhZmFyaSAxMi4xXG4gICAgY29uc3QgbWVkaWFEZXZpY2VzID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcztcbiAgICBjb25zdCBfZ2V0VXNlck1lZGlhID0gbWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5iaW5kKG1lZGlhRGV2aWNlcyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSAoY29uc3RyYWludHMpID0+IHtcbiAgICAgIHJldHVybiBfZ2V0VXNlck1lZGlhKHNoaW1Db25zdHJhaW50cyhjb25zdHJhaW50cykpO1xuICAgIH07XG4gIH1cblxuICBpZiAoIW5hdmlnYXRvci5nZXRVc2VyTWVkaWEgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJlxuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uIGdldFVzZXJNZWRpYShjb25zdHJhaW50cywgY2IsIGVycmNiKSB7XG4gICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cylcbiAgICAgICAgLnRoZW4oY2IsIGVycmNiKTtcbiAgICB9LmJpbmQobmF2aWdhdG9yKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKSB7XG4gIGlmIChjb25zdHJhaW50cyAmJiBjb25zdHJhaW50cy52aWRlbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sXG4gICAgICBjb25zdHJhaW50cyxcbiAgICAgIHt2aWRlbzogdXRpbHMuY29tcGFjdE9iamVjdChjb25zdHJhaW50cy52aWRlbyl9XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBjb25zdHJhaW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1SVENJY2VTZXJ2ZXJVcmxzKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBtaWdyYXRlIGZyb20gbm9uLXNwZWMgUlRDSWNlU2VydmVyLnVybCB0byBSVENJY2VTZXJ2ZXIudXJsc1xuICBjb25zdCBPcmlnUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb247XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9XG4gICAgZnVuY3Rpb24gUlRDUGVlckNvbm5lY3Rpb24ocGNDb25maWcsIHBjQ29uc3RyYWludHMpIHtcbiAgICAgIGlmIChwY0NvbmZpZyAmJiBwY0NvbmZpZy5pY2VTZXJ2ZXJzKSB7XG4gICAgICAgIGNvbnN0IG5ld0ljZVNlcnZlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwY0NvbmZpZy5pY2VTZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IHNlcnZlciA9IHBjQ29uZmlnLmljZVNlcnZlcnNbaV07XG4gICAgICAgICAgaWYgKHNlcnZlci51cmxzID09PSB1bmRlZmluZWQgJiYgc2VydmVyLnVybCkge1xuICAgICAgICAgICAgdXRpbHMuZGVwcmVjYXRlZCgnUlRDSWNlU2VydmVyLnVybCcsICdSVENJY2VTZXJ2ZXIudXJscycpO1xuICAgICAgICAgICAgc2VydmVyID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzZXJ2ZXIpKTtcbiAgICAgICAgICAgIHNlcnZlci51cmxzID0gc2VydmVyLnVybDtcbiAgICAgICAgICAgIGRlbGV0ZSBzZXJ2ZXIudXJsO1xuICAgICAgICAgICAgbmV3SWNlU2VydmVycy5wdXNoKHNlcnZlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0ljZVNlcnZlcnMucHVzaChwY0NvbmZpZy5pY2VTZXJ2ZXJzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGNDb25maWcuaWNlU2VydmVycyA9IG5ld0ljZVNlcnZlcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IE9yaWdQZWVyQ29ubmVjdGlvbihwY0NvbmZpZywgcGNDb25zdHJhaW50cyk7XG4gICAgfTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSA9IE9yaWdQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIC8vIHdyYXAgc3RhdGljIG1ldGhvZHMuIEN1cnJlbnRseSBqdXN0IGdlbmVyYXRlQ2VydGlmaWNhdGUuXG4gIGlmICgnZ2VuZXJhdGVDZXJ0aWZpY2F0ZScgaW4gT3JpZ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiwgJ2dlbmVyYXRlQ2VydGlmaWNhdGUnLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBPcmlnUGVlckNvbm5lY3Rpb24uZ2VuZXJhdGVDZXJ0aWZpY2F0ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlcih3aW5kb3cpIHtcbiAgLy8gQWRkIGV2ZW50LnRyYW5zY2VpdmVyIG1lbWJlciBvdmVyIGRlcHJlY2F0ZWQgZXZlbnQucmVjZWl2ZXJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENUcmFja0V2ZW50ICYmXG4gICAgICAncmVjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSAmJlxuICAgICAgISgndHJhbnNjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlLCAndHJhbnNjZWl2ZXInLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB7cmVjZWl2ZXI6IHRoaXMucmVjZWl2ZXJ9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltQ3JlYXRlT2ZmZXJMZWdhY3kod2luZG93KSB7XG4gIGNvbnN0IG9yaWdDcmVhdGVPZmZlciA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXI7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU9mZmVyKG9mZmVyT3B0aW9ucykge1xuICAgICAgaWYgKG9mZmVyT3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIHN1cHBvcnQgYml0IHZhbHVlc1xuICAgICAgICAgIG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvID1cbiAgICAgICAgICAgICEhb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXVkaW9UcmFuc2NlaXZlciA9IHRoaXMuZ2V0VHJhbnNjZWl2ZXJzKCkuZmluZCh0cmFuc2NlaXZlciA9PlxuICAgICAgICAgIHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLmtpbmQgPT09ICdhdWRpbycpO1xuICAgICAgICBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gPT09IGZhbHNlICYmIGF1ZGlvVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICBpZiAoYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdzZW5kcmVjdicpIHtcbiAgICAgICAgICAgIGlmIChhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbikge1xuICAgICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbignc2VuZG9ubHknKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3NlbmRvbmx5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAncmVjdm9ubHknKSB7XG4gICAgICAgICAgICBpZiAoYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ2luYWN0aXZlJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvID09PSB0cnVlICYmXG4gICAgICAgICAgICAhYXVkaW9UcmFuc2NlaXZlcikge1xuICAgICAgICAgIHRoaXMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJywge2RpcmVjdGlvbjogJ3JlY3Zvbmx5J30pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBzdXBwb3J0IGJpdCB2YWx1ZXNcbiAgICAgICAgICBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9XG4gICAgICAgICAgICAhIW9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpZGVvVHJhbnNjZWl2ZXIgPSB0aGlzLmdldFRyYW5zY2VpdmVycygpLmZpbmQodHJhbnNjZWl2ZXIgPT5cbiAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjay5raW5kID09PSAndmlkZW8nKTtcbiAgICAgICAgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvID09PSBmYWxzZSAmJiB2aWRlb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnKSB7XG4gICAgICAgICAgICBpZiAodmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ3NlbmRvbmx5Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3JlY3Zvbmx5Jykge1xuICAgICAgICAgICAgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdpbmFjdGl2ZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgIXZpZGVvVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICB0aGlzLmFkZFRyYW5zY2VpdmVyKCd2aWRlbycsIHtkaXJlY3Rpb246ICdyZWN2b25seSd9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdDcmVhdGVPZmZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltQXVkaW9Db250ZXh0KHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgd2luZG93LkF1ZGlvQ29udGV4dCkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDtcbn1cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/webrtc-adapter/src/js/safari/safari_shim.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/webrtc-adapter/src/js/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compactObject: () => (/* binding */ compactObject),\n/* harmony export */   deprecated: () => (/* binding */ deprecated),\n/* harmony export */   detectBrowser: () => (/* binding */ detectBrowser),\n/* harmony export */   disableLog: () => (/* binding */ disableLog),\n/* harmony export */   disableWarnings: () => (/* binding */ disableWarnings),\n/* harmony export */   extractVersion: () => (/* binding */ extractVersion),\n/* harmony export */   filterStats: () => (/* binding */ filterStats),\n/* harmony export */   log: () => (/* binding */ log),\n/* harmony export */   walkStats: () => (/* binding */ walkStats),\n/* harmony export */   wrapPeerConnectionEvent: () => (/* binding */ wrapPeerConnectionEvent)\n/* harmony export */ });\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\nlet logDisabled_ = true;\nlet deprecationWarnings_ = true;\n\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */\nfunction extractVersion(uastring, expr, pos) {\n  const match = uastring.match(expr);\n  return match && match.length >= pos && parseFloat(match[pos], 10);\n}\n\n// Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object (or false to prevent\n// the event).\nfunction wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  const proto = window.RTCPeerConnection.prototype;\n  const nativeAddEventListener = proto.addEventListener;\n  proto.addEventListener = function(nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap) {\n      return nativeAddEventListener.apply(this, arguments);\n    }\n    const wrappedCallback = (e) => {\n      const modifiedEvent = wrapper(e);\n      if (modifiedEvent) {\n        if (cb.handleEvent) {\n          cb.handleEvent(modifiedEvent);\n        } else {\n          cb(modifiedEvent);\n        }\n      }\n    };\n    this._eventMap = this._eventMap || {};\n    if (!this._eventMap[eventNameToWrap]) {\n      this._eventMap[eventNameToWrap] = new Map();\n    }\n    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\n    return nativeAddEventListener.apply(this, [nativeEventName,\n      wrappedCallback]);\n  };\n\n  const nativeRemoveEventListener = proto.removeEventListener;\n  proto.removeEventListener = function(nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap || !this._eventMap\n        || !this._eventMap[eventNameToWrap]) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    if (!this._eventMap[eventNameToWrap].has(cb)) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\n    this._eventMap[eventNameToWrap].delete(cb);\n    if (this._eventMap[eventNameToWrap].size === 0) {\n      delete this._eventMap[eventNameToWrap];\n    }\n    if (Object.keys(this._eventMap).length === 0) {\n      delete this._eventMap;\n    }\n    return nativeRemoveEventListener.apply(this, [nativeEventName,\n      unwrappedCb]);\n  };\n\n  Object.defineProperty(proto, 'on' + eventNameToWrap, {\n    get() {\n      return this['_on' + eventNameToWrap];\n    },\n    set(cb) {\n      if (this['_on' + eventNameToWrap]) {\n        this.removeEventListener(eventNameToWrap,\n          this['_on' + eventNameToWrap]);\n        delete this['_on' + eventNameToWrap];\n      }\n      if (cb) {\n        this.addEventListener(eventNameToWrap,\n          this['_on' + eventNameToWrap] = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n}\n\nfunction disableLog(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + typeof bool +\n        '. Please use a boolean.');\n  }\n  logDisabled_ = bool;\n  return (bool) ? 'adapter.js logging disabled' :\n    'adapter.js logging enabled';\n}\n\n/**\n * Disable or enable deprecation warnings\n * @param {!boolean} bool set to true to disable warnings.\n */\nfunction disableWarnings(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + typeof bool +\n        '. Please use a boolean.');\n  }\n  deprecationWarnings_ = !bool;\n  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\n}\n\nfunction log() {\n  if (typeof window === 'object') {\n    if (logDisabled_) {\n      return;\n    }\n    if (typeof console !== 'undefined' && typeof console.log === 'function') {\n      console.log.apply(console, arguments);\n    }\n  }\n}\n\n/**\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\n */\nfunction deprecated(oldMethod, newMethod) {\n  if (!deprecationWarnings_) {\n    return;\n  }\n  console.warn(oldMethod + ' is deprecated, please use ' + newMethod +\n      ' instead.');\n}\n\n/**\n * Browser detector.\n *\n * @return {object} result containing browser and version\n *     properties.\n */\nfunction detectBrowser(window) {\n  // Returned result object.\n  const result = {browser: null, version: null};\n\n  // Fail early if it's not a browser\n  if (typeof window === 'undefined' || !window.navigator ||\n      !window.navigator.userAgent) {\n    result.browser = 'Not a browser.';\n    return result;\n  }\n\n  const {navigator} = window;\n\n  // Prefer navigator.userAgentData.\n  if (navigator.userAgentData && navigator.userAgentData.brands) {\n    const chromium = navigator.userAgentData.brands.find((brand) => {\n      return brand.brand === 'Chromium';\n    });\n    if (chromium) {\n      return {browser: 'chrome', version: parseInt(chromium.version, 10)};\n    }\n  }\n\n  if (navigator.mozGetUserMedia) { // Firefox.\n    result.browser = 'firefox';\n    result.version = parseInt(extractVersion(navigator.userAgent,\n      /Firefox\\/(\\d+)\\./, 1));\n  } else if (navigator.webkitGetUserMedia ||\n      (window.isSecureContext === false && window.webkitRTCPeerConnection)) {\n    // Chrome, Chromium, Webview, Opera.\n    // Version matches Chrome/WebRTC version.\n    // Chrome 74 removed webkitGetUserMedia on http as well so we need the\n    // more complicated fallback to webkitRTCPeerConnection.\n    result.browser = 'chrome';\n    result.version = parseInt(extractVersion(navigator.userAgent,\n      /Chrom(e|ium)\\/(\\d+)\\./, 2));\n  } else if (window.RTCPeerConnection &&\n      navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) { // Safari.\n    result.browser = 'safari';\n    result.version = parseInt(extractVersion(navigator.userAgent,\n      /AppleWebKit\\/(\\d+)\\./, 1));\n    result.supportsUnifiedPlan = window.RTCRtpTransceiver &&\n        'currentDirection' in window.RTCRtpTransceiver.prototype;\n    // Only for internal usage.\n    result._safariVersion = extractVersion(navigator.userAgent,\n      /Version\\/(\\d+(\\.?\\d+))/, 1);\n  } else { // Default fallthrough: not supported.\n    result.browser = 'Not a supported browser.';\n    return result;\n  }\n\n  return result;\n}\n\n/**\n * Checks if something is an object.\n *\n * @param {*} val The something you want to check.\n * @return true if val is an object, false otherwise.\n */\nfunction isObject(val) {\n  return Object.prototype.toString.call(val) === '[object Object]';\n}\n\n/**\n * Remove all empty objects and undefined values\n * from a nested object -- an enhanced and vanilla version\n * of Lodash's `compact`.\n */\nfunction compactObject(data) {\n  if (!isObject(data)) {\n    return data;\n  }\n\n  return Object.keys(data).reduce(function(accumulator, key) {\n    const isObj = isObject(data[key]);\n    const value = isObj ? compactObject(data[key]) : data[key];\n    const isEmptyObject = isObj && !Object.keys(value).length;\n    if (value === undefined || isEmptyObject) {\n      return accumulator;\n    }\n    return Object.assign(accumulator, {[key]: value});\n  }, {});\n}\n\n/* iterates the stats graph recursively. */\nfunction walkStats(stats, base, resultSet) {\n  if (!base || resultSet.has(base.id)) {\n    return;\n  }\n  resultSet.set(base.id, base);\n  Object.keys(base).forEach(name => {\n    if (name.endsWith('Id')) {\n      walkStats(stats, stats.get(base[name]), resultSet);\n    } else if (name.endsWith('Ids')) {\n      base[name].forEach(id => {\n        walkStats(stats, stats.get(id), resultSet);\n      });\n    }\n  });\n}\n\n/* filter getStats for a sender/receiver track. */\nfunction filterStats(result, track, outbound) {\n  const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';\n  const filteredResult = new Map();\n  if (track === null) {\n    return filteredResult;\n  }\n  const trackStats = [];\n  result.forEach(value => {\n    if (value.type === 'track' &&\n        value.trackIdentifier === track.id) {\n      trackStats.push(value);\n    }\n  });\n  trackStats.forEach(trackStat => {\n    result.forEach(stats => {\n      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n        walkStats(result, stats, filteredResult);\n      }\n    });\n  });\n  return filteredResult;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDTztBQUNQO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksT0FBTztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGFBQWE7QUFDcEQsR0FBRyxJQUFJO0FBQ1A7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbmxldCBsb2dEaXNhYmxlZF8gPSB0cnVlO1xubGV0IGRlcHJlY2F0aW9uV2FybmluZ3NfID0gdHJ1ZTtcblxuLyoqXG4gKiBFeHRyYWN0IGJyb3dzZXIgdmVyc2lvbiBvdXQgb2YgdGhlIHByb3ZpZGVkIHVzZXIgYWdlbnQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gdWFzdHJpbmcgdXNlckFnZW50IHN0cmluZy5cbiAqIEBwYXJhbSB7IXN0cmluZ30gZXhwciBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCBhcyBtYXRjaCBjcml0ZXJpYS5cbiAqIEBwYXJhbSB7IW51bWJlcn0gcG9zIHBvc2l0aW9uIGluIHRoZSB2ZXJzaW9uIHN0cmluZyB0byBiZSByZXR1cm5lZC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IGJyb3dzZXIgdmVyc2lvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RWZXJzaW9uKHVhc3RyaW5nLCBleHByLCBwb3MpIHtcbiAgY29uc3QgbWF0Y2ggPSB1YXN0cmluZy5tYXRjaChleHByKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+PSBwb3MgJiYgcGFyc2VGbG9hdChtYXRjaFtwb3NdLCAxMCk7XG59XG5cbi8vIFdyYXBzIHRoZSBwZWVyY29ubmVjdGlvbiBldmVudCBldmVudE5hbWVUb1dyYXAgaW4gYSBmdW5jdGlvblxuLy8gd2hpY2ggcmV0dXJucyB0aGUgbW9kaWZpZWQgZXZlbnQgb2JqZWN0IChvciBmYWxzZSB0byBwcmV2ZW50XG4vLyB0aGUgZXZlbnQpLlxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgZXZlbnROYW1lVG9XcmFwLCB3cmFwcGVyKSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByb3RvID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgY29uc3QgbmF0aXZlQWRkRXZlbnRMaXN0ZW5lciA9IHByb3RvLmFkZEV2ZW50TGlzdGVuZXI7XG4gIHByb3RvLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihuYXRpdmVFdmVudE5hbWUsIGNiKSB7XG4gICAgaWYgKG5hdGl2ZUV2ZW50TmFtZSAhPT0gZXZlbnROYW1lVG9XcmFwKSB7XG4gICAgICByZXR1cm4gbmF0aXZlQWRkRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBjb25zdCB3cmFwcGVkQ2FsbGJhY2sgPSAoZSkgPT4ge1xuICAgICAgY29uc3QgbW9kaWZpZWRFdmVudCA9IHdyYXBwZXIoZSk7XG4gICAgICBpZiAobW9kaWZpZWRFdmVudCkge1xuICAgICAgICBpZiAoY2IuaGFuZGxlRXZlbnQpIHtcbiAgICAgICAgICBjYi5oYW5kbGVFdmVudChtb2RpZmllZEV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYihtb2RpZmllZEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fZXZlbnRNYXAgPSB0aGlzLl9ldmVudE1hcCB8fCB7fTtcbiAgICBpZiAoIXRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0pIHtcbiAgICAgIHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0gPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uc2V0KGNiLCB3cmFwcGVkQ2FsbGJhY2spO1xuICAgIHJldHVybiBuYXRpdmVBZGRFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIFtuYXRpdmVFdmVudE5hbWUsXG4gICAgICB3cmFwcGVkQ2FsbGJhY2tdKTtcbiAgfTtcblxuICBjb25zdCBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyID0gcHJvdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgcHJvdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKG5hdGl2ZUV2ZW50TmFtZSwgY2IpIHtcbiAgICBpZiAobmF0aXZlRXZlbnROYW1lICE9PSBldmVudE5hbWVUb1dyYXAgfHwgIXRoaXMuX2V2ZW50TWFwXG4gICAgICAgIHx8ICF0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdKSB7XG4gICAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uaGFzKGNiKSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgY29uc3QgdW53cmFwcGVkQ2IgPSB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLmdldChjYik7XG4gICAgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5kZWxldGUoY2IpO1xuICAgIGlmICh0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLnNpemUgPT09IDApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fZXZlbnRNYXApLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50TWFwO1xuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBbbmF0aXZlRXZlbnROYW1lLFxuICAgICAgdW53cmFwcGVkQ2JdKTtcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdvbicgKyBldmVudE5hbWVUb1dyYXAsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF07XG4gICAgfSxcbiAgICBzZXQoY2IpIHtcbiAgICAgIGlmICh0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lVG9XcmFwLFxuICAgICAgICAgIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdKTtcbiAgICAgICAgZGVsZXRlIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdO1xuICAgICAgfVxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWVUb1dyYXAsXG4gICAgICAgICAgdGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF0gPSBjYik7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVMb2coYm9vbCkge1xuICBpZiAodHlwZW9mIGJvb2wgIT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0FyZ3VtZW50IHR5cGU6ICcgKyB0eXBlb2YgYm9vbCArXG4gICAgICAgICcuIFBsZWFzZSB1c2UgYSBib29sZWFuLicpO1xuICB9XG4gIGxvZ0Rpc2FibGVkXyA9IGJvb2w7XG4gIHJldHVybiAoYm9vbCkgPyAnYWRhcHRlci5qcyBsb2dnaW5nIGRpc2FibGVkJyA6XG4gICAgJ2FkYXB0ZXIuanMgbG9nZ2luZyBlbmFibGVkJztcbn1cblxuLyoqXG4gKiBEaXNhYmxlIG9yIGVuYWJsZSBkZXByZWNhdGlvbiB3YXJuaW5nc1xuICogQHBhcmFtIHshYm9vbGVhbn0gYm9vbCBzZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIHdhcm5pbmdzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZVdhcm5pbmdzKGJvb2wpIHtcbiAgaWYgKHR5cGVvZiBib29sICE9PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdBcmd1bWVudCB0eXBlOiAnICsgdHlwZW9mIGJvb2wgK1xuICAgICAgICAnLiBQbGVhc2UgdXNlIGEgYm9vbGVhbi4nKTtcbiAgfVxuICBkZXByZWNhdGlvbldhcm5pbmdzXyA9ICFib29sO1xuICByZXR1cm4gJ2FkYXB0ZXIuanMgZGVwcmVjYXRpb24gd2FybmluZ3MgJyArIChib29sID8gJ2Rpc2FibGVkJyA6ICdlbmFibGVkJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2coKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChsb2dEaXNhYmxlZF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5sb2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2hvd3MgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHN1Z2dlc3RpbmcgdGhlIG1vZGVybiBhbmQgc3BlYy1jb21wYXRpYmxlIEFQSS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcHJlY2F0ZWQob2xkTWV0aG9kLCBuZXdNZXRob2QpIHtcbiAgaWYgKCFkZXByZWNhdGlvbldhcm5pbmdzXykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLndhcm4ob2xkTWV0aG9kICsgJyBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlICcgKyBuZXdNZXRob2QgK1xuICAgICAgJyBpbnN0ZWFkLicpO1xufVxuXG4vKipcbiAqIEJyb3dzZXIgZGV0ZWN0b3IuXG4gKlxuICogQHJldHVybiB7b2JqZWN0fSByZXN1bHQgY29udGFpbmluZyBicm93c2VyIGFuZCB2ZXJzaW9uXG4gKiAgICAgcHJvcGVydGllcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdEJyb3dzZXIod2luZG93KSB7XG4gIC8vIFJldHVybmVkIHJlc3VsdCBvYmplY3QuXG4gIGNvbnN0IHJlc3VsdCA9IHticm93c2VyOiBudWxsLCB2ZXJzaW9uOiBudWxsfTtcblxuICAvLyBGYWlsIGVhcmx5IGlmIGl0J3Mgbm90IGEgYnJvd3NlclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdy5uYXZpZ2F0b3IgfHxcbiAgICAgICF3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkge1xuICAgIHJlc3VsdC5icm93c2VyID0gJ05vdCBhIGJyb3dzZXIuJztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgY29uc3Qge25hdmlnYXRvcn0gPSB3aW5kb3c7XG5cbiAgLy8gUHJlZmVyIG5hdmlnYXRvci51c2VyQWdlbnREYXRhLlxuICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudERhdGEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEuYnJhbmRzKSB7XG4gICAgY29uc3QgY2hyb21pdW0gPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YS5icmFuZHMuZmluZCgoYnJhbmQpID0+IHtcbiAgICAgIHJldHVybiBicmFuZC5icmFuZCA9PT0gJ0Nocm9taXVtJztcbiAgICB9KTtcbiAgICBpZiAoY2hyb21pdW0pIHtcbiAgICAgIHJldHVybiB7YnJvd3NlcjogJ2Nocm9tZScsIHZlcnNpb246IHBhcnNlSW50KGNocm9taXVtLnZlcnNpb24sIDEwKX07XG4gICAgfVxuICB9XG5cbiAgaWYgKG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEpIHsgLy8gRmlyZWZveC5cbiAgICByZXN1bHQuYnJvd3NlciA9ICdmaXJlZm94JztcbiAgICByZXN1bHQudmVyc2lvbiA9IHBhcnNlSW50KGV4dHJhY3RWZXJzaW9uKG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAvRmlyZWZveFxcLyhcXGQrKVxcLi8sIDEpKTtcbiAgfSBlbHNlIGlmIChuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhIHx8XG4gICAgICAod2luZG93LmlzU2VjdXJlQ29udGV4dCA9PT0gZmFsc2UgJiYgd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgIC8vIENocm9tZSwgQ2hyb21pdW0sIFdlYnZpZXcsIE9wZXJhLlxuICAgIC8vIFZlcnNpb24gbWF0Y2hlcyBDaHJvbWUvV2ViUlRDIHZlcnNpb24uXG4gICAgLy8gQ2hyb21lIDc0IHJlbW92ZWQgd2Via2l0R2V0VXNlck1lZGlhIG9uIGh0dHAgYXMgd2VsbCBzbyB3ZSBuZWVkIHRoZVxuICAgIC8vIG1vcmUgY29tcGxpY2F0ZWQgZmFsbGJhY2sgdG8gd2Via2l0UlRDUGVlckNvbm5lY3Rpb24uXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnY2hyb21lJztcbiAgICByZXN1bHQudmVyc2lvbiA9IHBhcnNlSW50KGV4dHJhY3RWZXJzaW9uKG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAvQ2hyb20oZXxpdW0pXFwvKFxcZCspXFwuLywgMikpO1xuICB9IGVsc2UgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJlxuICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQXBwbGVXZWJLaXRcXC8oXFxkKylcXC4vKSkgeyAvLyBTYWZhcmkuXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnc2FmYXJpJztcbiAgICByZXN1bHQudmVyc2lvbiA9IHBhcnNlSW50KGV4dHJhY3RWZXJzaW9uKG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAvQXBwbGVXZWJLaXRcXC8oXFxkKylcXC4vLCAxKSk7XG4gICAgcmVzdWx0LnN1cHBvcnRzVW5pZmllZFBsYW4gPSB3aW5kb3cuUlRDUnRwVHJhbnNjZWl2ZXIgJiZcbiAgICAgICAgJ2N1cnJlbnREaXJlY3Rpb24nIGluIHdpbmRvdy5SVENSdHBUcmFuc2NlaXZlci5wcm90b3R5cGU7XG4gICAgLy8gT25seSBmb3IgaW50ZXJuYWwgdXNhZ2UuXG4gICAgcmVzdWx0Ll9zYWZhcmlWZXJzaW9uID0gZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgIC9WZXJzaW9uXFwvKFxcZCsoXFwuP1xcZCspKS8sIDEpO1xuICB9IGVsc2UgeyAvLyBEZWZhdWx0IGZhbGx0aHJvdWdoOiBub3Qgc3VwcG9ydGVkLlxuICAgIHJlc3VsdC5icm93c2VyID0gJ05vdCBhIHN1cHBvcnRlZCBicm93c2VyLic7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHNvbWV0aGluZyBpcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHNvbWV0aGluZyB5b3Ugd2FudCB0byBjaGVjay5cbiAqIEByZXR1cm4gdHJ1ZSBpZiB2YWwgaXMgYW4gb2JqZWN0LCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhbGwgZW1wdHkgb2JqZWN0cyBhbmQgdW5kZWZpbmVkIHZhbHVlc1xuICogZnJvbSBhIG5lc3RlZCBvYmplY3QgLS0gYW4gZW5oYW5jZWQgYW5kIHZhbmlsbGEgdmVyc2lvblxuICogb2YgTG9kYXNoJ3MgYGNvbXBhY3RgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGFjdE9iamVjdChkYXRhKSB7XG4gIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyhkYXRhKS5yZWR1Y2UoZnVuY3Rpb24oYWNjdW11bGF0b3IsIGtleSkge1xuICAgIGNvbnN0IGlzT2JqID0gaXNPYmplY3QoZGF0YVtrZXldKTtcbiAgICBjb25zdCB2YWx1ZSA9IGlzT2JqID8gY29tcGFjdE9iamVjdChkYXRhW2tleV0pIDogZGF0YVtrZXldO1xuICAgIGNvbnN0IGlzRW1wdHlPYmplY3QgPSBpc09iaiAmJiAhT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aDtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCBpc0VtcHR5T2JqZWN0KSB7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjY3VtdWxhdG9yLCB7W2tleV06IHZhbHVlfSk7XG4gIH0sIHt9KTtcbn1cblxuLyogaXRlcmF0ZXMgdGhlIHN0YXRzIGdyYXBoIHJlY3Vyc2l2ZWx5LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdhbGtTdGF0cyhzdGF0cywgYmFzZSwgcmVzdWx0U2V0KSB7XG4gIGlmICghYmFzZSB8fCByZXN1bHRTZXQuaGFzKGJhc2UuaWQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlc3VsdFNldC5zZXQoYmFzZS5pZCwgYmFzZSk7XG4gIE9iamVjdC5rZXlzKGJhc2UpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgaWYgKG5hbWUuZW5kc1dpdGgoJ0lkJykpIHtcbiAgICAgIHdhbGtTdGF0cyhzdGF0cywgc3RhdHMuZ2V0KGJhc2VbbmFtZV0pLCByZXN1bHRTZXQpO1xuICAgIH0gZWxzZSBpZiAobmFtZS5lbmRzV2l0aCgnSWRzJykpIHtcbiAgICAgIGJhc2VbbmFtZV0uZm9yRWFjaChpZCA9PiB7XG4gICAgICAgIHdhbGtTdGF0cyhzdGF0cywgc3RhdHMuZ2V0KGlkKSwgcmVzdWx0U2V0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qIGZpbHRlciBnZXRTdGF0cyBmb3IgYSBzZW5kZXIvcmVjZWl2ZXIgdHJhY2suICovXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyU3RhdHMocmVzdWx0LCB0cmFjaywgb3V0Ym91bmQpIHtcbiAgY29uc3Qgc3RyZWFtU3RhdHNUeXBlID0gb3V0Ym91bmQgPyAnb3V0Ym91bmQtcnRwJyA6ICdpbmJvdW5kLXJ0cCc7XG4gIGNvbnN0IGZpbHRlcmVkUmVzdWx0ID0gbmV3IE1hcCgpO1xuICBpZiAodHJhY2sgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmlsdGVyZWRSZXN1bHQ7XG4gIH1cbiAgY29uc3QgdHJhY2tTdGF0cyA9IFtdO1xuICByZXN1bHQuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgaWYgKHZhbHVlLnR5cGUgPT09ICd0cmFjaycgJiZcbiAgICAgICAgdmFsdWUudHJhY2tJZGVudGlmaWVyID09PSB0cmFjay5pZCkge1xuICAgICAgdHJhY2tTdGF0cy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICB0cmFja1N0YXRzLmZvckVhY2godHJhY2tTdGF0ID0+IHtcbiAgICByZXN1bHQuZm9yRWFjaChzdGF0cyA9PiB7XG4gICAgICBpZiAoc3RhdHMudHlwZSA9PT0gc3RyZWFtU3RhdHNUeXBlICYmIHN0YXRzLnRyYWNrSWQgPT09IHRyYWNrU3RhdC5pZCkge1xuICAgICAgICB3YWxrU3RhdHMocmVzdWx0LCBzdGF0cywgZmlsdGVyZWRSZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGZpbHRlcmVkUmVzdWx0O1xufVxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/webrtc-adapter/src/js/utils.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);